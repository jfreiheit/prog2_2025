{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programmieren II","text":"<p>Herzlich willkommen zur Programmieren II-Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben:</p> <ol> <li>L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben!</li> <li>Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen!</li> <li>Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. </li> <li>Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren...</li> <li>Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens.</li> <li>Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid!</li> </ol> <p>Viel Erfolg! Und viel Spa\u00df!</p>"},{"location":"#organisatorisches","title":"Organisatorisches","text":"<p>Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt:</p> <ul> <li>Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht.</li> <li>Die Veranstaltungen finden in Pr\u00e4senz statt. Es werden keine Videos erstellt.</li> <li>Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. </li> <li>Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen.</li> <li>Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen.</li> <li>Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben.</li> <li>Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu</li> </ul> <p>Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Bitte beachten Sie, dass das Modul erfahrungsgem\u00e4\u00df nur dann bestanden werden kann, wenn Sie die \u00dcbungen und Aufgaben selbstst\u00e4ndig l\u00f6sen k\u00f6nnen. Selbst wenn Ihnen zun\u00e4chst eine eigene L\u00f6sung schwerf\u00e4llt, m\u00fcssen Sie es irgendwann im Laufe des Semsters - am besten, jeweils so schnell wie m\u00f6glich - schaffen, diese Aufgaben selbstst\u00e4ndig zu implementieren.</p> <p>Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung.  </p> <p>Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen, die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen.  </p> <p>F\u00fcr die Kommunikation untereinander verwenden wir Slack. Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!</p>"},{"location":"#grober-inhalt-kann-sich-noch-andern","title":"Grober Inhalt (kann sich noch \u00e4ndern)","text":"<p>Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln.  </p> <p>Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). </p> Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 07.-11.04.2025 Organisatorisches, Wiederholung, Einstieg \u00dcbung 2 \u00a0- - 1. 14.-18.04.2025 Aufz\u00e4hlungstypen, Wrapper-Klassen (boxing und unboxing) \u00dcbung 3 Aufgabe 1 27.04.2025 2. 21.-25.04.2025 Exceptions \u00dcbung 4 Aufgabe 2 04.05.2025 3. 28.-02.05.2025 eigene Exceptions \u00dcbung 5 Aufgabe 3 18.05.2025 4. 05.-09.05.2025 Collections (List und Set) \u00dcbung 6 Aufgabe 4 25.05.2025 5. 12.-15.05.2025 Collections (Map) und Abstrakte Klassen \u00dcbung 7 Aufgabe 5 01.06.2025 6. 19.-23.05.2025 Interfaces \u00dcbung 8 Aufgabe 6 08.06.2025 7. 26.-30.05.2025 Lambdas \u00dcbung 9 Aufgabe 7 15.06.2025 8. 02.-06.06.2025 Java-Streams \u00dcbung 10 Aufgabe 8 22.06.2025 9. 09.-13.06.2025 Genererics \u00dcbung 11 Aufgabe 9 29.06.2025 10. 16.-20.06.2025 JUnit \u00dcbung 12 Aufgabe 10 06.07.2025 11. 23.-27.06.2025 Test driven development \u00dcbung 13 \u00a0- - 12. 30.-04.07.2025 Klausurvorbereitung \u00dcbung 14 \u00a0- - 13. 07.-11.07.2025 Klausurvorbereitung \u00dcbung 15 \u00a0- - 14.07.2025 09:45 Uhr Klausur 1.PZ C 635 und C 639 - - 29.09.2025 09:45 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - -"},{"location":"#inhalte","title":"Inhalte","text":"Einf\u00fchrung und Organisatorisches + Wiederholung + Einstieg <ul> <li>siehe Organisatorisches</li> <li>siehe Wiederholung</li> <li>siehe Einstieg</li> <li>siehe \u00dcbung 2</li> </ul> Code aus der Vorlesung 09.04.2025 Main.javaRectangle.java <pre><code>import javax.swing.*;\nimport java.util.Arrays;\n\npublic class Main\n{\n    public static void main(String[] args)\n    {\n         int[] numbers = {1, 2,  3, 4, 5, 6, 7, 8, 9, 10};\n         for(var values : numbers)\n         {\n             System.out.print(values + \", \");\n         }\n         System.out.println(Arrays.toString(numbers));\n\n         String s1 = \"Hello FIW! \\n \" + \"Welcome to FIW!\";\n         String s2 = \"\"\"\n                 Hello FIW!\n                 Hello FIW!\n                 Welcome to FIW!\n                 &lt;html&gt;\n                    &lt;h1&gt;Hello FIW!&lt;/h1&gt;\n                    &lt;p&gt;Hello FIW!&lt;/p&gt;\n                        &lt;a href=\"www.\"\n                 &lt;/html&gt;\"\"\";\n         System.out.println(s2 + \" Hallo \");\n\n         Rectangle r1  = new Rectangle(5, 6);\n         Rectangle r2 = new Rectangle(6, 7);\n         Rectangle r3 = new Rectangle(5, 6);\n         System.out.println(r1.toString());\n         System.out.println(r2.toString());\n         System.out.println(r3.toString());\n         System.out.println(\"r1 equals r2 ?  \" + r1.equals(r2));\n         System.out.println(\"r1 equals r3 ?  \" + r1.equals(r3));\n\n         JOptionPane.showMessageDialog(null, \"Hello FIW!\", \"Titel FIW!\", JOptionPane.QUESTION_MESSAGE);\n         String input = JOptionPane.showInputDialog(null, \"Geben Sie eine Zahl ein:\");\n         System.out.println(\"Sie haben \" + input + \" eingegeben\");\n    }\n}\n</code></pre> <pre><code>public record Rectangle(double width, double length){}\n</code></pre> Aufz\u00e4hlungstypen und Wrapper-Klassen <ul> <li>siehe Aufz\u00e4hlungstypen </li> <li>siehe Wrapper-Klassen (boxing und unboxing)</li> <li>siehe \u00dcbung 3</li> <li>siehe Aufgabe 1</li> </ul> Code aus der Vorlesung 14.04.2025 Vorlesung1404.javaDay.java <pre><code>package vorlesungen.vorl1404;\n\nimport javax.swing.*;\n\npublic class Vorlesung1404\n{\n    enum Ziffern {N0, N1,  }\n    public static boolean istWochenende(Day tag)\n    {\n        return (tag == Day.SAMSTAG || tag == Day.SONNTAG);\n    }\n\n    public static boolean istWochentag(Day tag)\n    {\n        return !istWochenende(tag);\n    }\n    public static void main(String[] args)\n    {\n        String tag = \"hallo\";\n        int day = 0;    // Montag\n        Day dayTag = Day.DIENSTAG;\n\n        System.out.println(istWochentag(dayTag));\n\n        String eingabe = JOptionPane.showInputDialog(null, \"Geben Sie ein Zahl ein : \");\n        System.out.println(\"Ihre Eingabe war \" + eingabe);\n\n        Integer io1 = Integer.valueOf(-1234);\n        Double do1 = Double.valueOf(-1234.0);\n        Integer io2 = 1234;\n        Double do2 = 1234.0;\n\n        int wert1 = io1.intValue();\n        double wert2 = do1.doubleValue();\n        int wert3 = io1;\n\n        String si1 = \"1234\";\n        Integer io3 = Integer.valueOf(eingabe);\n        int wert4 = Integer.parseInt(eingabe);\n        System.out.println(\"Eingabe war \" + wert4);\n\n        String s = io3.toString();\n\n        Integer io5 = 5000;\n        Integer io6 = 5000;\n        Integer io7 = 5001;\n        System.out.println(io5 == io6);\n        System.out.println(io7 &gt;= io6);\n\n        Float fo1 = Float.valueOf(\"-1234.0\");\n        Float fo2 = -1234.0f;\n        float f3 = fo1.floatValue();\n\n        int[][] matrix = new int[3][4];\n        for(int row = 0; row &lt; matrix.length; row++)\n        {\n            for(int col = 0; col &lt; matrix[row].length; col++)\n            {\n                matrix[row][col] = (row + 1) * (col + 1);\n                System.out.print(row + \",\" + col + \" \");\n            }\n            System.out.println();\n        }\n\n        System.out.println();\n\n        for(int row = 0; row &lt; matrix.length; row++)\n        {\n            for(int col = 0; col &lt; matrix[row].length; col++)\n            {\n                System.out.print(matrix[row][col] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl1404;\n\npublic enum Day\n{\n    MONTAG, DIENSTAG, MITTWOCHE, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG\n}\n</code></pre> Exceptions behandeln (<code>try-catch</code>, <code>throws</code>) <ul> <li>siehe Exceptions </li> <li>siehe \u00dcbung 4</li> <li>siehe Aufgabe 2</li> </ul> Code aus der Vorlesung 23.04.2025 <pre><code>package vorlesungen.vorl1423;\n\nimport javax.swing.*;\n\npublic class Ausnahmen\n{\n    static char charAt(String s, int index) throws Exception\n    {\n        char c = ' ';\n        c = s.charAt(index);\n        return c;\n    }\n\n    static int divide(int divident, int divisor) throws ArithmeticException\n    {\n        int result = 0;\n        result = divident / divisor; // kritisch, wenn divisor 0\n        return result;\n    }\n\n    static int inputInt()\n    {\n        boolean validInput = false;\n        int number = 0;\n        String message = \"Geben Sie eine Zahl ein!\";\n        while(!validInput)\n        {\n            String input = JOptionPane.\n                    showInputDialog(null,message\n                            );\n\n            try {\n                number = Integer.parseInt(input);\n                validInput = true;      // nur ausgefuehrt, wenn keine\n                                        // Exception geworfen wurde\n            } catch (RuntimeException e) {\n                message = \"Das war keine Zahl! Bitte Zahl!\";\n            }\n        }\n        return number;\n    }\n\n    public static void main(String[] args)\n    {\n        char c = ' ';\n        try {\n            c = charAt(\"Hallo\", 7);\n        } catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n        System.out.println(c);\n\n        int result = 0;\n        try {\n            result = divide(10, 0);\n        } catch(ArithmeticException e) {\n            e.printStackTrace();\n            System.out.println(e.getMessage());\n        }\n\n        System.out.println(result);\n\n        System.out.println(inputInt());\n\n        String[] basen = {\"2\", \"8\", \"10\", \"Hi\"};\n        for(int index = 0; index &lt;= 4; index++)\n        {\n            try {\n                String wert = basen[index];\n\n                int number = Integer.parseInt(wert);\n            }\n            catch(NumberFormatException e) {\n                System.err.println(\"keine Zahl!\");\n            }\n            catch(ArrayIndexOutOfBoundsException e) {\n                System.err.println(\"kein passender Index!\");\n            }\n        }\n        System.out.println(\"Ende\");\n    }\n}\n</code></pre> eigene Exceptions werfen (<code>throw</code>) <ul> <li>siehe Exceptions </li> <li>siehe \u00dcbung 5</li> <li>siehe Aufgabe 3</li> </ul> Code aus der Vorlesung 28.04.2025 Programmklasse.javaTriangle.javaIllegalSideLengthException.javaIllegalTriangleException.java <pre><code>package vorlesungen.vorl0428;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Programmklasse\n{\n    public static void mehrereExceptions()\n    {\n        String[] basen = {\"2\", \"8\", \"10\", \"Hi\"};\n        int base = 0;\n        double result= 0;\n        boolean ok = true;\n\n        for(int index = 0; index&lt;=4; index++)\n        {\n            try {\n                base = Integer.parseInt(basen[index]);\n                ok = true;\n            }\n            catch(NumberFormatException nfe) {\n                System.out.println(\"Keine Zahl!\");\n                ok = false;\n            }\n            catch(IndexOutOfBoundsException ioobe) {\n                System.out.println(\"Ausserhalb des Arrays\");\n                ok = false;\n            }\n            for(int exp = 0; exp&lt;6 &amp;&amp; ok; exp++) {\n                result = Math.pow(base, exp);\n                System.out.printf(\"%d ^ %d = %.0f %n\", base, exp, result);\n            }\n        }\n    }\n\n    static int getValueAtIndex(int[] field, int index) throws ArrayIndexOutOfBoundsException\n    {\n        return field[index];\n    }\n\n    public static void main(String[] args)\n    {\n        mehrereExceptions();\n\n        int value = 0;\n        boolean ok = true;\n        int[] field = {8, 3,-4, 2, -9};\n        try\n        {\n            value = getValueAtIndex(field,-3);\n        }\n        catch(ArrayIndexOutOfBoundsException e)\n        {\n            System.out.println(\"Index ausserhalb des Arrays!\");\n            ok = false;\n        }\n        if(ok)\n        {\n            System.out.println(\"value : \" + value);\n        }\n\n        Triangle t = null;\n        try {\n            t = new Triangle(3, 0, 5);\n        }\n        catch(IllegalSideLengthException e) {\n            System.out.println(e.getMessage());\n        }\n        catch(IllegalTriangleException e) {\n            System.out.println(e.getMessage());\n        }\n        if(t == null) {\n            System.out.println(\"kein Objekt!\");\n        }\n\n        /*\n        try {\n            Triangle t2 = new Triangle(3, 1, 5);\n        } catch (IllegalSideLengthException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalTriangleException e) {\n            throw new RuntimeException(e);\n        }\n\n         */\n\n        int[] arr = { 1, 2, 3 };\n        for(int el : arr)\n        {\n            System.out.println(\"element : \" + el);\n        }\n\n        Set&lt;String&gt; s1 = new HashSet&lt;&gt;();     // Menge erzeugen\n        s1.add(\"eins\");\n        s1.add(\"zwei\");\n        s1.add(\"drei\");\n        //s1.add(Integer.valueOf(4));     // prinzipiell moeglich, aber schlecht\n\n        for(String element : s1)\n        {\n            System.out.println(\"element : \" + element);\n        }\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0428;\n\npublic class Triangle\n{\n    private int a,b,c;\n\n    public Triangle(int a, int b, int c) throws IllegalSideLengthException, IllegalTriangleException\n    {\n        if (a &lt;= 0 || b &lt;= 0 || c &lt;= 0) {\n            throw new IllegalSideLengthException(\"sides must be greater than zero! is: (\"+a+\",\"+b+\",\"+c+\")\");\n        }\n        else if (a &gt;= (b + c) || b &gt;= (c + a) || c &gt;= (a + b)) {\n            throw new IllegalTriangleException();\n        }\n        else {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0428;\n\npublic class IllegalSideLengthException extends Exception\n{\n    public IllegalSideLengthException(String message) {\n        super(message);\n    }\n\n    public IllegalSideLengthException() {\n        super(\"sides must be greater than zero!\");\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0428;\n\npublic class IllegalTriangleException extends Exception\n{\n    public IllegalTriangleException(String message)\n    {\n        super(message);\n    }\n\n    public IllegalTriangleException()\n    {\n        super(\"Illegal triangle!\");\n    }\n}\n</code></pre> Collections (Listen und Mengen) <ul> <li>siehe Collections </li> <li>siehe \u00dcbung 6</li> <li>siehe Aufgabe 4</li> </ul> Code aus der Vorlesung 05.05.2025 <pre><code>package vorlesungen.vorl0505;\n\nimport java.util.*;\n\npublic class Vorlesung0505\n{\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n----------- Listen ------------------%n%n\");\n        List&lt;String&gt; list1 = new ArrayList&lt;&gt;();\n        list1.add(\"eins\");\n        //list1.add(2);       // Integer\n        list1.add(\"zwei\");\n        for(String str : list1)\n        {\n            System.out.println(str);\n        }\n        System.out.println(list1.size());\n        list1.remove(\"eins\");\n        list1.remove(0);\n\n        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\n        list2.add(1);\n        list2.add(2);\n        list2.add(3);\n        list2.add(4);\n        for(Integer i : list2)\n        {\n            System.out.print(i + \" \");          // 1 2 3 4\n        }\n        Integer v1 = list2.get(0);  // Index 0\n        System.out.println(v1);     // 1\n\n        System.out.println();\n        list2.remove(0);\n        for(Integer i : list2)\n        {\n            System.out.print(i + \" \");          // 2 3 4\n        }\n        // v1 = 1\n        v1 = list2.get(0);              // Index 0\n        // v1 = 2\n        System.out.println(v1);         // 2\n        list2.remove(Integer.valueOf(3));   // Objekt geloescht\n        for(Integer i : list2)\n        {\n            System.out.print(i + \" \");      // 2 4\n        }\n        System.out.println();\n        list2.add(2);\n        list2.add(4);\n        list2.add(2);\n        for(Integer i : list2)\n        {\n            System.out.print(i + \" \");      // 2 4 2 4 2\n        }\n        System.out.println();\n        System.out.println(list2.remove(Integer.valueOf(2)));\n        for(Integer i : list2)\n        {\n            System.out.print(i + \" \");      // 4 2 4 2\n        }\n        System.out.println();\n        List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();\n        list3.add(2);\n        list3.add(3);\n        list3.add(4);\n        list2.removeAll(list3);             // false\n        if(list2.size() == 0) System.out.println(\"list2 is empty\");\n        for(Integer i : list2)\n        {\n            System.out.print(i + \" \");      // 4 2 4 2\n        }\n        System.out.println();\n        list2.add(1);\n        list2.add(2);\n        list2.add(1);\n        list2.add(1);\n        list2.add(2);\n        list2.add(1);\n        Integer v3 = Integer.valueOf(1);\n        while(list2.contains(v3))\n        {\n            list2.remove(v3);\n        }\n\n        System.out.printf(\"%n%n----------- Mengen ------------------%n%n\");\n        Set&lt;String&gt; set1 = new HashSet&lt;&gt;();\n        System.out.println(set1.add(\"vier\"));       // true\n        System.out.println(set1.add(\"eins\"));       // true\n        System.out.println(set1.add(\"zwei\"));       // true\n        System.out.println(set1.add(\"zwei\"));       // false\n        System.out.println(set1.add(\"drei\"));       // true\n        for(String str : set1)\n        {\n            System.out.print(str + \" \");        // eins vier zwei drei\n        }\n\n        System.out.printf(\"%n%n----------- Maps ------------------%n%n\");\n        Map&lt;String, Double&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(\"s05123456\", 1.0);     // true\n        map1.put(\"s05654321\", 1.3);     // true\n        map1.put(\"s05111111\", 1.7);     // true\n        map1.put(\"s05654321\", 2.3);     // false\n\n        Set&lt;String&gt; allKeys = map1.keySet();\n        for(String key : allKeys)\n        {\n            System.out.print(key + \" \");\n        }\n        System.out.println();\n        Collection&lt;Double&gt; allValues = map1.values();\n        for(Double val : allValues)\n        {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map1.entrySet();\n        for(Map.Entry&lt;String, Double&gt; entry : entries)\n        {\n\n        }\n\n    }\n}\n</code></pre> Collections (Maps, Abstrakte Klassen und Interfaces) <ul> <li>siehe Abstrakte Klassen </li> <li>siehe Interfaces </li> <li>siehe \u00dcbung 7</li> <li>siehe \u00dcbung 8</li> <li>siehe Aufgabe 5</li> </ul> Code aus der Vorlesung 12.05.2025 Vorlesung0512.javaShape.javaRectangle.javaCircle.java <pre><code>package vorlesungen.vorl0512;\n\nimport java.util.*;\n\npublic class Vorlesung0512\n{\n    public static void printPerimeter(Shape shape)\n    {\n        System.out.println(\"Umfang ist \" + shape.perimeter());\n    }\n\n    public static void printArea(Shape shape)\n    {\n        System.out.println(\"Flaecheninhalt ist \" + shape.area());\n    }\n\n    public static void sortieren(Comparable[] unsorted)\n    {\n        for(int bubble = 1; bubble &lt; unsorted.length; bubble++)\n        {\n            for(int index = 0; index &lt; unsorted.length - bubble; index++)\n            {\n                if(unsorted[index].compareTo(unsorted[index + 1]) &gt; 0)\n                {\n                    Comparable temp = unsorted[index];\n                    unsorted[index] = unsorted[index + 1];\n                    unsorted[index + 1] = temp;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Map&lt;String, String&gt; accounts = new HashMap();\n        accounts.put(\"anton\", \"anton@email.de\");\n        accounts.put(\"berta\", \"berta@email.de\");\n        accounts.put(\"cesar\", \"cesar@email.de\");\n        accounts.put(\"anton\", \"anton2@email.de\");\n\n        String valueAnton = accounts.remove(\"anton\");\n        System.out.println(valueAnton);\n        /* alle Schluessel */\n        Set&lt;String&gt; allKeys = accounts.keySet();\n        for(String key : allKeys)\n        {\n            System.out.print(key + \" \");    // ceaser berta anton\n        }\n        System.out.println();\n\n        /* alle Werte */\n        Collection&lt;String&gt; allValues = accounts.values();\n        for(String value : allValues)\n        {\n            System.out.print(value + \" \");\n        }\n        System.out.println();\n\n        /* alle Schluessel-Werte-Paare */\n        Set&lt;Map.Entry&lt;String, String&gt;&gt; allEntries = accounts.entrySet();\n        for(Map.Entry&lt;String, String&gt; entry : allEntries)\n        {\n            System.out.println(\"key : \" + entry.getKey() + \" , value : \" + entry.getValue());\n        }\n\n        Shape s1 = new Circle(3.0);\n        Shape s2 = new Rectangle(3,4);\n        printPerimeter(s1);\n        printArea(s1);\n        printPerimeter(s2);\n        printArea(s2);\n        Circle c1 = new Circle(1.0);\n        System.out.println(c1.perimeter());\n        System.out.println(c1.area());\n        System.out.println(c1.getDiameter());\n        System.out.println(s1.perimeter());\n        System.out.println(s1.area());\n        //System.out.println(s1.getDiameter());     // keine Eigenschaft von Shape\n        printPerimeter(c1);\n        printArea(c1);\n\n        Shape[] shapes = new Shape[4];\n        shapes[0] = s1;\n        shapes[1] = s2;\n        shapes[2] = c1;\n        shapes[3] = new Rectangle(4,2);\n        for(Shape s : shapes)\n        {\n            printPerimeter(s);\n            printArea(s);\n            System.out.println(s.toString());\n        }\n\n        String str1 = \"Anton\";\n        String str2 = \"Berta\";\n        System.out.println(str1.compareTo(str2));\n\n        Rectangle[] rectArr = new Rectangle[7];\n        rectArr[0] = new Rectangle(9, 13);  // 117\n        rectArr[1] = new Rectangle(4, 17);  // 68\n        rectArr[2] = new Rectangle(12, 5);  // 60\n        rectArr[3] = new Rectangle(8, 9);   // 72\n        rectArr[4] = new Rectangle(10, 11); // 110\n        rectArr[5] = new Rectangle(5, 15);  // 75\n        rectArr[6] = new Rectangle(5, 10);  // 50\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n                /*\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n\n        sortieren(rectArr);\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n\n         */\n\n        System.out.printf(\"%n%n------------------------- treeSet ---------------------------%n%n\");\n        Set&lt;Rectangle&gt; treeSet = new TreeSet&lt;Rectangle&gt;();\n        for(Rectangle r : rectArr)\n        {\n            treeSet.add(r);\n        }\n        for(Rectangle r : treeSet)\n        {\n            System.out.println(r.toString());\n        }\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0512;\n\npublic abstract class Shape\n{\n    public abstract double perimeter();\n    public abstract double area();\n\n}\n</code></pre> <pre><code>package vorlesungen.vorl0512;\n\npublic class Rectangle extends Shape\n{\n    int width;\n    int height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter()\n    {\n        return 2 * (this.width + this.height);\n    }\n\n    @Override\n    public double area()\n    {\n        return this.width * this.height;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"Rectangle [width=\" + this.width + \", height=\" + this.height + \"]\";\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0512;\n\npublic class Circle extends Shape\n{\n    double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n    public double getDiameter()\n    {\n        return 2 * this.radius;\n    }\n\n    @Override\n    public double perimeter()\n    {\n        return Math.PI * this.getDiameter();\n    }\n\n    @Override\n    public double area()\n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"Circle [radius=\" + this.radius + \"]\";\n    }\n}\n</code></pre> Functional Interfaces und Lambdas <ul> <li>siehe Functional Interfaces </li> <li>siehe Lambda-Ausdr\u00fccke </li> <li>siehe \u00dcbung 9</li> <li>siehe Aufgabe 6</li> </ul> Code aus der Vorlesung 26.05.2025 Main.java <pre><code>package vorlesungen.vorl0526;\n\nimport java.util.List;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class Main\n{\n    public static void printValue(Printable printable, String s)\n    {\n        printable.print(s);\n    }\n\n    public static void main(String[] args)\n    {\n        /*\n        UseInterface useInterface = new UseInterface();\n        printValue(useInterface, \"Hallo FIW!\");\n         */\n\n        /*\n        printValue(new Printable(){\n\n            @Override\n            public void print(String s)\n            {\n                System.out.println(s);\n            }\n        }, \"Hallo anonyme Klasse\");\n        */\n\n\n        printValue(p1 -&gt; System.out.println(p1), \"Hallo!\");\n\n        List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);\n        numbers.forEach(n -&gt; System.out.println(n));\n        numbers.forEach(System.out::println);\n\n        numbers.forEach(Integer::valueOf);\n\n        List&lt;String&gt; staedte = List.of(\"Berlin\", \"Hamburg\", \"M\u00fcnchen\", \"K\u00f6ln\", \"Frankfurt am Main\", \"D\u00fcsseldorf\",\n                \"Stuttgart\", \"Leipzig\", \"Dortmund\", \"Bremen\", \"Essen\" ,\"Dresden\");\n\n        staedte.forEach(stadt -&gt; {\n            System.out.print(stadt + \" \");\n            stadt = stadt.toUpperCase();\n            System.out.println(stadt);\n        });\n\n        Consumer&lt;String&gt; printConsumer = message -&gt; System.out.println(message);\n        staedte.forEach(printConsumer);\n\n        Function&lt;String, Integer&gt; lengthOfString = str -&gt; str.length();\n        BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;\n\n    }\n}\n</code></pre> Printable.javaUseInterface.java <pre><code>package vorlesungen.vorl0526;\n\n@FunctionalInterface\npublic interface Printable\n{\n    // abstrakte Methode - Single Abstract Method (SAM)\n    public void print(String s);\n\n    // public void print(String s, int i);\n    // in Functional Interfaces genau eine abtrakte Methode\n\n    default void print()\n    {\n        print(\"default\");\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0526;\n\npublic class UseInterface implements Printable\n{\n\n    @Override\n    public void print(String s)\n    {\n        System.out.println(\"UseInterface : \" + s);\n    }\n}\n</code></pre> Streams <ul> <li>siehe Streams </li> <li>siehe Optionals </li> <li>siehe \u00dcbung 10</li> <li>siehe \u00dcbung 11</li> <li>siehe Aufgabe 7</li> <li>siehe Aufgabe 8</li> </ul> Code aus der Vorlesung 02.06.2025 Main.javaPerson.java <pre><code>package vorlesungen.vorl0602;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main\n{\n    private static List&lt;Person&gt; getPersonen() {\n        List&lt;Person&gt; personen = List.of(\n                new Person(\"Alice\", \"Ankara\"),\n                new Person(\"Alice\", \"Caracas\"),\n                new Person(\"Barbara\", \"Bern\"),\n                new Person(\"Barbara\", \"Damaskus\"),\n                new Person(\"Conny\", \"Caracas\"),\n                new Person(\"Conny\", \"Bern\"),\n                new Person(\"Daniela\", \"Damaskus\"),\n                new Person(\"Daniela\", \"Caracas\"),\n                new Person(\"Elvira\",\"Bern\" ),\n                new Person(\"Elvira\",\"Ankara\" ),\n                new Person(\"Frieda\", \"Caracas\"),\n                new Person(\"Gerda\", \"Ankara\"),\n                new Person(\"Hannah\", \"Hanoi\"),\n                new Person(\"Ina\", \"Islamabad\"),\n                new Person(\"Jana\", \"Hanoi\")\n        );\n        return personen;\n    }\n\n    public static void main(String[] args)\n    {\n        List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);\n        List&lt;Integer&gt; results = numbers.stream()\n                .filter( e -&gt; e % 2 == 0)\n                .map( evenNumber -&gt; evenNumber * 10 )\n                .collect(Collectors.toList());\n\n        results.forEach(s -&gt; System.out.println(s));\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0602;\n\npublic record Person(String name, String stadt){\n    @Override\n    public String toString()\n    {\n        return String.format(\"%s aus %s\", name, stadt);\n    }\n}\n</code></pre> Code aus der Vorlesung 16.06.2025 VorlesungStreams.java <pre><code>package vorlesungen.vorl0616;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class VorlesungStreams\n{\n    public record Rectangle(int width, int length)\n    {\n        public int area()\n        {\n            return this.width * this.length;\n        }\n    }\n\n    public static Optional&lt;String&gt; getValue(Map&lt;String, String&gt; map, String key)\n    {\n        if(map.containsKey(key))\n        {\n            return Optional.of(map.get(key));\n        }\n        else return Optional.empty();\n    }\n\n    public static void main(String[] args)\n    {\n        Map&lt;String, String&gt; studiengaenge = new HashMap&lt;&gt;();\n        studiengaenge.put(\"fiw\", \"Informatik und Wirtschaft\");\n        studiengaenge.put(\"ai\", \"Angewandte Informatik\");\n        studiengaenge.put(\"imi\", \"Internationale Medieninformatik\");\n        studiengaenge.put(\"ikg\", \"Informatik, Kultur und Gesundheit\");\n        System.out.println(studiengaenge.get(\"ai\").toUpperCase());\n        //System.out.println(studieng\u00e4nge.get(\"wi\").toUpperCase());\n\n        Optional&lt;String&gt; value = getValue(studiengaenge, \"ai\");\n        if(value.isPresent()) {\n            System.out.println(value.get());\n        }\n        value = getValue(studiengaenge, \"wi\");\n        if(value.isPresent()) {\n            System.out.println(value.get());\n        }\n        else\n        {\n            System.out.println(\"wi nicht vorhanden\");\n        }\n\n\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        List&lt;String&gt; words1 = List.of(\"eins\", \"zwei\", \"drei\", \"vier\", \"fuenf\");\n        List&lt;String&gt; words2 = List.of(\"abc\", \"a\", \"abcd\", \"abcde\", \"ab\");\n\n        words1.stream()\n                .forEach(s -&gt; System.out.println(s.toUpperCase()));\n        words1.stream()\n                .map(s -&gt; s.toUpperCase())\n                .forEach(s -&gt; System.out.println(s));\n\n        words1.stream()\n                .mapToInt(s -&gt; s.length())\n                .forEach(s -&gt; System.out.println(s));\n\n        Set&lt;Rectangle&gt; rectangles = new HashSet&lt;&gt;();\n        rectangles.add(new Rectangle(1, 2));\n        rectangles.add(new Rectangle(3, 2));\n        rectangles.add(new Rectangle(1, 4));\n        rectangles.add(new Rectangle(3, 4));\n        rectangles.add(new Rectangle(2, 5));\n        rectangles.add(new Rectangle(4, 2));\n        rectangles.add(new Rectangle(2, 4));\n\n        List&lt;Rectangle&gt; rectList = rectangles.stream()\n                .collect(Collectors.toList());\n\n        Map&lt;Integer, List&lt;Rectangle&gt;&gt; rectArea = rectangles.stream()\n                .collect(Collectors.groupingBy(r -&gt; r.width()));\n\n        for(Map.Entry&lt;Integer, List&lt;Rectangle&gt;&gt; entry : rectArea.entrySet())\n        {\n            Integer key = entry.getKey();\n            List&lt;Rectangle&gt; rectangleList = entry.getValue();\n            System.out.println(key + \" \" + rectangleList);\n        }\n\n        List&lt;Integer&gt; numbers1 = List.of(1, 2, 3, 4);\n        Integer sum = numbers1.stream()\n                .reduce(0, (a,b) -&gt; a + b);\n        System.out.println(\"sum = \" + sum);\n\n        Integer product = numbers1.stream()\n                .reduce(1, (a,b) -&gt; a * b);\n        System.out.println(\"product = \" + product);\n\n        numbers1.stream()\n                .filter(n -&gt; n % 2 == 0)\n                .forEach(s -&gt; System.out.println(s));\n\n        Random r = new Random();\n        Stream&lt;Integer&gt; s1 = Stream.generate(() -&gt; r.nextInt(10)).limit(10);\n        s1.forEach(s -&gt; System.out.println(s));\n\n        Stream&lt;Integer&gt; s2 = Stream.iterate(0, i -&gt; i + 1).limit(100);\n        s2.forEach(s -&gt; System.out.println(s));\n    }\n}\n</code></pre> JUnit <ul> <li>siehe JUnit-Tests </li> <li>siehe \u00dcbung 12</li> <li>siehe Aufgabe 9</li> </ul> Code aus der Vorlesung 23.06.2025 Fakultaet.javaFakultaetTest.javaMain.java <pre><code>package vorlesungen.vorl0623;\n\npublic class Fakultaet {\n\n    public long fakultaet(int number) throws IllegalArgumentException\n    {\n        if(number &lt; 1)\n        {\n            throw new IllegalArgumentException(\"Zahl muss groesser gleich 1 sein!\");\n        }\n        long result = 1;\n        for(int i = 2; i &lt;= number; i++)\n        {\n            long tmp = result;\n            result *= i;\n            if(tmp &gt; result)\n            {\n                throw new IllegalArgumentException(\"Overflow!\");\n            }\n        }\n        return result;\n    }\n\n    public void print(int number)\n    {\n        System.out.printf(\"%3d! = %,d %n\", number, fakultaet(number));\n    }\n\n}\n</code></pre> <pre><code>package vorlesungen.vorl0623;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FakultaetTest\n{\n    @Test\n    public void testFakultaet6()\n    {\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        long result = f.fakultaet(6);\n\n        // then\n        long expected = 720;\n        assertEquals(expected, result, \"6! should be 720!\");\n    }\n\n    @Test\n    public void testFakultaet1()\n    {\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        long result = f.fakultaet(1);\n\n        // then\n        long expected = 1;\n        //assertEquals(expected, result, \"1! should be 1\");\n        assertTrue(expected == result, \"1! should be 1\");\n    }\n\n    @Test\n    public void testSmallerThan1()\n    {\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; f.fakultaet(0));\n\n        // then\n        assertEquals(\"Zahl muss groesser gleich 1 sein!\",  exception.getMessage());\n    }\n\n\n    @Test\n    public void testOverflow()\n    {\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; f.fakultaet(21));\n\n        // then\n        assertEquals(\"Overflow!\",  exception.getMessage());\n    }\n\n    @Test\n    void testFakultaetPrint6()\n    {\n        PrintStream originalOut = System.out;       // System.out merken (Standardausgabegeraet Konsole)\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        System.setOut(new PrintStream(out));\n\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        f.print(6);\n\n        // then\n        assertEquals(\"  6! = 720 \\n\", out.toString(), \"should print 6! = 720 with linebreak\");\n        System.setOut(originalOut);                 // System.out wieder auf das Standardausgabegeraet setzen\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0623;\n\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Fakultaet f1 = new Fakultaet();\n        int nr = 0;\n        while(nr &lt; 22)\n        {\n            try {\n                f1.print(nr);\n            }\n            catch(IllegalArgumentException e) {\n                System.out.println(\"number = \" + nr + \" : \" + e.getMessage());\n            }\n            nr++;\n        }\n    }\n}\n</code></pre> Code aus der Vorlesung 25.06.2025 UmrechnungTimeZeit.javaTestUmrechnungTimeZeit.javaPower.javaPowerTest.java <pre><code>package vorlesungen.vorl0625;\n\npublic class UmrechnungTimeZeit\n{\n    private boolean isDigit(char c)\n    {\n        return c &gt;= '0' &amp;&amp; c &lt;= '9';\n    }\n\n    public String convert(String time) throws IllegalArgumentException\n    {\n        if(!isDigit(time.charAt(0))) throw new IllegalArgumentException(\"no digit\");\n        final int HOURS_MINUTES = 4;\n        String zeit = time.substring(0, HOURS_MINUTES);\n        return zeit;\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0625;\n\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class TestUmrechnungTimeZeit\n{\n    @Test\n    @DisplayName(\"1:00 am converts to 1:00\")\n    public void testUmrechnungTimeZeit1am()\n    {\n        // given (preparation)\n        UmrechnungTimeZeit utz =  new UmrechnungTimeZeit();\n\n        // when (execution)\n        String time = \"1:00 am\";\n        String zeit = utz.convert(time);\n\n        // then (validation)\n        String expected = \"1:00\";\n        assertEquals(expected, zeit, time + \" should be converted to \" + expected);\n    }\n\n    @Test\n    @DisplayName(\"2:00 am converts to 2:00\")\n    public void testUmrechnungTimeZeit2am()\n    {\n        // given (preparation)\n        UmrechnungTimeZeit utz =  new UmrechnungTimeZeit();\n\n        // when (execution)\n        String time = \"2:00 am\";\n        String zeit = utz.convert(time);\n\n        // then (validation)\n        String expected = \"2:00\";\n        assertEquals(expected, zeit, time + \" should be converted to \" + expected);\n    }\n\n    @Test\n    @DisplayName(\"2:15 am converts to 2:15\")\n    public void testUmrechnungTimeZeit215am()\n    {\n        // given (preparation)\n        UmrechnungTimeZeit utz =  new UmrechnungTimeZeit();\n\n        // when (execution)\n        String time = \"2:15 am\";\n        String zeit = utz.convert(time);\n\n        // then (validation)\n        String expected = \"2:15\";\n        assertEquals(expected, zeit, time + \" should be converted to \" + expected);\n    }\n\n    @Test\n    @DisplayName(\"exception if time does not start with digit\")\n    public void testUmrechnungTimeZeitNoDigitAtBeginning()\n    {\n        // given (preparation)\n        UmrechnungTimeZeit utz =  new UmrechnungTimeZeit();\n\n        // when (execution)\n        String time = \"hallo\";\n        Exception e = assertThrows(IllegalArgumentException.class, () -&gt; utz.convert(time));\n\n        // then (validation)\n        assertEquals(\"no digit\", e.getMessage());\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0625;\n\npublic class Power {\n\n    private int base;\n    private int exp;\n\n    public Power(int base, int exp)\n    {\n        this.base = base;\n        this.exp = exp;\n    }\n\n    public double value()\n    {\n        double value = 1.0;\n        if(exp &gt; 0)\n        {\n            for(int i=0; i&lt;exp; i++)\n            {\n                value *= base;\n            }\n        }\n        else\n        {\n            for(int i=0; i&lt;-exp; i++)\n            {\n                value *= base;\n            }\n            value = 1.0 / value;\n        }\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"(\" + this.base + \"^\" + this.exp + \")\";\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        Power p = (Power)o;\n        return (this.base==p.base &amp;&amp; this.exp==p.exp);\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return 7*this.base + 11*this.exp;\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl0625;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass PowerTest {\n    static Power p1,p2,p3,p4;\n    static int testnr = 1;\n\n    @BeforeAll\n    public static void setup()\n    {\n        p1 = new Power(2,3);\n        p2 = new Power(2,3);\n        p3 = new Power(-2,3);\n        p4 = new Power(2,-3);\n    }\n\n    @BeforeEach\n    public void printBeforeTests()\n    {\n        System.out.printf(\"%n %n --------------- Test %d ------------ %n\", testnr);\n        p1.print();\n        p2.print();\n        testnr++;\n    }\n\n\n    @Test\n    void testToString() {\n        String s = p1.toString();\n\n        assertEquals(\"(2^3)\", s, \"Strings are not equal!\");\n    }\n\n    @Test\n    void testPower() {\n        assertNotNull(p1, \"no Power object\");\n    }\n\n    @Test\n    void testValue() {\n        double value = p1.value();\n\n        assertEquals(8.0, value, \"2^3 should be 8.0\");\n    }\n\n    @Test\n    public void testEqualsObject() {\n        assertTrue(p1.equals(p2), \" 2^3 should be equal to 2^3!\");\n    }\n}\n</code></pre>"},{"location":"abstrakt/","title":"Abstrakte Klassen","text":"<p>Abstrakte Klassen  haben wir bereits verwendet, ohne bis her zu wissen, worum es sich dabei handelt. Wenn wir uns nochmal die \"Vererbungshierarchie\" von <code>Collection</code> anschauen, dann finden wir darin</p> <ul> <li>Interfaces: die Klassen <code>Collection</code>, <code>List</code>, <code>Set</code>, <code>SortedSet</code> und <code>NavigableSet</code> sind solche Interfaces (dazu kommen wir in der n\u00e4chsten Lektion) und</li> <li>Abtrakte Klassen: die Klassen <code>AbstractCollection</code>, <code>AbstractList</code> und <code>AbstractSet</code> sind solche abstrakten Klassen (die schauen wir uns jetzt an)</li> </ul> <p></p>"},{"location":"abstrakt/#klassen-allgemein","title":"Klassen - allgemein","text":"<p>Wir haben uns bis jetzt Klassen erstellt, um </p> <ol> <li>sie als einen neuen (Referenz-)Typ zu verwenden, um</li> <li>von diesen Klassen zu erben und somit alle Eigenschaften (Variablen und Methoden) dieser Klasse wiederzuverwenden und um</li> <li>daraus Objekte zu erzeugen. Diese Objekte weisen alle die gleichen Eigenschaften (Variablen und Methoden) auf. Diese Eigenschaften sind entweder in der Klasse definiert, von der wir Objekte erzeugen oder sie wurden in dieser Klasse von einer anderen Klasse geerbt.  </li> </ol> <p>Angenommen, in der Klasse wurde eine Methode implementiert</p> <pre><code>public void eineImplementierteMethode()\n{\n    // Anweisungen\n}\n</code></pre> <p>, dann konnten alle Objekte, die wir von dieser Klasse erzeugt haben, diese Methode aufrufen und ausf\u00fchren <code>refVariable.eineImplementierteMethode();</code>. </p>"},{"location":"abstrakt/#klassen-abstrakt","title":"Klassen - abstrakt","text":"<p>Abstrakte Klassen sind etwas anders. Von ihnen k\u00f6nnen wir keine Objekte erzeugen. Das hei\u00dft, f\u00fcr abstrakte Klassen gelten nur die beiden ersten Punkte der oberen Aufz\u00e4hlung. Abstrakte Klassen werden erstellt, um </p> <ol> <li>sie als einen neuen (Referenz-)Typ zu verwenden, um</li> <li>von diesen Klassen alle Eigenschaften erben zu lassen. </li> </ol> <p>Der dritte obere Punkt gilt nicht! Wir k\u00f6nnen von abstrakten Klassen keine Objekte erzeugen. </p> <p>Eine abstrakte Klasse enth\u00e4lt eine oder mehrere abstrakte Methoden. Oder besser andersherum: Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse.</p>"},{"location":"abstrakt/#abstrakte-methoden","title":"Abstrakte Methoden","text":"<p>Abstrakte Methoden sind Methoden, die nicht implementiert sind, d.h. sie haben keinen Methodenrumpf. Eine abstrakte Methode besteht nur aus einem Methodenkopf (gefolgt von einem Semikolon):</p> <pre><code>public abstract void eineAbstrakteMethode();\n</code></pre> <p>Das Schl\u00fcsselwort <code>abstract</code> gibt an, dass die Methode nicht implementiert wird, sondern nur abstrakt beschreibt, </p> <ul> <li>wie der Name der Methode lautet,</li> <li>welche Parameter die Methode erwartet,</li> <li>wie der R\u00fcckgabetyp der Methode ist und</li> <li>wie der Sichtbarkeitsmodifizierer dieser Methode ist.</li> </ul> <p>Prinzipiell ist f\u00fcr abstrakte Methoden zu beachten, dass sie das Schl\u00fcsselwort <code>abstract</code> im Methodenkopf deklarieren und dass abstrakte Methode keinen Methodenrumpf haben, also keine <code>{ }</code>. Die Deklaration einer abstrakten Methode endet aber mit einem Semikolon!</p>"},{"location":"abstrakt/#verwendung-abstrakter-klassen","title":"Verwendung abstrakter Klassen","text":"<p>Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abtrakte Klassen dienen </p> <ol> <li>als Typ und </li> <li>als Basisklasse, d.h. von abstrakten Klassen wird geerbt.</li> </ol> <p>Von abstrakten Klassen abgeleitete Klassen (also Klassen, die von einer abstrakten Klasse erben), m\u00fcssen die geerbten Methoden implementieren (ansonsten w\u00e4ren sie selbst wieder abstrakt)!</p>"},{"location":"abstrakt/#ein-beispiel-die-abstrakte-klasse-shape","title":"Ein Beispiel - die abstrakte Klasse <code>Shape</code>","text":"<p>Wir erstellen uns eine abstrakte Klasse <code>Shape</code>, welche zwei abstrakte Methoden enth\u00e4lt, <code>perimeter()</code> und <code>area()</code>. </p> <pre><code>public abstract class Shape \n{   \n    public abstract double perimeter();\n    public abstract double area();\n\n}\n</code></pre> <p>Beachten Sie, dass eine Klasse selbst als <code>abstract</code> deklariert werden muss, wenn sie abstrakte Methoden enth\u00e4lt. Deshalb enth\u00e4lt die Klassendeklaration in Zeile <code>1</code> ebanfalls das Schl\u00fcsselwort <code>abstract</code>. Sie lie\u00dfe sich auch sonst gar nicht compilieren. </p>"},{"location":"abstrakt/#rectangle-erbt-von-shape","title":"<code>Rectangle</code> erbt von <code>Shape</code>","text":"<p><code>Shape</code> kann nun bereits als Typ verwendet werden. Es lassen sich aber keine Objekte von der Klasse <code>Shape</code> erzeugen. Vielmehr ist die Klasse <code>Shape</code> auch dazu da, um von ihr zu erben. Wir erzeugen uns deshalb eine Klasse <code>Rectangle</code>, die von <code>Shape</code> erbt. </p> <p>Wenn wir nun schreiben:</p> <pre><code>public class Rectangle extends Shape\n{\n\n}\n</code></pre> <p>dann ist <code>Rectangle</code> rot unterstrichen und Eclipse bietet uns zwei <code>QuickFixes</code> an:</p> <ol> <li><code>Add unimplemnted methods</code> oder</li> <li><code>Make type Rectangle abstract</code></li> </ol> <p>Durch das Erben von <code>Shape</code> haben wir auch die beiden abstrakten Methoden <code>perimeter()</code> und <code>area()</code> geerbt. Wir haben nun entweder die M\u00f6glichkeit, diese Methoden zu implementieren oder die Klasse <code>Rectangle</code> ist selbst eine abstrakte Klasse. Wir w\u00e4hlen <code>QuickFix 1</code> und lassen die Methoden hinzuf\u00fcgen: </p> <pre><code>public class Rectangle extends Shape\n{\n\n    @Override\n    public double perimeter() \n    {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public double area() \n    {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n}\n</code></pre> <p>Eclipse f\u00fcgt die zu implementierenden Methoden genau so ein, wie wir sie geerbt haben (also als <code>public</code> und mit R\u00fcckgabetyp <code>double</code> sowie den in <code>Shape</code> definierten Namen). Nun sind die beiden Methoden aber jeweils implementiert (aber noch nicht richtig - <code>TODO</code>). Da beide Methoden nun einen Methodenrumpf enthalten (Zeilen <code>6-9</code> und <code>13-16</code>), sind sie nicht mehr abstrakt und somit ist auch die Klasse <code>Rectangle</code> keine abstrakte Klasse. </p> <p>Eine sinnvolle Implementierung der Klasse <code>Rectangle</code> sieht z.B. so aus, dass wir zwei Objektvariablen definieren, die die Breite und H\u00f6he eines Rechtecks beschreiben, dass wir einen parametrisierten Konstruktor hinzuf\u00fcgen und dass wir unter Verwendung der Werte der Objektvariablen die Methoden <code>perimeter()</code> und <code>area()</code> sinnvoll implementieren: </p> <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n}\n</code></pre> <p>Nat\u00fcrlich k\u00f6nnte (und sollte) die Klasse auch noch geeignete Implementierungen f\u00fcr mindestens die von <code>Object</code> geerbten Methoden <code>equals()</code> und <code>toString()</code> enthalten. </p>"},{"location":"abstrakt/#circle-erbt-von-shape","title":"<code>Circle</code> erbt von <code>Shape</code>","text":"<p>Wir k\u00f6nnen beliebig oft von der Klasse <code>Shape</code> erben, d.h. wir k\u00f6nnen nun beliebig viele Klasse erstellen, die von der Klasse <code>Shape</code> erben. F\u00fcr jede dieser Klassen gilt nun:</p> <ul> <li>ein Objekt dieser Klasse (z.B. ein Objekt der Klasse <code>Rectangle</code>) \"besitzt\" die Methoden <code>perimeter()</code> und <code>area()</code>,</li> <li>ein Objekt dieser Klasse ist auch vom (Laufzeit-)Typ <code>Shape</code>. </li> </ul> <p>Wir erzeugen uns eine weitere Klasse, um diese Tatsachen n\u00e4her zu betrachten: </p> <pre><code>public class Circle extends Shape\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n}\n</code></pre>"},{"location":"abstrakt/#testen-der-klassen","title":"Testen der Klassen","text":"<p>Beispielsweise k\u00f6nnte nun in einer beliebigen Klasse eine Methode implementiert werden, in der ein <code>Shape</code> als Parameter verwendet wird und die f\u00fcr dieses <code>Shape</code> die Methode <code>perimeter()</code> oder <code>area()</code> aufruft. Es ist ja sicher, dass jedes Objekt vom Typ <code>Shape</code> diese Methoden als Eigenschaft \"besitzt\". Betrachten wir folgende <code>TestklasseShape</code>:</p> <pre><code>public class TestklasseShape \n{\n\n    public static void printPerimeter(Shape s)\n    {\n        System.out.printf(\"perimeter : %.2f cm%n\", s.perimeter());\n    }\n\n    public static void printArea(Shape s)\n    {\n        System.out.printf(\"area      : %.2f cm%n\", s.area());\n    }\n\n    public static double sumPerimeters(Shape[] shapes)\n    {\n        double sum = 0.0;\n        for(Shape s : shapes)\n        {\n            sum += s.perimeter();\n        }\n        return sum;\n    }\n\n    public static double sumAreas(Shape[] shapes)\n    {\n        double sum = 0.0;\n        for(Shape s : shapes)\n        {\n            sum += s.area();\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Rectangle(10, 20);\n        Shape s2 = new Circle(6.0);\n        printPerimeter(s1);\n        printPerimeter(s2);\n        printArea(s1);\n        printArea(s2);\n\n        Shape[] shapes = new Shape[4];\n        shapes[0] = s1;\n        shapes[1] = s2;\n        shapes[2] = new Rectangle(5,15);\n        shapes[3] = new Circle(10.0);\n        System.out.printf(\"sum of perimeters : %.2f cm%n\", sumPerimeters(shapes));\n        System.out.printf(\"sum of areas      : %.2f cm%n\", sumAreas(shapes));\n    }\n}\n</code></pre> <p>In dieser Testklasse sind vier Methoden implementiert, die als Parameter entweder Objekte vom Typ <code>Shape</code> oder vom Typ <code>Shape[]</code> erwarten. Von Objekten, die vom (Laufzeit-)Typ <code>Shape</code> sind, wissen wir, dass sie die Methoden <code>perimeter()</code> bzw. <code>area()</code> als Eigenschaften besitzen. Deshalb k\u00f6nnen wir diese Methoden auch in den jeweiligen Methoden f\u00fcr die <code>Shape</code>-Objekte aufrufen. </p> <p>Abstrakte Klassen fungieren also ein Muster f\u00fcr Klassen, die von den abstrakten Klassen erben, denn die abgeleiteten Klassen m\u00fcssen genau diese Methoden implementieren, die von den abstrakten Klassen vorgegeben sind. Ohne jetzt wirklich zu wissen, welche konkreten Klassen von dieser abstrakten Klasse erben und auch, ohne wirklich zu wissen, von welcher konkreten Klasse die Objekte erzeugt wurden (z.B. <code>Rectangle</code> oder <code>Circle</code>), so wissen wir doch, dass diese Objekte zumindest \u00fcber die Methoden <code>perimeter()</code> und <code>area()</code> verf\u00fcgen. </p>"},{"location":"abstrakt/#beispiele-aus-den-java-paketen","title":"Beispiele aus den Java-Paketen","text":"<p>In Java finden sich sehr viele abstrakte Klassen. Wir betrachten im Folgenden einige, zu denen wir bereits einen Bezug haben. </p>"},{"location":"abstrakt/#die-abstrakte-klasse-number","title":"Die abstrakte Klasse <code>Number</code>","text":"<p>Die Klasse Number aus dem <code>java.lang</code>-Paket ist eine abstrakte Klasse. In dieser Klasse sind folgende abstrakte Methoden definiert: </p> <ul> <li><code>abstract double doubleValue()</code></li> <li><code>abstract float  floatValue()</code></li> <li><code>abstract int    intValue()</code></li> <li><code>abstract long   longValue()</code></li> </ul> <p>Alle numerischen Wrapper-Klassen erben von <code>Number</code>, d.h. die Klassen <code>Byte</code>, <code>Double</code>, <code>Float</code>, <code>Integer</code>, <code>Long</code> und <code>Short</code> sind von <code>Number</code> abgeleitet. Das bedeutet, dass alle Objekte dieser konkreten Wrapper-Klassen auch vom Typ <code>Number</code> sind und somit die Methoden <code>doubleValue()</code>, <code>floatValue()</code>, <code>intValue()</code> und <code>longValue()</code> als Eigenschaften besitzen. Wir k\u00f6nnen also f\u00fcr alle solche Objekte diese Methoden aufrufen. </p>"},{"location":"abstrakt/#abstrakte-klassen-fur-collections","title":"Abstrakte Klassen f\u00fcr Collections","text":"<p>Beispiele f\u00fcr abstrakte Klassen finden wir auch im <code>java.util</code>-Paket f\u00fcr die Collections. Beispielsweise definiert die abstrakte Klasse AbstractCollection eine Reihe uns bereits bekannter Methoden, wie z.B. <code>add()</code>, <code>addAll()</code>, <code>clear()</code>, <code>contains()</code>, <code>isEmpty()</code>, <code>iterator()</code>, <code>remove()</code> usw. Alle Klassen, die von dieser Klasse erben, wie z.B. AbstractList und AbstractSet verf\u00fcgen also ebenfalls \u00fcber diese Methoden. Beachten Sie, dass diese beiden Klassen <code>AbstractList</code> und <code>AbstractSet</code> ebenfalls abstrakt sind! Von <code>AbstractSet</code> erben z.B. die Klassen <code>HashSet</code>, <code>TreeSet</code> und <code>EnumSet</code>. Erst von diesen konkreten Klassen k\u00f6nnen tats\u00e4chlich Objekte erzeugt werden. Alle diese Objekte besitzen aber (nat\u00fcrlich) die bereits in <code>AbstractCollection</code> definierten Methoden. </p> <p>Success</p> <p>Wir kennen jetzt abstrakte Klassen. Abstrakte Klassen sind Klassen, die abstrakte Methoden enthalten. Abstrakte Methoden sind Methoden, die nicht implementiert sind. Von abstrakten Klassen k\u00f6nnen wir keine Objekte erzeugen. Abstrakte Klassen dienen uns als Typen und wir k\u00f6nnen von abstrakten Klassen erben. Eine Klasse, die von einer abstrakten Klasse erbt, muss die geerbten abstrakten Methoden implementieren (oder sie ist selbst wieder abstrakt). Alle Klassen, die von einer abstrakten Klasse erben, implementieren also die Methoden genau so, wie sie von der abstrakten Klasse vorgegeben wurden, also mit der Methodensignatur (Name der Methode, Parameter, R\u00fcckgabetyp und Sichtbarkeitsmodifizierer). Jedes Objekt einer Klasse, welche von der abstrakten Klasse geerbt hat, ist auch vom Typ der abstrakten Klasse.</p>"},{"location":"aufgaben/","title":"Aufgaben","text":""},{"location":"aufgaben/#aufgabe-1-wurfelspiel","title":"Aufgabe 1 (W\u00fcrfelspiel)","text":"Aufgabe 1 <p>Vorbereitung (siehe Einstieg)</p> <ol> <li>Informieren Sie sich \u00fcber die Klasse <code>JOptionPane</code> aus dem Paket <code>javax.swing</code> (z.B. hier oder hier oder hier)  Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei <code>module-info.java</code> haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung <code>requires java.desktop;</code> einf\u00fcgen - das ist das Modul, in dem sich das Paket <code>javax.swing</code> befindet. </li> <li>Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch <code>Yes</code> und <code>No</code> stehen) und pr\u00fcfen Sie, ob der <code>Nein</code>- oder der <code>Ja</code>-Button gedr\u00fcckt wurde (im Beispiel steht <code>A</code> f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten):     </li> </ol> <p>Aufgabe</p> <ol> <li>Implementieren Sie folgendes W\u00fcrfelspiel:<ul> <li>An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen.</li> <li>Die Spieler sind nacheinander an der Reihe.</li> <li>Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch.</li> <li>In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder<ul> <li>eine 6 w\u00fcrfelt oder er</li> <li>den Versuch freiwillig beendet.  </li> </ul> </li> <li>Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit <code>0</code> Punkten bewertet.</li> <li>Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert).</li> </ul> </li> <li>Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. <code>20</code>) erreicht hat, hat gewonnen.      Beispiel mit zwei Spielern <code>A</code> und <code>B</code> bis Gesamtpunktzahl <code>20</code>:     </li> <li>Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!</li> </ol>"},{"location":"aufgaben/#aufgabe-2-myinteger","title":"Aufgabe 2 (MyInteger)","text":"Aufgabe 2 <p>Vorbereitung (Selbstudium)</p> <ol> <li> <p>Eine statische Variable wird mit dem Schl\u00fcsselwort <code>static</code> deklariert, also z.B. <code>static int myVariable = 0;</code>. Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable <code>myVariable</code> wurde in der Klasse <code>MyClass</code> deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber <code>MyClass.myVariable</code>. F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable.</p> </li> <li> <p>Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort <code>static</code> deklariert, also z.B. <code>public static void myMethod() {}</code>. Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode <code>myMethod()</code> wurde in der Klasse <code>MyClass</code> deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber <code>MyClass.myMethod()</code>. Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse <code>Math</code> statisch und wir k\u00f6nnen sie z.B. mit <code>Math.sqrt(value)</code> oder <code>Math.abs(value)</code> aufrufen.</p> </li> <li> <p>siehe z.B. hier oder hier oder hier</p> </li> </ol> <p>Aufgabe </p> <p>Die Klasse <code>MyInteger</code> ist eine sogenannte Wrapper-Klasse. Die Idee ist, dass <code>MyInteger</code> eine objektorientierte H\u00fclle um den <code>int</code>-Typ darstellt. Implementieren Sie die Klasse <code>MyInteger</code>. Diese Klasse hat folgende Eigenschaften:</p> <ol> <li>Statische Konstanten vom Typ <code>int</code> <code>MAX_VALUE</code> und <code>MIN_VALUE</code>, welche als Wert die gr\u00f6\u00dfte bzw. kleinste <code>int</code>-Zahl enthalten.</li> <li>Eine private Objektvariable <code>value</code> vom Typ <code>int</code>. (Dieser <code>value</code> hat jetzt eine \"objektorientierte\" H\u00fclle: <code>MyInteger</code>).</li> <li> <p>Eine statische Methode <code>parseInt(String s)</code>, die den \u00fcbergebenen <code>String s</code> als <code>int</code>-Zahl zur\u00fcckgibt, wenn <code>s</code> einer Zahl entspricht. Wenn nicht, wirft die Methode eine <code>IllegalArgumentException</code>. Beachten Sie:</p> <ol> <li><code>s</code> kann mit <code>+</code> oder <code>\u2013</code> beginnen,</li> <li><code>s</code> kann f\u00fchrende Nullen aufweisen,</li> <li>die L\u00e4nge von <code>s</code> kann mit <code>s.length()</code> ermittelt und jedes einzelne Zeichen aus <code>s</code> kann mit <code>s.charAt(index)</code> betrachtet werden. </li> <li>Ist <code>s</code> leer, wird eine <code>IllegalArgumentException</code> geworfen und wenn <code>s</code> keiner Zahl entspricht auch.</li> <li>Die Exception wird nur weitergereicht, nicht hier behandelt.</li> </ol> </li> <li> <p>Zwei Konstruktoren <code>MyInteger(int value)</code> und <code>MyInteger(String s)</code>, die jeweils die Objektvariable <code>value</code> initialisieren. Der zweite Konstruktor verwendet <code>parseInt(String)</code> und kann ebenfalls eine <code>IllegalArgumentException</code> werfen (reicht die Exception von <code>parseInt(String)</code> weiter). </p> </li> <li>Eine Objektmethode <code>intValue()</code>, die den Wert von <code>value</code> zur\u00fcckgibt.</li> <li>Eine Objektmethode <code>doubleValue()</code>, die den Wert von <code>value</code> als <code>double</code> zur\u00fcckgibt.</li> <li>Eine statische Methode <code>valueOf(String s)</code>, die ein Objekt von <code>MyInteger</code> erzeugt und zur\u00fcckgibt (und evtl. eine <code>IllegalArgumentException</code> wirft).</li> <li>Eine statische Methode <code>valueOf(int value)</code>, die ein Objekt von <code>MyInteger</code> erzeugt und zur\u00fcckgibt.</li> <li>\u00dcberschreiben Sie au\u00dferdem die Methoden <code>equals()</code> und <code>toString()</code> (Zusatz:  auch <code>hashCode()</code> \u00fcberschreiben).</li> <li>Testen Sie Ihre Klasse ausf\u00fchrlich in einer <code>Testklasse</code> mit <code>main()</code>-Methode.</li> <li>Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!</li> </ol>"},{"location":"aufgaben/#aufgabe-3-solitaire","title":"Aufgabe 3 (Solitaire)","text":"Aufgabe 3 <p>Information und Vorbereitung</p> <p>Wir wenden Aufz\u00e4hlungstypen und mehrdimensionale Arrays an. </p> <p>Wir beginnen, ein Englisches Solit\u00e4r zu programmieren. Einige kennen es auch als Steckhalma. Ziel des Spiels ist, alle Steine bis auf einen (der am besten in der Mitte \u00fcbrig bleibt), zu entfernen. Ein Zug ist wie folgt: ein Stein springt \u00fcber einen anderen Stein und der \u00fcbersprungene Stein wird entfernt. Es gibt viele L\u00f6sungen daf\u00fcr. </p> <p>Teil der Aufgabe ist es auch, \"fremden\" Code zu lesen und zu verstehen, denn einige Klassen sind bereits gegeben:</p> Klasse Point.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * ein Point repreasentiert eine Position\n * im Spielfeld, bestehend aus der Nummer \n * fuer die Zeile (row) und der Nummer\n * fuer die Spalte (col)\n */\npublic class Point {\n    private int row;\n    private int col;\n\n    /*\n     * Konstruktor zur Erzeugung einer \n     * Position bestehend aus row und col\n     */\n    public Point(int row, int col)\n    {\n        this.row = row;\n        this.col = col;\n    }\n\n    public int getRow() {\n        return this.row;\n    }\n\n    public int getCol() {\n        return this.col;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"(\"+ this.row + \",\" + this.col + \")\";\n    }\n}\n</code></pre> Klasse Move.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * diese Klasse repraesentiert einen Zug\n * Variablen sind Point from\n * und Point to\n * es wird nicht geprueft, ob der Zug ueberhaupt\n * moeglich ist\n */\npublic class Move {\n    private Point from;\n    private Point to;\n\n    /*\n     * ein Zug von dem from-Point (fromRow,fromCol)\n     * zum to-Point (toRow,toCol)\n     */\n    public Move(int fromRow, int fromCol, int toRow, int toCol)\n    {\n        this.from = new Point(fromRow, fromCol);\n        this.to = new Point(toRow, toCol);\n    }\n\n    /*\n     * in dem Konstruktor werden in this.from und this.to nicht einfach\n     * die Referenzen von from und to gespeichert, sondern davon Kopien\n     * erstellt, damit das Programm robuster gegen das Aendern von\n     * Referenzen ist\n     */\n    public Move(Point from, Point to)\n    {\n        this.from = new Point(from.getRow(), from.getCol());\n        this.to = new Point(to.getRow(), to.getCol());\n    }\n\n    /*\n     * der Getter fuer den Point from gibt keine Referenz auf\n     * den Point from zurueck, sondern eine Kopie (einen Klon)\n     * von from --&gt; Referenzen koennen \"verbogen\" werden, aber\n     * die Kopien bleiben unveraendert\n     */\n    public Point getFrom()\n    {\n        return new Point(this.from.getRow(), this.from.getCol());\n    }\n\n    /*\n     * der Getter fuer den Point to gibt keine Referenz auf\n     * den Point to zurueck, sondern eine Kopie (einen Klon)\n     * von to --&gt; Referenzen koennen \"verbogen\" werden, aber\n     * die Kopien bleiben unveraendert\n     */\n    public Point getTo()\n    {\n        return new Point(this.to.getRow(), this.to.getCol());\n    }\n\n}\n</code></pre> Klasse Moves.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * diese Klasse repraesentiert eine Folge \n * von Zuegen (Move), die in einem Array\n * moves gespeichert sind\n */\npublic class Moves {\n    private Move[] moves;\n\n    /*\n     * der Konstruktor erstellt ein leeres moves-Array\n     * (d.h. noch keine Zuege (Moves) gespeichert)\n     */\n    public Moves()\n    {\n        this.moves = new Move[0];\n    }\n\n    /*\n     * der Konstruktor erstellt ein moves-Array mit einem\n     * Move - dem erste Zug (firstMove) \n     */\n    public Moves(Move firstMove)\n    {\n        this.moves = new Move[1];\n        this.moves[0] = firstMove;\n    }\n\n    /*\n     * Anzahl der bisher gespeicherten Zuege\n     */\n    public int getLength()\n    {\n        return this.moves.length;\n    }\n\n    /*\n     * fuegt einen Zug (nextMove) zum moves-Array hinzu\n     * dazu muss das moves-Array um 1 laenger sein als zuvor\n     * es wird eine Kopie aller Zuege erstellt und dann\n     * der nextMove hinzugefuegt\n     */\n    public void addMove(Move nextMove)\n    {\n        Move[] newMoves = new Move[this.moves.length + 1];\n        for (int index = 0; index &lt; this.moves.length; index++) {\n            newMoves[index] = this.moves[index];\n        }\n        newMoves[newMoves.length - 1] = new Move(nextMove.getFrom(), nextMove.getTo());\n        this.moves = newMoves;\n    }\n\n    /*\n     * gibt den Move zurueck, der im moves-Array unter dem Index index\n     * gespeichert ist;\n     * kann sein, dass index kein korrekter Index im moves-Array ist, \n     * dann wird eine IllegalArgumentException geworfen\n     */\n    public Move getMoveAtIndex(int index) throws IllegalArgumentException\n    {\n        try {\n            return this.moves[index];\n        }\n        catch(ArrayIndexOutOfBoundsException e)\n        {\n            throw new IllegalArgumentException(\"kein gueltiger Index!\");\n        }\n    }\n\n    /*\n     * Ausgabe aller im moves-Array gespeicherten Zuege\n     * wird nur zum Debuggen benoetigt\n     */\n    public void printMoves()\n    {\n        System.out.printf(\"%n---%n\");\n        for (int index = 0; index &lt; this.moves.length; index++) {\n            Move move = this.moves[index];\n            Point from = move.getFrom();\n            Point to = move.getTo();\n            System.out.println(from.toString() + \" --&gt; \" + to.toString());\n        }\n        System.out.printf(\"%n---%n%n\");\n    }\n}\n</code></pre> enum State.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * FREE - der Platz ist ein Spielfeld, aber kein Spielstein drauf\n * USED - der Platz ist ein Spielfeld mit Spielstein drauf\n * NOT  - der Platz gehoert nicht zum Spielfeld\n */\npublic enum State {\n    FREE, USED, NOT\n}       \n</code></pre> <p>Aufgabe</p> <p>Bef\u00fcllen Sie die Klasse <code>Solitaire.java</code>, wie in den Kommentaren beschrieben:</p> Klasse Solitaire.java <pre><code>package aufgaben.aufgabe3.loesung;\n\npublic class Solitaire {\n    private Moves game;\n    private State[][] field;\n\n    public Solitaire()\n    {\n        this.game = new Moves();\n        this.field = new State[7][7];\n        for(int row = 0; row &lt; this.field.length; row++)\n        {\n            for(int col = 0; col &lt; this.field[row].length; col++)\n            {\n                if((row &lt; 2 || row &gt; 4) &amp;&amp; (col &lt; 2 || col &gt; 4))\n                {\n                    this.field[row][col] = State.NOT;\n                }\n                else\n                {\n                    this.field[row][col] = State.USED;\n                }\n            }\n        }\n        this.field[3][3] = State.FREE;\n    }\n\n    /*\n     * Geben Sie das Spielfeld aus! Am Anfang sollte auf der\n     * Konsole so ein Bild erscheinen:\n     *     o o o     \n     *     o o o     \n     * o o o o o o o \n     * o o o   o o o \n     * o o o o o o o \n     *     o o o     \n     *     o o o \n     * \n     */\n    public void print()\n    {\n\n    }\n\n    /*\n     * diese Methode gibt ein true zurueck, wenn von der\n     * uebergebenen Position (row,col) ein Zug moeglich ist\n     * d.h. \n     * 1. auf der angegebenen Position muss ein Stein sein\n     * 2. zwei Steine weiter (oben, unten, rechts oder links)\n     *      darf kein Stein sein\n     * 3. dazwischen muss ein Stein sein\n     */\n    public boolean possibleFrom(int row, int col)\n    {\n\n        return false;\n    }\n\n    /*\n     * diese Methode gibt alle Positionen (Point) zurueck,\n     * AUF die von (fromRow,fromCol) aus gesprungen werden\n     * kann\n     */\n    public Point[] possibleTo(int fromRow, int fromCol)\n    {\n        if(!possibleFrom(fromRow, fromCol)) return new Point[0];\n\n        /* \n         * naechste Zeile muss entfernt werden!\n         * sttatdessen muessen Sie alle Point-Objekte ermitteln AUF die\n         * gesprungen werden kann. Diese Point-Objekte werden in einem \n         * Point-Array gespeichert, welches zur\u00fcckgegeben wird.\n         */\n        return null;\n    }\n\n    /* \n     * diese Methode erzeugt ein Moves-Objekt\n     * in dieses Moves-Objekt werden mithilfe der\n     * Objektmethode addMove() (aus Moves) alle\n     * moeglichen Zuege hinzugefuegt\n     * (moeglich im aktuellen Zustand von field[][])\n     */\n    public Moves possibleMoves()\n    {\n        Moves possibleMoves = new Moves();\n\n        // next line for debugging\n        possibleMoves.printMoves();\n        return possibleMoves;\n    }\n\n    /*\n     * gibt ein true zurueck, wenn im aktuellen Zustand \n     * von field[][] ueberhaupt noch ein Zug moeglich ist\n     * sonst false\n     */\n    public boolean movePossible()\n    {\n\n        return false;\n    }\n\n    /*\n     * ruft die Methode move(Move move) auf,\n     * wenn ein Zug moeglich ist (dann true zurueck)\n     * sonst false\n     */\n    public boolean moveFirstPossible()\n    {\n        if(!movePossible()) return false;\n        /*\n         *  hier einen moeglichen Zug ausfuehren\n         *  den ersten, den Sie finden (siehe\n         *  possibleMoves() )\n         */\n        return true;\n    }\n\n    /*\n     * hier wird der Zug Move move ausgefuehrt\n     * nach dem Zug ist \n     * 1. die from-Position leer\n     * 2. die to-Position mit einem Stein besetzt\n     * 3. dazwischen leer (Stein wird \"entfernt\")\n     * falls Zug nicht moeglich, wird eine \n     * IllegalArgumentException geworfen \n     */\n    public void move(Move move) throws IllegalArgumentException\n    {\n\n    }\n\n}\n</code></pre> <p>Sie k\u00f6nnen selbstverst\u00e4ndlich beliebig viele weitere (Hilfs-)Methoden hinzuf\u00fcgen. </p> <p>Testen Sie Ihr Spiel in einer <code>Testklasse</code>. F\u00fchren Sie einige Z\u00fcge aus und geben danach immer das Spielfeld auf die Konsole aus. Die Konsole k\u00f6nnte z.B. dann so aussehen:</p> m\u00f6gliche Konsolenausgaben <pre><code>    o o o     \n    o o o     \no o o o o o o \no o o   o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(1,3) --&gt; (3,3)\n(3,1) --&gt; (3,3)\n(3,5) --&gt; (3,3)\n(5,3) --&gt; (3,3)\n\n---\n\n    o o o     \n    o   o     \no o o   o o o \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(2,1) --&gt; (2,3)\n(2,5) --&gt; (2,3)\n(4,3) --&gt; (2,3)\n\n---\n\n    o o o     \n    o   o     \no     o o o o \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(0,2) --&gt; (2,2)\n(2,4) --&gt; (2,2)\n(3,3) --&gt; (1,3)\n(4,1) --&gt; (2,1)\n(4,2) --&gt; (2,2)\n\n---\n\n      o o     \n        o     \no   o o o o o \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(0,4) --&gt; (0,2)\n(2,3) --&gt; (2,1)\n(3,2) --&gt; (1,2)\n(3,3) --&gt; (1,3)\n(4,1) --&gt; (2,1)\n\n---\n\n    o         \n        o     \no   o o o o o \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(2,3) --&gt; (2,1)\n(2,4) --&gt; (0,4)\n(3,2) --&gt; (1,2)\n(3,3) --&gt; (1,3)\n(4,1) --&gt; (2,1)\n\n---\n\n    o         \n        o     \no o     o o o \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(2,0) --&gt; (2,2)\n(2,4) --&gt; (0,4)\n(2,5) --&gt; (2,3)\n(4,2) --&gt; (2,2)\n(4,3) --&gt; (2,3)\n\n---\n\n    o         \n        o     \n    o   o o o \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(2,4) --&gt; (0,4)\n(2,5) --&gt; (2,3)\n(3,2) --&gt; (1,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n\n---\n\n    o   o     \n\n    o     o o \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(2,6) --&gt; (2,4)\n(3,2) --&gt; (1,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,4) --&gt; (2,4)\n\n---\n\n    o   o     \n\n    o   o     \no o o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(3,2) --&gt; (1,2)\n(3,4) --&gt; (1,4)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n\n---\n\n    o   o     \n    o         \n        o     \no o   o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(0,2) --&gt; (2,2)\n(3,0) --&gt; (3,2)\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n\n---\n\n        o     \n\n    o   o     \no o   o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(3,0) --&gt; (3,2)\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n\n---\n\n        o     \n\n    o   o     \n    o o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(3,2) --&gt; (1,2)\n(3,3) --&gt; (3,1)\n(3,4) --&gt; (1,4)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n\n---\n\n        o     \n    o         \n        o     \n      o o o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n\n---\n\n        o     \n    o   o     \n\n      o   o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(0,4) --&gt; (2,4)\n(3,6) --&gt; (3,4)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         \n        o     \n      o   o o \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(3,6) --&gt; (3,4)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         \n        o     \n      o o     \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(3,3) --&gt; (3,5)\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,3) --&gt; (2,3)\n(5,2) --&gt; (3,2)\n\n---\n\n\n    o         \n        o     \n          o   \no o o o o o o \n    o o o     \n    o o o     \n\n\n---\n(4,5) --&gt; (2,5)\n(5,2) --&gt; (3,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         \n        o o   \n\no o o o o   o \n    o o o     \n    o o o     \n\n\n---\n(2,4) --&gt; (2,6)\n(2,5) --&gt; (2,3)\n(4,3) --&gt; (4,5)\n(5,2) --&gt; (3,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         \n            o \n\no o o o o   o \n    o o o     \n    o o o     \n\n\n---\n(4,3) --&gt; (4,5)\n(5,2) --&gt; (3,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         \n            o \n\no o o     o o \n    o o o     \n    o o o     \n\n\n---\n(4,1) --&gt; (4,3)\n(4,6) --&gt; (4,4)\n(5,2) --&gt; (3,2)\n(6,3) --&gt; (4,3)\n(6,4) --&gt; (4,4)\n\n---\n\n\n    o         \n            o \n\no     o   o o \n    o o o     \n    o o o     \n\n\n---\n(4,6) --&gt; (4,4)\n(5,3) --&gt; (3,3)\n(6,2) --&gt; (4,2)\n(6,4) --&gt; (4,4)\n\n---\n\n\n    o         \n            o \n\no     o o     \n    o o o     \n    o o o     \n\n\n---\n(4,3) --&gt; (4,5)\n(4,4) --&gt; (4,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n(6,2) --&gt; (4,2)\n\n---\n\n\n    o         \n            o \n\no         o   \n    o o o     \n    o o o     \n\n\n---\n(6,2) --&gt; (4,2)\n(6,3) --&gt; (4,3)\n(6,4) --&gt; (4,4)\n\n---\n\n\n    o         \n            o \n\no   o     o   \n      o o     \n      o o     \n\n\n---\n(5,4) --&gt; (5,2)\n(6,3) --&gt; (4,3)\n(6,4) --&gt; (4,4)\n(6,4) --&gt; (6,2)\n\n---\n\n\n    o         \n            o \n\no   o     o   \n    o         \n      o o     \n\n\n---\n(4,2) --&gt; (6,2)\n(5,2) --&gt; (3,2)\n(6,4) --&gt; (6,2)\n\n---\n\n\n    o         \n            o \n\no         o   \n\n    o o o     \n\n\n    o         \n            o \n\no         o   \n\n    o o o     \n</code></pre> <p>Dabei steht z.B.  <pre><code>    ---\n    (1,3) --&gt; (3,3)\n    (3,1) --&gt; (3,3)\n    (3,5) --&gt; (3,3)\n    (5,3) --&gt; (3,3)\n\n    ---\n</code></pre> f\u00fcr die in dem Zustand dar\u00fcber m\u00f6glichen Z\u00fcge.  </p>"},{"location":"aufgaben/#aufgabe-4-operationen-uber-mengen","title":"Aufgabe 4 (Operationen \u00fcber Mengen)","text":"Aufgabe 4 <p>Implementieren Sie eine Klasse <code>SetOperations</code>. </p> <ol> <li>Erstellen Sie drei Objektvariablen (z.B. <code>numbers1</code>, <code>numbers2</code> und <code>both</code>) vom Typ <code>Set&lt;Integer&gt;</code>. Erzeugen Sie f\u00fcr diese Objektvariablen <code>TreeSet</code>-Objekte.</li> <li>Erstellen Sie eine Objektmethode <code>fill()</code>. In dieser Methode sollen die beiden Sets <code>numbers1</code> und <code>numbers2</code> mit Zufallszahlen aus dem Wertebereich <code>0..99</code> bef\u00fcllt werden. Erzeugen Sie jeweils <code>100</code> Zufallszahlen (die <code>number</code>s-Sets werden dann aber jeweils weniger als 100 Eintr\u00e4ge haben, da doppelte Elemente nicht aufgenommen werden.)  Beachten Sie, dass die <code>nextInt()</code>-Methode ein <code>int</code> zur\u00fcckliefert. Dieses int muss zun\u00e4chst in ein <code>Integer</code>-Objekt umgewandelt werden (<code>Integer.valueOf(int)</code>) und dieses <code>Integer</code>-Objekt wird dann dem Set hinzugef\u00fcgt (wenn es nicht schon enthalten ist).</li> <li>Erstellen Sie eine Objektmethode <code>fillBothUnion()</code>. In dieser Methode wird die <code>both</code>-Menge derart bef\u00fcllt, dass <code>both</code> einer Vereinigung der Mengen <code>numbers1</code> und <code>numbers2</code> entspricht. F\u00fcr Methoden auf Mengen siehe z.B. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html.</li> <li>Erstellen Sie eine Objektmethode <code>fillBothIntersection()</code>. In dieser Methode wird die <code>both</code>-Menge derart bef\u00fcllt, dass <code>both</code> einem Schnitt der Mengen <code>numbers1</code> und <code>numbers2</code> entspricht. </li> <li>Erstellen Sie eine Objektmethode <code>fillBothDifference()</code>. In dieser Methode wird die <code>both</code>-Menge derart bef\u00fcllt, dass <code>both</code> der Differenz der Menge <code>numbers1</code> minus der Menge <code>numbers2</code> entspricht. </li> <li>Schreiben Sie eine Methode <code>print()</code> so, dass jede Menge als ein Quadrat (10x10) aus Punkten auf der Konsole erscheint. Es wird ein Punkt gezeichnet, wenn die entsprechende Zahl (die 100 Punkte bilden die Zahlen 0..99 ab) in der Menge enthalten ist und es wird kein Punkt gezeichnet, wenn die Zahl nicht vorhanden ist. (Anstelle von Punkten k\u00f6nnen Sie auch jedes beliebige Zeichen (<code>o, *, #, x, ...</code>) verwenden).  Gestalten Sie die Ausgabe so, dass die drei Mengen <code>numbers1</code>, <code>numbers2</code> und <code>both</code> nebeneinander auf der Konsole erscheinen. </li> <li> <p>Testen Sie alle drei Methoden <code>fillBothUnion()</code>, <code>fillBothIntersection()</code> und <code>fillBothDifference()</code>. Die Ausgabe k\u00f6nnte wie folgt sein (<code>A</code> stellt die Menge <code>numbers1</code> dar, <code>B</code> die Menge <code>numbers2</code> und rechts ist jeweils die <code>both</code>-Menge dargestellt): </p> <p></p> <p></p> <p></p> </li> </ol> <p>Tipps: </p> <ul> <li>F\u00fcr die schwarzen Punkte habe ich das Character <code>'\\u25cf'</code> verwendet (ein passendes Leerzeichen dazu ist <code>'\\u2009'</code>). Das Zeichen f\u00fcr die Vereinigung ist <code>'\\u222a'</code> und f\u00fcr den Schnitt <code>'\\u2229'</code>. </li> <li>Schauen Sie sich auch im Skript Mengenoperationen an. </li> </ul>"},{"location":"aufgaben/#aufgabe-5-maps","title":"Aufgabe 5 (Maps)","text":"Aufgabe 5 <ol> <li> <p>Gegeben ist die Datei pi.txt (download pi.txt.zip). Sie enth\u00e4lt \u03c0 mit den ersten <code>100.000</code> Nachkommastellen. Entpacken Sie die Datei <code>pi.txt.zip</code> und kopieren oder bewegen Sie die Datei <code>pi.txt</code> in einen <code>assets</code>-Ordner, der sich in Ihrem Workspace neben dem <code>src</code> und dem <code>out</code>-Ordner befindet (also direkt in dem Ordner Ihres Java-Projektes. Die folgende Abbildung zeigt, wie es z.B. bei mir aussieht (siehe auch \u00dcbung 5):</p> <p></p> </li> <li> <p>Erstellen Sie sich Klasse <code>StringPI</code> mit folgendem Inhalt:</p> Klasse StringPi mit der Konstanten PI <pre><code>import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class StringPI\n{\n    public static final String PI;\n\n    static {\n        try {\n            String fileContent = new String(Files.readAllBytes(Paths.get(\"assets/pi.txt\")));\n            PI = fileContent.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.println(PI.substring(0, 100));\n    }\n}\n</code></pre> <p>Die Ausf\u00fchrung der Klasse sollte folgende Ausgabe ergeben:</p> <pre><code>3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706\n</code></pre> </li> <li> <p>Die Zahl \u03c0 ist eine irrationale Zahl, d.h. sie kann nicht als Bruch dargestellt werden. Au\u00dferdem ist sie nicht periodisch, d.h. es gibt keine immer wiederkehrende Folge von Ziffern im Nachkommabereich. Die Zahl \u03c0 hat unendlich viele Nachkommastellen und da sie nicht periodisch ist, kommen alle m\u00f6glichen Ziffernfolge in \u03c0 vor. Beispielsweise kommt die Ziffernfolge <code>123456</code> allein in den ersten 200 Millionen Nachkommastellen 208 Mal vor.</p> </li> <li> <p>Erstellen Sie eine <code>TreeMap</code>, in der die Schl\u00fcssel vom Typ <code>String</code> und die Werte vom Typ <code>Integer</code> sind. Als Schl\u00fcssel nutzen Sie alle 4-stelligen Zifferkombinationen <code>\"0000\"</code>, <code>\"0001\"</code> bis <code>\"9999\"</code>. Als Werte sollen dazu jeweils die Anzahl der Vorkommen dieser Ziffernkombinationen in dem obigen <code>String PI</code> gespeichert werden. </p> </li> <li> <p>Erstellen Sie eine <code>ArrayList</code>, in der die Ziffernkombinationen gespeichert sind, die am h\u00e4ufigsten in dem obigen <code>String PI</code> gespeichert sind. Wieviele und welche Ziffernkombinationen sind das?</p> Tipps <ul> <li> <p>Schauen Sie sich dazu die Klasse String genauer an!</p> </li> <li> <p>\u00dcberlegen Sie sich, wie Sie am besten alle m\u00f6glichen Kombinationen aus 4-stelligen Zahlen als String erzeugen k\u00f6nnen (also <code>\"0000\", \"0001\", \"0002\", ... \"9999\"</code>).  </p> </li> <li> <p>Schreiben Sie sich eine Methode <code>int nrOfOccurrences(String sub, String str)</code>, die die Anzahl des Vorkommens von <code>sub</code> in <code>str</code> z\u00e4hlt. Sie k\u00f6nnen diese Methode z.B. testen, indem Sie <code>sub=\"0000\"</code> setzen und <code>str=pi</code> \u2192 <code>\"0000\"</code> kommt 9 Mal in <code>pi</code> vor. Testen Sie auch <code>sub=\"2541\"</code> und <code>str=pi</code>, denn <code>\"2541\"</code> ist der allerletzte <code>substring</code> in unserem <code>pi</code> und kommt 8 Mal vor. </p> </li> </ul> </li> </ol>"},{"location":"aufgaben/#aufgabe-6-interfaces","title":"Aufgabe 6 (Interfaces)","text":"Aufgabe 6 <ol> <li> <p>Das Observer-Entwurfsmuster geh\u00f6rt zu den am meisten verwendeten Designmustern/Designpattern/Pattern in der Programmierung. Es wird auch Beobachter-Muster oder Publisher-Pattern genannt. Man kann sich dieses Pattern so vorstellen, dass der Publisher eine Zeitung oder auch Slack ist und dass Listener diese Zeitung (oder Slack) \"abonnieren\". Immer, wenn eine Nachricht ver\u00f6ffentlicht wird, dann erfahren alle Abonnenten davon. Wir werden eine (einfache) Implementierung dieses Entwurfsmusters durchf\u00fchren.</p> </li> <li> <p>Erstellen Sie ein Interface <code>Publisher</code> mit folgenden (abstrakten) Methoden (ist also kein functional interface):</p> <ul> <li><code>public boolean register(Listener listener);</code></li> <li><code>public boolean unregister(Listener listener);</code></li> <li><code>public void notifyListeners();</code> </li> <li><code>public String getUpdate(Listener listener);</code></li> </ul> </li> <li> <p>Erstellen Sie ein weiteres Interface <code>Listener</code> mit folgenden (abstrakten) Methoden:</p> <ul> <li><code>public void update();</code></li> <li><code>public void setPublisher(Publisher publisher);</code></li> <li><code>public void removePublisher(Publisher publisher);</code></li> </ul> </li> <li> <p>Erstellen Sie eine Klasse <code>Slack</code>, die das <code>Publisher</code>-Interface implementiert. Objektvariablen der Klasse sind</p> <ul> <li><code>private Set&lt;Listener&gt; listeners;</code> (speichert alle \"Abonnenten\"; kann gerne auch eine Liste sein)</li> <li> <p><code>private int nrOfMessages;</code> (speichert die aktuelle Nummer einer ver\u00f6ffentlichten Nachricht - die Nachrichten, die ver\u00f6ffentlicht werden, sollen fortlaufend nummeriert werden) </p> </li> <li> <p>Im parameterlosen Konstruktor werden die Menge (oder Liste) erzeugt und die <code>nrOfMessages</code> auf <code>0</code> gesetzt. </p> </li> <li> <p>In der Methode <code>register(Listener listener)</code> wird der <code>listener</code> in die Set <code>listeners</code> eingef\u00fcgt. Geben Sie ein <code>true</code> zur\u00fcck, wenn <code>listener</code> tats\u00e4chlich eingef\u00fcgt wurde und <code>false</code> sonst (falls er schon in der Menge (oder Liste) war).</p> </li> <li> <p>In der Methode <code>unregister(Listener listener)</code> wird der <code>listener</code> wieder aus der Set <code>listeners</code> gel\u00f6scht. Geben Sie ein <code>true</code> zur\u00fcck, wenn <code>listener</code> tats\u00e4chlich gel\u00f6scht wurde und <code>false</code> sonst (falls er nicht in der Menge (oder Liste) war.</p> </li> <li> <p>In der Methode <code>notifyListeners()</code> wird f\u00fcr alle <code>listener</code> aus der Menge <code>listeners</code> die <code>update()</code>-Methode aufgerufen (siehe <code>Listener</code> und <code>Student</code>). </p> </li> <li> <p>Die Methode <code>getUpdate(Listener obj)</code> liefert einfach folgenden String zur\u00fcck: <code>\"Breaking News \" + this.nrOfMessages</code>.</p> </li> <li> <p>Erstellen Sie eine Methode <code>public void publishNews()</code>, in der die <code>nrOfMessages</code> um 1 erh\u00f6ht und die  Methode <code>notifyListeners()</code> aufgerufen wird. </p> </li> </ul> </li> <li> <p>Erstellen Sie eine Klasse <code>Student</code>, die das <code>Listener</code>-Interface implementiert. Objektvariablen der Klasse sind</p> <ul> <li> <p><code>private String name;</code> (speichert den Namen von <code>Student</code>)</p> </li> <li> <p><code>private Publisher publisher;</code> (speichert den <code>Publisher</code>, an den sich <code>Student</code> anmeldet) </p> </li> <li> <p>Im parametrisierten Konstruktor <code>public Student(String name)</code> wird der Name initalisiert. </p> </li> <li> <p>In der Methode <code>setPublisher(Publisher publisher)</code> wird die <code>register()</code>-Methode des <code>publisher</code> aufgerufen und der Wert der Objektvariable <code>publisher</code> gesetzt. Geben Sie bei erfolgreicher Anmeldung an den <code>publisher</code> auf die Konsole <code>this.name + \" registered!\"</code> aus. </p> </li> <li> <p>In der Methode <code>removePublisher(Publisher publisher)</code> meldet sich <code>Student</code> wieder vom <code>publisher</code> ab (Aufruf von <code>unregister()</code>) und Ausgabe auf die Konsole <code>this.name + \" deregistered!\"</code>.</p> </li> <li> <p>In der Methode <code>update()</code> wird die <code>getUpdate()</code>-Methode des <code>publisher</code> aufgerufen und die zur\u00fcckgegebene Nachricht <code>msg</code> wie folgt auf die Konsole ausgegben: <code>this.name + \" received \" + msg</code>. </p> </li> <li> <p>Implementieren Sie f\u00fcr <code>Student</code> auch die Methoden <code>equals()</code> und <code>hashCode()</code>. </p> </li> </ul> </li> <li> <p>Wenn Sie Ihre Implementierung mit folgender Klasse testen:</p> <pre><code>public class Testklasse {\n\n    public static void main(String[] args) \n    {       \n        final int NR_OF_STUDENTS = 5;\n        Slack slack = new Slack();\n\n        Student[] students = new Student[NR_OF_STUDENTS];\n        Character c = 'A';\n        for(int index=0; index &lt; students.length; index++)\n        {\n            students[index] = new Student(c.toString());\n            c++;\n            students[index].setPublisher(slack);\n        }\n        slack.publishNews();\n\n        System.out.println();\n        students[1].removePublisher(slack);\n        students[3].removePublisher(slack);\n        System.out.println();\n        slack.publishNews();\n\n        System.out.println();\n        students[1].setPublisher(slack);\n        students[2].removePublisher(slack);\n        students[4].removePublisher(slack); \n        System.out.println();\n        slack.publishNews();\n\n        System.out.println();\n        students[0].removePublisher(slack);\n        students[1].removePublisher(slack);\n        students[3].setPublisher(slack);\n        System.out.println();\n        slack.publishNews();\n    }\n\n}\n</code></pre> <p>dann sollte die Ausgabe ungef\u00e4hr so sein: </p> <pre><code>A registered!\nB registered!\nC registered!\nD registered!\nE registered!\nD received Breaking News 1\nC received Breaking News 1\nB received Breaking News 1\nA received Breaking News 1\nE received Breaking News 1\n\nB deregistered!\nD deregistered!\n\nC received Breaking News 2\nA received Breaking News 2\nE received Breaking News 2\n\nB registered!\nC deregistered!\nE deregistered!\n\nB received Breaking News 3\nA received Breaking News 3\n\nA deregistered!\nB deregistered!\nD registered!\n\nD received Breaking News 4\n</code></pre> </li> </ol>"},{"location":"aufgaben/#aufgabe-7-lambdas-und-streams-i","title":"Aufgabe 7 (Lambdas und Streams I)","text":"Aufgabe 7 <ol> <li> <p>Die Aufgabe kommt aus dem ersten Semster (siehe Probeklausuren - Studentin). Jetzt wollen wir diese Aufgabe mithilfe von Streams und Lambdas l\u00f6sen. Gegeben Sie die folgenden Klassen (download aufgabe7.zip):</p> Name.java <pre><code>package aufgaben.aufgabe7;\n\nimport java.util.Arrays;\n\npublic class Name {\n\n    private char[] name;\n\n    public Name(String name) {\n        this.name = name.toCharArray();\n    }\n\n    @Override\n    public String toString() {\n        String s = \"\";\n        for(char c : this.name) {\n            s += c;\n        }\n        return s;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Name other = (Name) o;\n\n        return Arrays.equals(this.name, ((Name) o).name);\n    }\n\n    public boolean isBigger(Name n) {\n        int length = this.name.length &lt; n.name.length ? this.name.length : n.name.length;\n        for (int index = 0; index &lt; length; index++) {\n            if (this.name[index] &gt; n.name[index]) return true;\n            else if (this.name[index] &lt; n.name[index]) return false;\n        }\n        return this.name.length &gt; n.name.length;\n    }\n\n}\n</code></pre> Studentin.java <pre><code>package aufgaben.aufgabe7;\n\nimport java.util.Random;\n\nclass Studentin {\n    private String matrNr;\n    private int jahr;\n    private double note;\n    private int lp;\n    private Name sg;\n\n    public Studentin(String sg) {\n        this.sg = new Name(sg);\n        Random rand = new Random();\n        int num = rand.nextInt(10000);\n        this.matrNr = String.format(\"s095%04d\", num);\n        this.jahr = rand.nextInt(16) + 2009;\n        if (this.jahr &lt; 2019) {\n            this.lp = 180;\n        } else {\n            this.lp = (rand.nextInt(36)) * 5;\n        }\n        this.note = 1.0 + (rand.nextInt(30) * 0.1);\n    }\n\n    public String getMatrNr() { return this.matrNr; }\n    public double getNote() { return this.note; }\n    public int getLp() { return this.lp; }\n    public Name getSg() { return this.sg; }\n    public int getSemester() {\n        return (2025 - this.jahr) * 2 - 1;\n    }\n    @Override\n    public String toString() {\n        if (this.lp == 180) {\n            return String.format(\"%8s Absolventin (%d) aus %3s mit 180 LPs. Notendurchschnitt: %.2f\",\n                    this.matrNr, this.jahr, this.sg, this.note);\n        }\n        return String.format(\"%8s %2d.Semester (%d) aus %3s mit %3d LPs. Notendurchschnitt: %.2f\",\n                this.matrNr, this.getSemester(), this.jahr, this.sg, this.lp, this.note);\n    }\n}\n</code></pre> Main.java <pre><code>package aufgaben.aufgabe7;\n\nimport java.util.Random;\n\npublic class Main\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n---------------- Name-Objekte --------------%n%n\");\n        Name n1 = new Name(\"FIW\");\n        Name n2 = new Name(\"AI\");\n        Name n3 = new Name(\"IMI\");\n\n        System.out.println(n1.toString());\n        System.out.println(n2.toString());\n        System.out.println(n3.toString());\n        System.out.println();\n        System.out.println(\"FIW &gt; AI  ? (true  == \" + n1.isBigger(n2) + \")\");\n        System.out.println(\"FIW &gt; IMI ? (false == \" + n1.isBigger(n3) + \")\");\n\n        System.out.printf(\"%n%n---------------- Studentin --------------%n%n\");\n        Studentin[] studis = new Studentin[40];\n        Random r = new Random();\n        for (int index = 0; index &lt; 40; index++) {\n            studis[index] = switch(r.nextInt(5)) {\n                case 0 -&gt; new Studentin(\"FIW\");\n                case 1,2 -&gt; new Studentin(\"AI\");\n                case 3,4 -&gt; new Studentin(\"IMI\");\n                default -&gt; throw new IllegalStateException(\"Unexpected value: \" + r.nextInt(5));\n            };\n            System.out.println(studis[index].toString());\n        }\n\n        System.out.printf(\"%n%n---------------- Studiengaenge --------------%n%n\");\n        SG fiw = new SG(studis, \"FIW\");\n        System.out.println(fiw.toString());\n        fiw.sort(true);\n        System.out.println(fiw.toString());\n        fiw.sort(false);\n        System.out.println(fiw.toString());\n\n        SG ai = new SG(studis, \"AI\");\n        System.out.println(ai.toString());\n        ai.sort(true);\n        System.out.println(ai.toString());\n        ai.sort(false);\n        System.out.println(ai.toString());\n\n        SG imi = new SG(studis, \"IMI\");\n        System.out.println(imi.toString());\n        imi.sort(true);\n        System.out.println(imi.toString());\n        imi.sort(false);\n        System.out.println(imi.toString());\n\n        System.out.printf(\"%n------------ Studiengaenge (FIW) ---------------%n%n\");\n        Studentin fiwBesterAbschluss = fiw.besterAbschluss();\n        if(fiwBesterAbschluss != null) System.out.println(fiwBesterAbschluss.toString());\n        System.out.printf(\"durchschnittliche Abschlussnote : %.4f\", fiw.durchschnittlicheAbschlussnote());\n        Studentin[] nochStudierend = fiw.nochStudierend();\n        System.out.printf(\"%n%n\");\n        System.out.println(\"Folgende Studentinnen studieren noch in FIW : \");\n        for(int index = 0; index &lt; nochStudierend.length; index++)\n        {\n            System.out.println(\"  \" + nochStudierend[index].toString());\n        }\n\n        System.out.printf(\"%n------------------- HTW ------------------%n%n\");\n        HTW htw = new HTW(studis);\n        System.out.println(htw.toString());\n\n        Studentin[] nochHTW = htw.nochStudierend();\n        System.out.println(\"aktuell studieren \" + nochHTW.length + \" Studierende an der HTW : \");\n        for (int index = 0; index &lt; nochHTW.length; index++)\n        {\n            System.out.println(nochHTW[index].toString());\n        }\n    }\n}\n</code></pre> <p>SG.java</p> <pre><code>package aufgaben.aufgabe7;\n\n\npublic class SG\n{\n    private Studentin[] studis;\n    private Name sg;\n\n    public SG(Studentin[] studis, String sg) {\n        this.sg = new Name(sg);\n        /*\n        Das studis-Array des Parameters enth\u00e4lt Studentin-Objekte aus verschiedenen\n        Studieng\u00e4ngen. Ermitteln Sie, wie viele Studentin-Objekte es f\u00fcr den\n        Studiengang sg enth\u00e4lt und erzeugen Sie das studis-Array der Objektvariablen\n        entsprechend.\n\n        Bef\u00fcllen Sie das studis-Array der Objektvariablen mit allen Studentin-Objekten\n        aus dem studis-Array des Parameters, die zum Studiengang sg geh\u00f6ren.\n\n        Nutzen Sie dazu Streams!\n         */\n        this.studis = new Studentin[0]; // TODO\n    }\n\n    public int anzahlStudis() {\n        return this.studis.length;\n    }\n\n    public void sort(boolean note) {\n        /*\n        Sortieren Sie das studis-Array.\n\n        Ist der Parameterwert von note true, wird das Array nach dem Notendurchschnitt\n        sortiert (beste Note zuerst).\n        Ist der Parameterwert von note false, wird das Array nach der Anzahl der Semester\n        sortiert (wenigsten Semester zuerst).\n\n        Nutzen Sie dazu die Sortier-Methode sort(T[] a, Comparator c) aus der Klasse Arrays\n        Schauen Sie sich f\u00fcr einen passenden Comparator die compare()-Methoden der Klassen\n        Double und Integer an!\n\n        Verwenden Sie Lambdas!\n         */\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"%s mit %d Studis : %n\", this.sg, this.studis.length);\n        for(int index = 0; index &lt; this.studis.length; index++)\n        {\n            s += String.format(\"   %s %n\", this.studis[index].toString());\n        }\n        s += \"\\n\";\n        return s;\n    }\n\n    public Studentin besterAbschluss() {\n        /*\n        Geben Sie die Studentin zur\u00fcck, die den besten Notendurchschnitt von allen\n        Absolventinnen (mit 180 Leistungspunkten) des Studiengangs hat.\n\n        Verwenden Sie Streams. Schauen Sie sich folgende Methoden an\n        - stream() aus der Klasse Arrays\n        - filter()  // um alle Absolventinnen zu filtern\n        - min()     // um diejenige mit der besten Note zu ermitteln\n         */\n        return null;    // TODO\n    }\n\n    public double durchschnittlicheAbschlussnote() {\n        /*\n        Geben Sie den durchschnittlichen Notenwert (als double) aller Absolventinnen\n        (mit 180 Leistungspunkten) des Studiengangs zur\u00fcck.\n\n        Verwenden Sie Streams. Schauen Sie sich folgende Methoden an\n        - stream() aus der Klasse Arrays\n        - filter()          // um alle Absolventinnen zu filtern\n        - mapToDouble()     // oder map() - um den Studentinnen-Stream in einen Noten-Stream zu wandeln\n        - average()\n         */\n        return 0.0; //TODO\n    }\n\n    public Studentin[] nochStudierend() {\n        /*\n        Geben Sie ein Studentin[] zur\u00fcck, das alle Studentinnen aus dem Studiengang enth\u00e4lt,\n        die noch keine 180 Leistungspunkte haben.\n\n        Verwenden Sie Streams. Schauen Sie sich folgende Methoden an\n        - stream() aus der Klasse Arrays\n        - filter()          // um alle Studentinnen mit weniger als 180 LP zu filtern\n        - toArray()         // um ein Studentin-Array zu erzeugen\n         */\n        return new Studentin[0]; // TODO\n    }\n}\n</code></pre> <p>HTW.java</p> <pre><code>package aufgaben.aufgabe7;\n\npublic class HTW\n{\n    private SG[] htw;\n\n    public HTW(Studentin[] studis) {\n        /*\n        Erstellen Sie eine Name[] sgs, das alle Namen der Studieng\u00e4nge enth\u00e4lt, in denen\n        die Studentinnen aus dem studis-Array studieren\n\n        Verwenden Sie Streams. Schauen Sie sich folgende Methoden an\n        - stream() aus der Klasse Arrays\n        - map()             // um aus dem Studentinnen-Stream einen Studiengangs-Stream zu machen\n        - distinct()        // um alle Doppelungen heraus zu filtern\n        - toArray()         // um ein Name-Array zu erzeugen\n         */\n        Name[] sgs = new Name[0]; // TODO\n\n        this.htw = new SG[sgs.length];\n        for (int i = 0; i &lt; sgs.length; i++) {\n            htw[i] = new SG(studis, sgs[i].toString());\n        }\n    }\n    public int anzahlStudis() {\n        /*\n        Ermitteln Sie die Summe aller Studentinnen aus dem htw-Array.\n\n        Verwenden Sie Streams. Schauen Sie sich folgende Methoden an\n        - stream() aus der Klasse Arrays\n        - mapToInt()        // um die anzahlStudis (siehe SG) pro SG zu ermitteln\n        - sum()             // um die Summe der Anzahlen zu ermitteln\n         */\n        return 0;   // TODO\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"HTW mit %d Studierenden in %d Studiengaengen : %n%n\",\n                this.anzahlStudis(), this.htw.length);\n        for (int index = 0; index &lt; this.htw.length; index++)\n        {\n            s += this.htw[index].toString();\n        }\n        s += \"\\n\";\n        return s;\n    }\n\n    public Studentin[] nochStudierend()\n    {\n        /*\n        Erzeugen Sie ein Studentin[] aller noch Studierenden aus dem htw-Array.\n\n        Verwenden Sie Streams. Schauen Sie sich folgende Methoden an\n        - stream() aus der Klasse Arrays\n        - flatMap()        // um alle nochStudierend (siehe SG) pro SG zu ermitteln\n        - toArray()        // um das Studentin[] zu erzeugen (und mit dem Stream zu befuellen)\n         */\n        return new Studentin[0];\n    }\n}\n</code></pre> </li> <li> <p>Die Klassen <code>Name.java</code>, <code>Studentin.java</code> und <code>Main.java</code> sind fertig. Aber in <code>SG.java</code> und <code>HTW.java</code> gibt es einige <code>//TODO</code>s. Ersetzen Sie diese unter Beachtung der jeweils dar\u00fcber befindlichen Kommentare. Eine L\u00f6sung ohne Streams und Lambdas finden Sie unter Probeklausuren - Studentin, falls Sie an manchen Stellen nicht weiterkommen. </p> </li> </ol>"},{"location":"aufgaben/#aufgabe-8-lambdas-und-streams-ii","title":"Aufgabe 8 (Lambdas und Streams II)","text":"Aufgabe 8 <ol> <li> <p>Gegeben ist eine Liste von Strings, z.B. <code>List&lt;String&gt; words = Arrays.asList(\"fiw\", \"ai\", \"imi\", \"ikg\", \"wi\", \"bui\", \"ce\", \"csb\", \"iiw\", \"wiw\");</code> Gruppieren Sie mithilfe von Streams die Strings nach ihrer L\u00e4nge und z\u00e4hlen Sie die Anzahl der Strings in jeder Gruppe. Ausgabe k\u00f6nnte (f\u00fcr obiges Beispiel) wie folgt sein:</p> <pre><code>3 Strings mit L\u00e4nge 2\n7 Strings mit L\u00e4nge 3\n</code></pre> </li> <li> <p>Gegeben folgender Record <code>Rectangle</code>: <code>public record Rectangle(int width, int length){}</code> und z.B. folgende Menge:</p> <pre><code>Set&lt;Rectangle&gt; rectangles = new HashSet&lt;&gt;();\nrectangles.add(new Rectangle(1, 2));\nrectangles.add(new Rectangle(3, 2));\nrectangles.add(new Rectangle(1, 4));\nrectangles.add(new Rectangle(3, 4));\nrectangles.add(new Rectangle(2, 5));\nrectangles.add(new Rectangle(4, 2));\nrectangles.add(new Rectangle(2, 4));\n</code></pre> <p>Partitionieren Sie die Menge der <code>rectangles</code>, je nachdem die Breite gr\u00f6\u00dfer ist als die L\u00e4nge und umgekehrt (Gleichheit k\u00f6nnen Sie eine der beiden Gruppen zuordnen). M\u00f6gliche Ausgabe k\u00f6nnte sein:</p> <pre><code>L\u00e4nge &gt; Breite : [Rectangle[width=1, length=2], Rectangle[width=3, length=4], Rectangle[width=2, length=4], Rectangle[width=1, length=4], Rectangle[width=2, length=5]]\nBreite &gt; L\u00e4nge : [Rectangle[width=4, length=2], Rectangle[width=3, length=2]]\n</code></pre> </li> <li> <p>Finden Sie alle kleinsten (gr\u00f6\u00dften) Rechteck aus <code>rectangles</code> (Gr\u00f6\u00dfe soll die Addition von L\u00e4nge und Breite sein). (Hinweis: Ich brauchte 2 Streams oder 1 Stream und eine schlaue Behandlung der Map - vielleicht schaffen Sie es ja mit einem Stream?!). Ausgabe k\u00f6nnte sein:</p> <pre><code>Alle Rechtecke mit Breite + L\u00e4nge = 3 :\n   Rectangle[width=1, length=2]\n</code></pre> <p>bzw. (gr\u00f6\u00dfte)</p> <pre><code>Alle Rechtecke mit Breite + L\u00e4nge = 7 :\n   Rectangle[width=3, length=4]\n   Rectangle[width=2, length=5]\n</code></pre> </li> <li> <p>Gruppieren Sie alle <code>rectangles</code> nach ihrem Fl\u00e4cheninhalt. Ausgabe k\u00f6nnte sein:</p> <pre><code>  2 : [Rectangle[width=1, length=2]] \n  4 : [Rectangle[width=1, length=4]] \n  6 : [Rectangle[width=3, length=2]] \n  8 : [Rectangle[width=2, length=4], Rectangle[width=4, length=2]] \n 10 : [Rectangle[width=2, length=5]] \n 12 : [Rectangle[width=3, length=4]] \n</code></pre> </li> </ol>"},{"location":"aufgaben/#aufgabe-9-junit-tests-myinteger","title":"Aufgabe 9 (JUnit-Tests MyInteger)","text":"Aufgabe 9 <ol> <li>Erstellen Sie f\u00fcr die Klasse <code>MyInteger</code> aus Aufgabe 2 so viele Junit-Tests, dass die Testabdeckung <code>100%</code> erreicht. </li> </ol>"},{"location":"collections/","title":"Collections","text":"<p>Um mehrere Werte oder Referenzen gleichen Typs zu speichern, haben wir bisher Arrays verwendet. Die L\u00e4nge von Arrays wird bei der Initialisierung festgelegt und l\u00e4sst sich dann nicht mehr ver\u00e4ndern. Wenn ein weiteres Element einem vollen Array hinzugef\u00fcgt werden soll, muss zun\u00e4chst ein neues Array erstellt werden, das l\u00e4nger ist als das alte und dann m\u00fcssen alle Elemente aus dem alten Array in das neue Array kopiert werden, ehe das neue Element hinzugef\u00fcgt wird. Das ist recht aufwendig. Dar\u00fcber hinaus ist es beispielsweise auch aufwendig, in Arrays Doppelungen zu vermeiden. F\u00fcr ein Element, das in ein Array eingef\u00fcgt werden soll, muss daf\u00fcr zun\u00e4chst gepr\u00fcft werden, ob es nicht bereits im Array enthalten ist. Diese Nachteile f\u00fchren dazu, dass wir uns nun mit Datenstrukturen besch\u00e4ftigen, die ebenfalls mehrere Elemente speichern k\u00f6nnen, deren Verwaltung aber nicht so aufwendig ist, wie bei Arrays. Diese Datenstrukturen hei\u00dfen Collections. </p> <p>Collections haben drei wesentliche Eigenschaften:</p> <ul> <li>Eine Collection hat keine festgelegte L\u00e4nge, d.h. es sind beliebig viele Elemente in einer Collection speicherbar.</li> <li>In eine Collection k\u00f6nnen nur Elemente von Referenztypen gespeichert werden, d.h. keine Wertetypen (<code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, ...). Um auch solche \"Werte\" speichern zu k\u00f6nnen, werden wir Wrapper-Klassen kennenlernen. </li> <li>Im Gegensatz zu Arrays k\u00f6nnen in einer Collection Elemente verschiedener Referenztypen gespeichert werden. Das ist aber eher ein Problem und kein Feature. Wir werden das vermeiden, da die Verwaltung von Elementen verschiedener Typen fehleranf\u00e4llig ist. Wir werden Collections typisieren, damit sie nur Elemente eines Typs speichern kann.</li> </ul>"},{"location":"collections/#arten-von-collections","title":"Arten von Collections","text":"<p>Es gibt unterschiedliche Arten von Collections, welche je nach Einsatzzweck verwendet werden:</p>  Typ  \u00a0Struktur  \u00a0Zugriff   Eigenschaften  <code>List</code>  Menge   wahlfrei (indexbasiert)  Iterator  kann Elemente mehrfach enthalten  <code>Set</code>  Menge   Iterator   keine doppelten Elemente  keine Ordnung der Elemente  <code>Map</code>  Schl\u00fcssel-Werte-Paare   schl\u00fcsselbasiert  Schl\u00fcssel ist eindeutig  Werte k\u00f6nnen mehrfach sein  <code>Stack</code>  Stapel/Stack   oberstes Element  last-in-first-out-Prinzip  <code>Queue</code>  Warteschlange   erstes und letztes Element   first-in-first-out-Prinzip  <p>Wir werden uns in diesem Semester aber nur mit den Collections <code>List</code>, <code>Set</code> und <code>Map</code> besch\u00e4ftigen. Das Prinzip eines Stacks haben wir bereits kennengelernt, als wir uns \u00fcber den Methodenstack in Programmierung 1 unterhalten hatten. Ein Stack ist ein Stapel, auf den man ein Element legen kann (<code>pop</code>) und von dem man das oberste Element entfernen kann (<code>pop</code>). Mithilfe von <code>top</code> erh\u00e4lt man lesenden Zugriff auf das oberste Element. Auf alle anderen Elemente hat man im Stack keinen Zugriff. </p> <p>Eine Queue implementiert das Prinzip einer Warteschlange. Ein Element kann an das Ende einer Warteschlange angeh\u00e4ngt werden. Herausgenommen werden kann aber immer nur das Element am Anfang (dem head) der Warteschlange. </p> <p>Eine Liste (<code>List</code>) ist noch am ehesten vergleichbar mit einem Array, au\u00dfer dass es keine Gr\u00f6\u00dfenbeschr\u00e4nkung gibt und dass nur Referenztypen in eine Liste gespeichert werden. In Listen werden ebenfalls Indizes verwaltet, so dass man auf die Elemente Zugriff wie in einem Array hat. Es gibt Listen, die automatisch sortiert werden. In Listen k\u00f6nnen Elemente doppelt vorkommen. Von Doppelungen in Collections wird gesprochen, wenn f\u00fcr zwei Elemente <code>e1</code> und <code>e2</code> gilt <code>e1.equals(e2) == true</code> (oder <code>e1.hashCode() == e2.hashCode()</code>). </p> <p>Eine Menge (<code>Set</code>) hat die besondere Eigenschaft, dass sie keine Doppelungen enth\u00e4lt. Wird versucht, ein Element einer Menge hinzuzuf\u00fcgen, welches bereits in der Menge enthalten ist, dann wird das Element nicht hinzugef\u00fcgt. Deshalb gibt die <code>add(element)</code>-Methode f\u00fcr eine Menge ein <code>boolean</code> zur\u00fcck, damit erkannt werden kann, ob das Element hinzugef\u00fcgt wurde (<code>true</code>) oder nicht (<code>false</code>). </p> <p>Eine <code>Map</code> kann man sich wie eine Tablle aus zwei Spalten vorstellen. In der linken Spalte stehen Schl\u00fcssel <code>key</code> und in der rechten die Werte <code>value</code>. Jedem Schl\u00fcssel ist genau ein Wert zugeordnet. Jeder Schl\u00fcssel ist eindeutig, d.h. es gibt keine Doppelungen unter den Schl\u00fcsseln (die Schl\u00fcssel in einer <code>Map</code> sind eine <code>Set</code>). Werte k\u00f6nnen allerdings doppelt vorkommen (haben aber jeweils einen eigenen Schl\u00fcssel). </p> <p>Eine kurze Entscheidungshilfe, welche Collection verwendet wird, zeigt die folgende Abbildung:</p> <p></p>"},{"location":"collections/#der-collection-klassenbaum","title":"Der Collection-Klassenbaum","text":"<p>Leider ist die Verwaltung von Collections in Java nicht einheitlich. Das liegt daran, dass (unverst\u00e4ndlicherweise) Listen und Mengen in einer anderen Vererbungshierarchie verwaltet werden, als Maps. Wir schauen uns die Vererbungshierarchie von <code>Collection</code> einaml an. Darin kommen die Listen und Mengen vor, aber nicht Maps.</p> <p></p> <p>Die \"Mutter-Klasse\" der Collections <code>List</code> und <code>Set</code> ist <code>Collection</code>. In der Abbildung fallen unterschiedliche Farben auf. Die gr\u00fcngef\u00e4rbten Klassen sind sogenannte Interfaces. Interfaces lernen wir sp\u00e4ter noch kennen. Ebenso wie die rotgef\u00e4rbten Klassen, bei denen es sich um abstrakte Klassen handelt. Das soll uns zun\u00e4chst nicht besonders interessieren, aber wir k\u00f6nnen uns merken, dass wir die gr\u00fcngef\u00e4rbten Klassen als Typen verwenden (insb. den Typ <code>List</code> f\u00fcr die Listen und den Typ <code>Set</code> f\u00fcr die Mengen). Wir k\u00f6nnen aber keine konkreten <code>List</code>-Objekte bzw. keine konkreten <code>Set</code>-Objekte erzeugen. Das geht nur mit dem blaugef\u00e4rbten Klassen. Das bedeutet, dass wir z.B. ein konkretes <code>ArrayList</code>-Objekt erzeugen werden oder ein konkretes <code>HashSet</code>-Objekt. Hier einige Beispiele:</p> <pre><code>import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n        List l1 = new ArrayList();\n        List l2 = new LinkedList();\n\n        Set s1 = new HashSet();\n        Set s2 = new TreeSet();\n    }\n}\n</code></pre> <p>Beachten Sie, alle Klassen aus dem <code>java.util</code>-Paket zu importieren! Eine Klasse <code>List</code> gibt es z.B. auch im <code>java.awt</code>-Paket! Statt alle Klassen einzeln zu importieren k\u00f6nnen Sie auch schreiben:</p> <pre><code>import java.util.*;\n</code></pre> <p>Der <code>*</code> ist eine Wildcard und importiert alle Klassen aus <code>java.util</code>. </p> <p>Zur Diskussion, wann <code>ArrayList</code> besser ist und wann <code>LinkedList</code>, siehe hier. Eine Diskussion \u00fcber die Unterschiede zwischen <code>HashSet</code> und <code>TreeSet</code> finden Sie z.B. hier. Wir werden f\u00fcr Listen haupts\u00e4chlich Objekte von <code>ArrayList</code> erstellen und f\u00fcr Mengen haupts\u00e4chlich Objekte von <code>HashSet</code>.</p>"},{"location":"collections/#mengen-sets","title":"Mengen - Sets","text":"<p>Wir betrachten zun\u00e4chst Mengen genauer und beginnen mit einem Beispiel:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n\n        Set menge = new HashSet();\n\n        String s1 = \"erster\";\n        String s2 = \"zweiter\";\n        String s3 = \"dritter\";\n        String s4 = \"zweiter\";\n\n        System.out.println(menge.add(s1)); // true\n        System.out.println(menge.add(s2)); // true\n        System.out.println(menge.add(s3)); // true\n        System.out.println(menge.add(s4)); // false\n\n        System.out.println(menge.size()); // 3\n\n        Iterator it = menge.iterator();\n        while(it.hasNext())\n        {\n            System.out.println(it.next());\n        } \n\n    }\n}\n</code></pre> <p>In Zeile <code>1</code> werden zun\u00e4chst alle verwendeten Klassen aus dem <code>java.util</code>-Paket geladen. Das sind f\u00fcr unser Beispiel <code>Set</code>, <code>HashSet</code> und <code>Iterator</code>. Die <code>Iterator</code>-Klasse wird verwendet, um durch unsere Menge <code>menge</code> zu laufen. Wir werden auf den <code>Iterator</code> gleich genauer eingehen, lernen aber bald eine einfachere L\u00f6sung kennen, um durch unsere Menge zu iterieren. </p> <p>In Zeile <code>7</code> wird die Menge <code>menge</code> erzeugt. Wir deklarieren daf\u00fcr den Typ <code>Set</code> und erzeugen unter Verwendung des parameterlosen Konstruktors von <code>HashSet</code> ein <code>HashSet</code>-Objekt. Die <code>menge</code> hat also den Compilertyp <code>Set</code> und mindestens den Laufzeittyp <code>HashSet</code> (nat\u00fcrlich noch weitere Laufzeittypen, z.B. <code>Object</code>). </p> <p>In den Zeilen <code>14-17</code> werden der <code>menge</code> Elemente hinzugef\u00fcgt. Diese Elemente sind hier vom Typ <code>String</code>. Das Hinzuf\u00fcgen von Elementen zu einer Menge erfolgt mit der Methode <code>add(element)</code>. Diese Methode gibt ein <code>boolean</code> zur\u00fcck. Wir lassen in den Zeilen <code>14-17</code> diese R\u00fcckgabe auf die Konsole ausgeben und stellen fest, dass wir folgende Ausgaben erhalten: </p> <pre><code>true\ntrue\ntrue\nfalse\n</code></pre> <p>Die <code>add()</code>-Methode gibt also 3x ein <code>true</code> zur\u00fcck und beim vierten Aufruf ein <code>false</code>. Das liegt daran, dass beim vierten Aufruf von <code>add()</code> (Zeile <code>17</code>) das \u00fcbergebene Element <code>s4</code> nicht in die Menge <code>menge</code> eingef\u00fcgt wird, da sich in dieser Menge bereits ein <code>String</code> mit dem Wert <code>\"zweiter\"</code> befindet und eine Menge keine Doppelungen enthalten darf. Da <code>s2.equals(s4)</code> den Wert <code>true</code> zur\u00fcckgibt, erkennt die <code>add()</code>-Methode, dass bereits ein gleiches Objekt in der Menge enthalten ist und <code>s4</code> wird deshalb nicht eingef\u00fcgt. </p> <p>In Zeile <code>19</code> lassen wir uns die Anzahl der Elemente in der Menge <code>menge</code> ausgeben. Dies erfolgt mithilfe der <code>size()</code>-Methode (in Collections ist es also nicht <code>length()</code>, auch nicht <code>length</code> und auch nicht <code>getLength()</code> oder <code>getSize()</code>, sondern <code>size()</code>). Der Wert von <code>size()</code> in unserem Beispiel ist <code>3</code>. </p>"},{"location":"collections/#der-iterator","title":"Der Iterator","text":"<p>Mithilfe der Klasse Iterator iterieren wir durch eine Collection, d.h. wir laufen durch unsere Collection und betrachten alle Elemente aus der Collection. </p> <p>Die Klasse <code>Iterator</code> besitzt drei Objektmethoden (eigentlich vier, aber die vierte Methode soll uns zun\u00e4chst nicht interessieren):</p> <ul> <li><code>hasNext()</code>: liefert ein <code>true</code> zur\u00fcck, wenn sich mindestens ein weiteres Element in der Collection befindet; wenn nicht, dann <code>false</code>,</li> <li><code>next()</code>: liefert das n\u00e4chste Element aus der Iteration zur\u00fcck (und entfernt es daraus), </li> <li><code>remove()</code>: l\u00f6scht das mit <code>next()</code>zur\u00fcckgegebene Element.</li> </ul> <p>In Zeile <code>21</code> erzeugen wir zun\u00e4chst mit der <code>iterator()</code>-Methode aus <code>Set</code> ein Objekt von <code>Iterator</code>. Die Referenz auf dieses Objekt nennen wir hier <code>it</code>. </p> <p>Die <code>while()</code>-Schleife in den Zeilen <code>22-25</code> durchl\u00e4uft nun diese Iteration, indem sie mithilfe von <code>hasNext()</code> pr\u00fcft, ob sich noch ein weiteres Element in der Iteration befindet und wenn ja, dann wird es mithilfe von <code>next()</code> aus der Iteration entnommen und in Zeile <code>24</code> auf die Konsole ausgegeben. </p> <p>Wir erhalten f\u00fcr unser Beispiel folgende Ausgaben:</p> <pre><code>zweiter\ndritter\nerster\n</code></pre> <p>Darin sehen wir auch, dass die Reihenfolge des Einf\u00fcgens in eine Menge nicht gewahrt wird. Wir haben die Elemente in der Reihenfolge <code>\"erster\"</code>, <code>\"zweiter\"</code>, <code>\"dritter\"</code> in die Menge eingef\u00fcgt, aber die Ausgabe erfolgt in der Reihenfolge <code>\"zweiter\"</code>, <code>\"dritter\"</code>, <code>\"erster\"</code>. Auf die Reihenfolge haben wir in Mengen keinen Einfluss!</p>"},{"location":"collections/#methoden-fur-mengen","title":"Methoden f\u00fcr Mengen","text":"<p>Wir haben bereits drei Methoden f\u00fcr Mengen kennengelernt: <code>add()</code>, <code>size()</code> und <code>iterator()</code>. Tats\u00e4chlich sind das Methoden, die in allen Klassen zur Verf\u00fcgung stehen, die von <code>java.util.Collection</code> erben (erben ist hier eigentlich nicht ganz richtig, da es sich bei <code>java.util.Collection</code> um ein Interface handelt, aber das soll uns hier zun\u00e4chst egal sein). Wir betrachten nun alle wesentlichen Methoden, die wir f\u00fcr Mengen und Listen zur Verf\u00fcgung haben (siehe dazu auch die Java-Dokumentation von Collection):</p>  Methode   Beschreibung  <code>boolean add(E element)</code>  F\u00fcgt Element <code>element</code> in die Collection ein. Gibt <code>true</code> zur\u00fcck, wenn Element hinzugef\u00fcgt wurde sonst <code>false</code>.  <code>boolean addAll(Collection c)</code>  F\u00fcgt alle Elemente der Collection <code>c</code> in die Collection ein. Gibt <code>true</code> zur\u00fcck, wenn mindestens ein Element hinzugef\u00fcgt wurde sonst <code>false</code>.  <code>void clear()</code>  Entfernt alle Elemente aus der Collection. <code>boolean contains(E element)</code>  Gibt <code>true</code> zur\u00fcck, wenn sich <code>element</code> in der Collection befindet, sonst <code>false</code>. <code>boolean containsAll(Collection c)</code>  Gibt <code>true</code> zur\u00fcck, wenn sich alle Elemente der Collection <code>c</code> in der Collection befinden, sonst <code>false</code>. <code>boolean isEmpty()</code>  Gibt <code>true</code> zur\u00fcck, wenn sich keine Elemente in der Collection befinden, sonst <code>false</code>. <code>Iterator iterator()  Erzeugt einen Iterator, welcher auf das erste Element der Collection zeigt. <code>boolean remove(Object o)</code>  Entfernt <code>o</code> aus der Collection und gibt <code>true</code> zur\u00fcck, wenn ein Element entfernt wurde, sonst <code>false</code>. <code>boolean removeAll(Collection c)</code>  Entfernt alle Elemente aus c aus der Collection und gibt <code>true</code> zur\u00fcck, wenn mindestens ein Element entfernt wurde, sonst <code>false</code>. <code>int size()</code>  Gibt die Anzahl der Elemente in der Collection zur\u00fcck. <code>Object[] toArray()</code>  Gibt die Elemente in der Collection in einem Array-Datentyp zur\u00fcck. <p>Der TyP <code>E</code> in der Tabelle ist ein Platzhalter f\u00fcr einen konkreten Typ. Bei dem <code>Iterator</code> sehen wir eine neue Syntax <code>&lt;E&gt;</code>. Diese lernen wir gleich kennen. <code>E</code> steht, wie gesagt, f\u00fcr einen beliebigen Typ. Die Typisierung wollen wir zun\u00e4chst motivieren. </p>"},{"location":"collections/#typisieren","title":"Typisieren","text":"<p>Generell k\u00f6nnen in Collections Objekte verschiedener Typen gespeichert werden. Es w\u00e4re also m\u00f6glich, so etwas hier zu tun:</p> <pre><code>    Set menge = new HashSet();\n    menge.add(new String(\"erster\"));        // String einf\u00fcgen\n    menge.add(new Power(2,4));              // Power einf\u00fcgen\n    menge.add(new Point(2,3));              // Point einf\u00fcgen\n    menge.add(new Konto());                 // Konto einf\u00fcgen\n</code></pre> <p>Das Speichern von Objekten verschiedenen Typs ist jedoch sehr fehleranf\u00e4llig und sollte unbedingt vermieden werden! Es gibt auch nicht wirklich sinnvollen Anwendungsbeispiele daf\u00fcr. </p> <p>Stattdessen wollen wir angeben, welcher Typ die Objekte haben sollen, die in unserer Collection gespeichert werden k\u00f6nnen. Dazu typisieren wir die Collection. </p> <p>Das Typisieren einer Collection erfolgt mithilfe der Diamond-Syntax:  <code>Collection&lt;Typ&gt; name = new KonkreteKlasse&lt;&gt;();</code></p> <p>Wir typisieren die Menge <code>menge</code> aus dem eben gezeigten Beispiel:</p> <pre><code>    Set&lt;String&gt; menge = new HashSet&lt;&gt;();    // mit String typisiert - menge nimmt nur Strings auf\n    menge.add(new String(\"erster\"));        // String einf\u00fcgen\n    menge.add(new Power(2,4));              // Fehler - kein String\n    menge.add(new Point(2,3));              // Fehler - kein String\n    menge.add(new Konto());                 // Fehler - kein String\n</code></pre> <p>Wir haben <code>menge</code> typisiert und angegeben, dass <code>menge</code> nur Objekte vonm Typ <code>String</code> aufnehmen kann. Dazu geben wir bei der Typdeklaration <code>Set&lt;String&gt;</code> den Elemente-Typ in spitzen Klammern an. Diese spitzen Klammern werden auch in den Konstruktoraufruf eingef\u00fcgt <code>new HashSet&lt;&gt;();</code>. Darin muss der Typ aber nicht wiederholt werden (der ist ja aus der Deklaration klar). </p> <p>Der Versuch, Objekte eines anderen Typs als <code>String</code> in die Collection einzuf\u00fcgen, scheitert bereits zur Compilezeit, d.h. das Programm l\u00e4sst sich gar nicht \u00fcbersetzen, wenn versucht wird, Objekte anderen Typs als der bei der Typisierung Angegebene einzuf\u00fcgen. </p> <p>Unser einf\u00fchrendes Beispiel von oben ist deshalb besser mit Typisierung: </p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n\n        Set&lt;String&gt; menge = new HashSet&lt;&gt;();\n\n        String s1 = \"erster\";\n        String s2 = \"zweiter\";\n        String s3 = \"dritter\";\n        String s4 = \"zweiter\";\n\n        System.out.println(menge.add(s1)); // true\n        System.out.println(menge.add(s2)); // true\n        System.out.println(menge.add(s3)); // true\n        System.out.println(menge.add(s4)); // false\n\n        System.out.println(menge.size()); // 3\n\n        Iterator&lt;String&gt; it = menge.iterator();\n        while(it.hasNext())\n        {\n            System.out.println(it.next());\n        } \n\n    }\n}\n</code></pre> <p>Beachten Sie, dass auch der Iterator (Zeile <code>21</code>) typisiert wird.</p>"},{"location":"collections/#die-for-each-schleife","title":"Die for-each-Schleife","text":"<p>Wenn wir unsere Collection typisieren, haben wir auch eine einfachere M\u00f6glichkeit, durch diese zu laufen als die Verwednung des Iterators. Wir k\u00f6nnen stattdessen die for-each-Schleife verwenden. Die allgemeine Syntaxh einer solchen Schleife ist:</p> <pre><code>for(TypElement element : collection)\n{\n\n}\n</code></pre> <p>F\u00fcr unser Beispiel k\u00f6nnten wir den Iterator ersetzen durch diese Schleife:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n\n        Set&lt;String&gt; menge = new HashSet&lt;&gt;();\n\n        String s1 = \"erster\";\n        String s2 = \"zweiter\";\n        String s3 = \"dritter\";\n        String s4 = \"zweiter\";\n\n        System.out.println(menge.add(s1)); // true\n        System.out.println(menge.add(s2)); // true\n        System.out.println(menge.add(s3)); // true\n        System.out.println(menge.add(s4)); // false\n\n        System.out.println(menge.size()); // 3\n\n        for(String s : menge)\n        {\n            System.out.println(s);\n        }\n\n    }\n}\n</code></pre> <p>\u00dcbrigens: anstelle der Collection (hier: <code>menge</code>) k\u00f6nnte auch ein Array stehen. Wenn Sie also vollst\u00e4ndig durch Array laufen m\u00f6chten, m\u00fcssen Sie das nicht zwingend \u00fcber alle Indizes machen, sondern k\u00f6nnen daf\u00fcr auch diese for-each-Schleife verwenden. </p> \u00dcbung <p>Ersetzen Sie im oberen Beispiel <code>HashSet</code> durch <code>TreeSet</code>. Erkennen Sie einen Unterschied?</p>"},{"location":"collections/#listen","title":"Listen","text":"<p>Der Umgang mit Listen ist \u00e4hnlich dem Umgang mit Mengen, da beide von <code>java.util.Collection</code> abgeleitet sind. Deshalb stehen uns f\u00fcr Listen die gleichen Methoden zur Verf\u00fcgung, wie f\u00fcr Mengen. Listen k\u00f6nnen wir uns eher wie Arrays vorstellen. In Listen gibt es, im Unterschied zu Mengen, index-basierte Zugriffe und auch Doppelungen. Wir betrachten ein Beispiel:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    static void fillList(List&lt;String&gt; list) \n    {\n        for (int i = 0; i &lt; 10; i++) \n        { \n            list.add(String.valueOf(i)); \n        }\n    }\n\n    static void printList(List&lt;String&gt; list) \n    {\n        Iterator&lt;String&gt; it = list.iterator();\n        while(it.hasNext()) \n        {\n            System.out.print(it.next() + \" \");\n        }\n        System.out.println();\n        System.out.println(\"End of list\");\n    }\n\n    public static void main(String[] args)\n    {\n        List&lt;String&gt; list1 = new ArrayList&lt;&gt;();\n        fillList(list1);\n        printList(list1);\n\n        List&lt;String&gt; list2 = new LinkedList&lt;&gt;();\n        fillList(list2);\n        list2.remove(\"3\");      // Wert!\n        list2.remove(6);        // Index!\n        list1.removeAll(list2);\n        printList(list2);       // 0 1 2 4 5 6 8 9\n        printList(list1);       // 3 7\n    }\n\n}\n</code></pre> <p>Wir erstellen uns zwei Listen <code>list1</code> (Zeile <code>26</code>) und <code>list2</code> (Zeile <code>30</code>). Beide sind vom Compilertyp List und beide sind typisiert mit <code>String</code>, d.h. sie k\u00f6nnen nur Strings aufnehmen. </p> <p>Die Methode <code>fillList()</code> (Zeilen <code>5-11</code>) bef\u00fcllt die \u00fcbergebene Liste mit den Ziffern <code>0...9</code>. Da die Liste Strings erwartet, werden die <code>int</code>-Ziffern mithilfe von <code>String.valueOf()</code> in einen <code>String</code> umgewandelt (Zeile <code>9</code>). Die <code>add()</code>-Methode f\u00fcgt die Strings hinzu (Zeile <code>9</code>).  </p> <p>Die Methode <code>printList()</code> (Zeilen <code>13-33</code>) gibt die Elemente der \u00fcbergebenen Liste mithilfe des Iterators aus. Es wird jede Ziffer ausgegeben, gefolgt von einem Leerzeichen (Zeile <code>18</code>). </p> <p>Der Aufruf von <code>printList(list1);</code> in Zeile <code>28</code> f\u00fchrt zu folgender Ausgabe:</p> <pre><code>0 1 2 3 4 5 6 7 8 9 \nEnd of list\n</code></pre> <p>Die Liste <code>list2</code> wird zun\u00e4chst ebenfalls mit den Ziffern <code>0...9</code> (jeweils als <code>String</code>) bef\u00fcllt. Die Anweisung <code>list2.remove(\"3\");</code> in Zeile <code>32</code> bewirkt, dass der Wert <code>\"3\"</code> aus der Liste gel\u00f6scht wird. Nach diesem L\u00f6schen enth\u00e4lt die Liste <code>list2</code> noch folgende Werte:</p> <pre><code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \n</code></pre> <p>In Zeile <code>33</code> wird nun das Element aus der Liste gel\u00f6scht, das unter dem Index <code>6</code> gespeichert ist. Das ist das Element <code>\"7\"</code>. Nach dem L\u00f6schen des Elementes enth\u00e4lt die Liste <code>list2</code> noch folgende Werte:</p> <pre><code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" \n</code></pre> <p>Die Anweisung <code>list1.removeAll(list2);</code> in Zeile <code>34</code> bewirkt nun, dass aus <code>list1</code> alle Werte gel\u00f6scht werden, die (auch) in <code>list2</code> enthalten sind, also <code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\"</code>. Das bewirkt, dass in <code>list1</code> dann nur noch die Werte <code>\"3\" \"7\"</code> \u00fcbrig bleiben. </p> <p>Die Anweisung <code>printList(list2);</code> in Zeile <code>35</code> bewirkt folgende Ausgabe: </p> <pre><code>0 1 2 4 5 6 8 9 \nEnd of list\n</code></pre> <p>Die Anweisung <code>printList(list1);</code> in Zeile <code>36</code> bewirkt folgende Ausgabe: </p> <pre><code>3 7 \nEnd of list\n</code></pre> <p>Die Methode <code>printList()</code> h\u00e4tte anstelle den Iterator zu verwenden auch mit der for-each-Schleife implementiert werden k\u00f6nnen:</p> <pre><code>    static void printList(List&lt;String&gt; list) \n    {\n        for(String s : list)\n        {\n            System.out.print(s + \" \");\n        }\n        System.out.println();\n        System.out.println(\"End of list\");\n    }\n</code></pre> \u00dcbung <p>Gegeben ist folgender Code: <pre><code>  Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;();\n\u00a0 Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;();\n\n\u00a0 for (int i = 10; i &gt;= 1; i--) { s1.add(i); }\n\u00a0 for (int i = 9; i &lt;= 12; i++) { s2.add(i); }\u000b\n\u00a0 \n\u00a0 s1.addAll(s2); \u00a0 \n</code></pre></p> <ol> <li>Was ist der R\u00fcckgabewert von <code>s1.addAll(s2);</code> und warum?</li> <li>Implementieren Sie die Ausgabe aller Werte von <code>s1</code> und <code>s2</code>. </li> </ol>"},{"location":"collections/#mengenoperationen","title":"Mengenoperationen","text":"<p>Angenommen, wir haben drei Mengen <code>A</code>, <code>B</code> und <code>C</code>, wobei alle Elemente aus <code>C</code> auch Elemente in <code>A</code> sind. Mithilfe der Methoden <code>addAll()</code>, <code>removeAll()</code>, <code>retainAll()</code>  und <code>containsAll()</code> lassen sich Operationen \u00fcber Mengen beschreiben, wie die folgende Abbildung zeigt:</p> <p></p>"},{"location":"collections/#stack-und-queue","title":"Stack und Queue","text":"<p>Wir werden uns, wie bereits erw\u00e4hnt, nicht ausf\u00fcrhlich mit Stack und Queue besch\u00e4ftigen, wollen aber hier der Vollst\u00e4ndigkeit halber, die gesonderten Methoden angeben, die diese beiden Arten von Collections betreffen:</p>"},{"location":"collections/#stack","title":"Stack","text":"<ul> <li>Last-In-First-Out-Prinzip</li> <li><code>push(E element)</code> zum Hinzuf\u00fcgen</li> <li><code>pop()</code> entfernt oberstes Element und gibt es zur\u00fcck</li> <li><code>empty()</code> pr\u00fcft, ob der Stack leer ist</li> </ul>"},{"location":"collections/#queue","title":"Queue","text":"<ul> <li>First-In-First-Out-Prinzip</li> <li><code>add()/offer()</code> zum Hinzuf\u00fcgen</li> <li><code>remove()/poll()</code> entfernt vorderstes Element und gibt es zur\u00fcck</li> <li><code>element()/peek()</code> pr\u00fcft, ob die Warteschlange leer ist</li> </ul>"},{"location":"collections/#wertetypen-in-collections","title":"Wertetypen in Collections","text":"<p>Wertetypen k\u00f6nnen nicht als Typen der Elemente in Collections verwendet werden. Es sind nur Referenztypen in Collections erlaubt. F\u00fcr alle Wertetypen stehen entsprechende Wrapper-Klassen zur Verf\u00fcgung: <code>Integer</code>, <code>Double</code>, <code>Float</code>, <code>Short</code>, <code>Byte</code>, <code>Long</code>, <code>Character</code>, <code>Boolean</code>:</p> <pre><code>// Wertetypen k\u00f6nnen nicht als konkrete\u00a0\n// Typen in Collections verwendet werden\nList&lt;int&gt; l = new ArrayList&lt;&gt;();    // Fehler !!\n\n// Verwendung der Wrapper-Klassen + Auto-Boxing\nList&lt;Integer&gt; l = new ArrayList&lt;&gt;();\n\nl.add(100);\u00a0 \u00a0 \u00a0 \u00a0 // Auto-Boxing\n</code></pre> <p>Das obere beispiel zeigt in Zeile <code>3</code>, wie es nicht geht. Die <code>List l</code> kann nicht mit <code>int</code> typisiert werden. Stattdessen muss die Wrapper-Klasse <code>Integer</code> verwendet werden. Siehe Wrapper-Klassen.</p>"},{"location":"einstieg/","title":"Einstieg","text":"<p>Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem <code>java.util</code>-Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane. </p> <p>Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse <code>JOptionPane</code> befindet sich im Paket <code>javax.swing</code>. Wenn Sie in Ihrem Java-Projekt eine Datei <code>module-info.java</code> haben, dann m\u00fcssen Sie darin <code>requires java.desktop;</code> eintragen, um \u00fcberhaupt Klassen aus dem <code>javax.swing</code>-Paket importieren zu k\u00f6nnen, das sich das Paket <code>javax.swing</code> im Modul <code>java.desktop</code> befindet:</p> module-info.java <pre><code>module SoSe25   // SoSe25 ist der Name des Java-Projektes\n{\n    requires java.desktop;\n}\n</code></pre> <p>Die interessanten Methoden zur Erzeugung der Dialoge sind</p> <ul> <li><code>showConfirmDialog()</code>,</li> <li><code>showInputDialog()</code>,</li> <li><code>showMessageDialog()</code> und</li> <li><code>showOptionDialog()</code> </li> </ul> <p>Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann (<code>showInputDialog()</code>) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen <code>String</code> zur\u00fcck und die anderen Dialoge geben ein <code>int</code> zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene <code>int</code>-Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen:</p> <ul> <li><code>JOptionPane.YES_OPTION</code>,</li> <li><code>JOptionPane.NO_OPTION</code>,</li> <li><code>JOptionPane.CANCEL_OPTION</code>,</li> <li><code>JOptionPane.OK_OPTION</code>,</li> <li><code>JOptionPane.CLOSED_OPTION</code></li> </ul>"},{"location":"einstieg/#beispiel-showconfirmdialog","title":"Beispiel <code>showConfirmDialog()</code>","text":"<p>Die <code>showConfirmDialog()</code>-Methode ist zwei Mal \u00fcberladen. Es gibt </p> <ul> <li><code>static int showConfirmDialog(Component parentComponent, Object message)</code> und </li> <li><code>static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType)</code></li> </ul> <p>Als <code>optionType</code> gibt es dabei die Auswahl zwischen </p> <ul> <li><code>JOptionPane.DEFAULT_OPTION</code>,</li> <li><code>JOptionPane.YES_NO_OPTION</code>,</li> <li><code>JOptionPane.YES_NO_CANCEL_OPTION</code>,</li> <li><code>JOptionPane.OK_CANCEL_OPTION</code></li> </ul> <p>Die <code>parentComponent</code> ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf <code>null</code> setzen. </p> <p>Der <code>String</code> <code>message</code> erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein <code>String</code> sein kann, sondern besipielsweise auch ein <code>Icon</code>, ist der Typ von <code>message</code> als <code>Object</code> deklariert.</p> <p>Der <code>String</code> <code>title</code> erscheint als Titel des Dialogfensters. </p>"},{"location":"einstieg/#beispiel-mit-yes_no_option","title":"Beispiel mit <code>YES_NO_OPTION</code>","text":"<pre><code>int auswahl = JOptionPane.showConfirmDialog(\n        null,                           // parentComponent\n        \"Wollen Sie wirklich beenden?\", // message\n        \"Programmende\",                 // title\n        JOptionPane.YES_NO_OPTION       // optionType\n    );\n</code></pre> <p>erzeugt z.B. folgendes Dialogfenster:</p> <p></p> <p>Wenn Sie nun auf einen der beiden Button <code>No</code> oder <code>Yes</code> klicken, dann schlie\u00dft sich das Fenster wieder und in dem <code>int</code> <code>auswahl</code> ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten:</p> <pre><code>if(auswahl == JOptionPane.NO_OPTION)\n{\n    // es wurde auf NO geklickt\n}\nelse if(auswahl == JOptionPane.YES_OPTION)\n{\n    // es wurde auf YES geklickt\n}\n</code></pre>"},{"location":"einstieg/#beispiel-mit-yes_no_cancel_option","title":"Beispiel mit <code>YES_NO_CANCEL_OPTION</code>","text":"<pre><code>int auswahl = JOptionPane.showConfirmDialog(null, \"Weitere Seiten scannen?\", \"Speichern\", JOptionPane.YES_NO_CANCEL_OPTION);\n\nif(auswahl == JOptionPane.NO_OPTION)\n{\n    // es wurde auf NO geklickt\n}\nelse if(auswahl == JOptionPane.YES_OPTION)\n{\n    // es wurde auf YES geklickt\n}\nelse if(auswahl == JOptionPane.CANCEL_OPTION)\n{\n    // es wurde auf CANCEL geklickt\n}\n</code></pre> <p>erzeugt folgendes Dialogfenster:</p> <p></p>"},{"location":"einstieg/#beispiel-showinputdialog","title":"Beispiel <code>showInputDialog()</code>","text":"<p>Die Methode <code>showInputDialog()</code> \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode <code>showInputDialog()</code> ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form <code>showInputDialog(Object message)</code> oder, wenn wir noch einen <code>messageType</code> hinzuf\u00fcgen wollen, <code>showInputDialog(Component parentComponent, Object message, String title, int messageType)</code>. </p> <p>F\u00fcr den <code>messageType</code> gibt es folgende vordefinierte Konstanten:</p> <ul> <li><code>ERROR_MESSAGE</code>,</li> <li><code>INFORMATION_MESSAGE</code>,</li> <li><code>WARNING_MESSAGE</code>,</li> <li><code>QUESTION_MESSAGE</code>,</li> <li><code>PLAIN_MESSAGE</code></li> </ul> <p>Wichtig ist, dass die <code>showInputDialog()</code>-Methode den <code>String</code> zur\u00fcckgibt, der eingegeben wurde. </p> <pre><code>String eingabe = JOptionPane.showInputDialog(\"Ihre Eingabe : \");\nSystem.out.println(\"Sie haben \" + eingabe + \" eingegeben\");\n</code></pre> <p>erzeugt folgendes Dialogfenster:</p> <p></p> <p>Die Implementierung</p> <pre><code>String eingabe = JOptionPane.showInputDialog(null, \"Ihre Eingabe : \", \"Dialogtitel\", JOptionPane.ERROR_MESSAGE);\nSystem.out.println(\"Sie haben \" + eingabe + \" eingegeben\");\n</code></pre> <p>erzeugt folgendes Dialogfenster:</p> <p></p> <p>Die Ansicht der Fenster und auch der <code>messageType</code>-Icons sind betriebssystemabh\u00e4ngig. </p>"},{"location":"einstieg/#ausblick","title":"Ausblick","text":"<p>Angenommen, wir wollen <code>JOptionPane.showInputDialog()</code> verwenden, um eine Zahl einzugeben. Klar ist, dass <code>showInputDialog()</code> die Eingabe als <code>String</code> zur\u00fcckgibt. </p> <ol> <li> <p>Problem: Wie wandeln wir einen <code>String</code> zu einem <code>int</code> (oder <code>double</code>) um? </p> <p>Antwort: mit der Hilfe von Wrapper-Klassen </p> </li> <li> <p>Problem: Angenommen, wir haben eine L\u00f6sung, <code>String</code> nach <code>int</code> umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. <code>hallo</code>? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln.</p> <p>Antwort: mit der Behandlung von Exceptions</p> </li> </ol>"},{"location":"enum/","title":"Aufz\u00e4hlungstypen (enum)","text":""},{"location":"enum/#motivation","title":"Motivation","text":"<p>Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B.</p> <pre><code>String tag = \"MONTAG\"   // kann auch Werte \"Dienstag\" usw. annehmen\nint tag = 0;            // Magic Number f\u00fcr \"Montag\"\n</code></pre> <p>Das Problem: </p> <ul> <li>die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. <code>Tag = \"hallo\"</code> oder <code>Tag=4711</code>,</li> <li>Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit</li> </ul> Beispiel TicTacToe <pre><code>public class TicTacToe \n{\n    int[][] field;\n\n    TicTacToe()\n    {\n        field = new int[3][3];\n        for(int i=0; i&lt;field.length; i++)\n            for(int j=0; j&lt;field[i].length; j++)\n                field[i][j]=0;\n    }\n\n    void makeMove(int i, int j, int player)\n    {\n        if(field[i][j]==0 &amp;&amp; player==1 || player==2)    \n            field[i][j]=player;\n    }\n}\n</code></pre> <ul> <li>Zust\u00e4nde <code>EMPTY</code> (<code>0</code>), <code>RED</code> (<code>1</code>), <code>BLACK</code> (<code>2</code>) verschl\u00fcsselt \u2192 magic numbers</li> <li><code>field[i][j]</code> k\u00f6nnte auch beliebige andere <code>int</code>-Werte annehmen</li> <li>Code nahezu unlesbar</li> </ul>"},{"location":"enum/#erster-verbesserungsversuch-konstanten","title":"Erster Verbesserungsversuch: Konstanten","text":"Beispiel TicTacToe mit Konstanten <pre><code>public class TicTacToe \n{\n    int[][] field;\n    static final int EMPTY = 0;     // Feld ist leer\n    static final int RED = 1;       // auf das Feld hat rot gesetzt\n    static final int BLACK = 2;     // auf das Feld hat schwarz gesetzt\n\n    TicTacToe()\n    {\n        field = new int[3][3];\n        for(int i=0; i&lt;field.length; i++)\n            for(int j=0; j&lt;field[i].length; j++)\n                field[i][j]=EMPTY;\n    }\n\n    void makeMove(int i, int j, int player)\n    {\n        if(field[i][j]==EMPTY &amp;&amp; player==RED || player==BLACK)  \n            field[i][j]=player;     // hier wird auf das Feld rot oder schwarz gesetzt\n    }\n}\n</code></pre> <ul> <li>etwas besser, aber immer noch beliebige Werte f\u00fcr <code>field[i][j]</code> m\u00f6glich</li> </ul>"},{"location":"enum/#der-aufzahlungstyp-enum","title":"Der Aufz\u00e4hlungstyp <code>enum</code>","text":"<p>Anforderungen:</p> <ul> <li>eigener Datentyp</li> <li>endliche Anzahl an Zust\u00e4nden bzw. Werten</li> <li>leserliche Bezeichnung der Werte</li> </ul> <p>L\u00f6sung:</p> <ul> <li>Enumerations (sog. Aufz\u00e4hlungstypen)</li> <li>Schl\u00fcsselwort <code>enum</code></li> </ul> <p>Syntax: <pre><code>    enum TypName {WERT1, WERT2, WERT3};\n</code></pre></p> <p>Verwendung:</p> <ul> <li><code>TypName</code> nun als Datentyp verwendbar, z.B. <code>TypName[][]</code></li> <li>Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. <code>TypName.WERT1</code></li> </ul> Beispiel TicTacToe mit enum <pre><code>public class TicTacToe \n{\n    enum State {EMPTY, RED, BLACK};\n    State[][] field;\n\n    TicTacToe()\n    {\n        field = new State[3][3];\n        for(int i=0; i&lt;field.length; i++)\n            for(int j=0; j&lt;field[i].length; j++)\n                field[i][j]=State.EMPTY;\n    }\n\n    void makeMove(int i, int j, State player)\n    {\n        if(field[i][j]==State.EMPTY &amp;&amp; player!=State.EMPTY)     \n            field[i][j]=player;\n    }\n}\n</code></pre> <ul> <li>typsicher</li> <li>rot und schwarz \u00fcber <code>State.RED</code> und <code>State.BLACK</code> erreichbar</li> <li>andere Zust\u00e4nde nicht m\u00f6glich</li> </ul>"},{"location":"enum/#details","title":"Details:","text":"<ul> <li>alle <code>enum</code> erben implizit von <code>java.lang.Enum</code></li> <li><code>enum</code> sind Referenztypen</li> <li>die Konstanten (Werte) in <code>enum</code> sind automatisch <code>static</code> und <code>final</code></li> <li><code>==</code> kann verwendet werden (auch <code>switch()</code>); <code>equals()</code> gibt es aber auch</li> </ul> Beispiel enum <pre><code>State s = State.EMPTY;  // s = 0 oder s = \"rot\" oder so geht nicht \n                        //-&gt; typsicher\nswitch(s)\n{\n    case EMPTY:     System.out.println(\"leeres Feld\"); break;\n    case RED:       System.out.println(\"roter Stein\"); break;\n    case BLACK:     System.out.println(\"schwarzer Stein Feld\"); break;\n}\n\n// neuere Syntax switch ohne break zur Info\nswitch(s)\n{\n    case EMPTY  -&gt;   System.out.println(\"leeres Feld\");\n    case RED    -&gt;   System.out.println(\"roter Stein\");\n    case BLACK  -&gt;   System.out.println(\"schwarzer Stein Feld\");\n}\n</code></pre>"},{"location":"enum/#weiteres","title":"Weiteres:","text":"<ul> <li>auch Definition von Methoden m\u00f6glich</li> <li><code>toString()</code>, <code>equals()</code> usw. aus <code>Object</code> k\u00f6nnen \u00fcberschrieben werden</li> <li>Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig)</li> <li>Zugriff auf das Array von Konstanten mithilfe von <code>values()</code></li> </ul> Beispiel f\u00fcr Werte mit Attributennoch ein Beispiel f\u00fcr Werte mit Attributen <pre><code>enum Farben {\n    KREUZ(12), PIK(11), HERZ(10), KARO(9);\n    private int farbwert;\n\n    private Farben(int wert)\n    {\n        this.farbwert=wert;\n    }   \n\n    @Override\n    public String toString()\n    {\n        char c = ' ';\n        switch(this)\n        {\n            case KREUZ  : c ='\\u2663';  break;\n            case PIK    : c ='\\u2664';  break;\n            case HERZ   : c ='\\u2665';  break;\n            case KARO   : c ='\\u2666';  break;\n        }\n        return String.valueOf(c);\n    }\n}\n</code></pre> <pre><code>enum Karten {\n    AS(11), ZEHN(10), NEUN(0), ACHT(0), SIEBEN(0), K(4), D(3), B(2);\n    private int kartenwert;\n\n    private Karten(int wert)\n    {\n        this.kartenwert=wert;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = \"\";\n        switch(this)\n        {\n            case AS     : s =\"A\";   break;\n            case ZEHN   : s =\"10\";  break;\n            case NEUN   : s =\"9\";   break;\n            case ACHT   : s =\"8\";   break;\n            case SIEBEN : s =\"7\";   break;\n            case K      : s =\"K\";   break;\n            case D      : s =\"D\";   break;\n            case B      : s =\"B\";   break;\n        }\n        return s;\n    }\n}\n</code></pre> Ausf\u00fchrliches Beispiel - Skat.java <pre><code>package vorbereitungen.enums;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Skat {\n    Karte[] p1;\n    Karte[] p2;\n    Karte[] p3;\n    Karte[] skat;\n\n    enum Karten {\n        AS(11), ZEHN(10), NEUN(0), ACHT(0), SIEBEN(0), K(4), D(3), B(2);\n        private int kartenwert;\n\n        private Karten(int wert)\n        {\n            this.kartenwert=wert;\n        }\n\n        @Override\n        public String toString()\n        {\n            String s = \"\";\n            switch(this)\n            {\n                case AS     : s =\"A\";   break;\n                case ZEHN   : s =\"10\";  break;\n                case NEUN   : s =\"9\";   break;\n                case ACHT   : s =\"8\";   break;\n                case SIEBEN : s =\"7\";   break;\n                case K      : s =\"K\";   break;\n                case D      : s =\"D\";   break;\n                case B      : s =\"B\";   break;\n            }\n            return s;\n        }\n    }\n\n    enum Farben {\n        KREUZ(12), PIK(11), HERZ(10), KARO(9);\n        private int farbwert;\n\n        private Farben(int wert)\n        {\n            this.farbwert=wert;\n        }   \n\n        @Override\n        public String toString()\n        {\n            char c = ' ';\n            switch(this)\n            {\n                case KREUZ  : c ='\\u2663';  break;\n                case PIK    : c ='\\u2664';  break;\n                case HERZ   : c ='\\u2665';  break;\n                case KARO   : c ='\\u2666';  break;\n            }\n            return String.valueOf(c);\n        }\n    }\n\n    class Karte {\n        Karten k;\n        Farben f;\n\n        Karte(Karten k, Farben f)\n        {\n            this.k=k;\n            this.f=f;\n        }\n\n        @Override\n        public Karte clone()\n        {\n            return new Karte(this.k,this.f);\n        }\n\n        @Override\n        public String toString()\n        {\n            return f.toString()+k.toString()+\" \";\n        }\n\n    }\n\n    class Deck {\n        Karte[] deck;\n\n        Deck()\n        {\n            deck = new Karte[32];\n            int index = 0;\n            for(Farben f: Farben.values())\n            {\n                for(Karten k:Karten.values())\n                {\n                    deck[index++] = new Karte(k,f);\n                }\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            String s = \"\";\n            for(int i=0; i&lt;deck.length; i++)\n            {\n                s += deck[i].f.toString() + deck[i].k.toString() +\" \";\n                if(i==7 || i==15 || i==23 || i==31) s+=\"\\n\";\n            }\n            return s;\n        }\n\n        public void print()\n        {\n            System.out.println(this.toString());\n        }\n\n    }\n\n    Skat()\n    {\n        p1 = new Karte[8];\n        p2 = new Karte[8];\n        p3 = new Karte[8];\n        skat = new Karte[2];    \n    }\n\n    boolean existsFalse(boolean[] b)\n    {\n        for(int i=0; i&lt;b.length; i++)\n        {\n            if(!b[i]) return true;\n        }\n        return false;\n    }\n\n    public void geben()\n    {\n        Deck d = new Deck();\n        Random r = new Random();    \n        boolean[] b = new boolean[32]; \n        Arrays.fill(b, false);\n        int indexP1 = 0, indexP2 = 0, indexP3 =0, indexSkat = 0;\n        int zz = r.nextInt(32);\n        while(existsFalse(b))\n        {\n            while(b[zz])\n            {\n                zz = r.nextInt(32);\n            }\n            b[zz] = true;\n            if(indexP1&lt;8)\n            {\n                p1[indexP1++] = d.deck[zz].clone();\n            }\n            else if(indexP2&lt;8)\n            {\n                p2[indexP2++] = d.deck[zz].clone();\n            }\n            else if(indexP3&lt;8)\n            {\n                p3[indexP3++] = d.deck[zz].clone();\n            }\n            else if(indexSkat&lt;2)\n            {\n                skat[indexSkat++] = d.deck[zz].clone();\n            }\n        }\n    }\n\n    public void sortieren()\n    {\n\n    }\n\n    public void print()\n    {\n        System.out.print(\"Spieler 1 : \");\n        for(Karte k : p1) System.out.print(k.toString()+\" \");\n        System.out.println();\n        System.out.print(\"Spieler 2 : \");\n        for(Karte k : p2) System.out.print(k.toString()+\" \");\n        System.out.println();\n        System.out.print(\"Spieler 3 : \");\n        for(Karte k : p3) System.out.print(k.toString()+\" \");\n        System.out.println();\n        System.out.print(\"Skat      : \");\n        for(Karte k : skat) System.out.print(k.toString()+\" \");\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Skat s = new Skat();\n        s.geben();\n        s.print();\n\n    }\n\n}\n</code></pre>"},{"location":"enum/#nutzliche-links-fur-enums","title":"N\u00fctzliche Links f\u00fcr enums","text":"<ul> <li>Oracle Docs</li> <li>W3Schools</li> <li>Java enums - so geht's</li> <li>Enums</li> <li>Java Tutorial - Enums (youtube)</li> </ul>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Motivation</p> <p>Wir wissen nun, wie wir einen <code>String</code> in ein <code>int</code> umwandeln. N\u00e4mlich mithilfe der <code>parseInt(String)</code>-Methode der Klasse <code>Integer</code>. Was aber passiert, wenn der <code>String</code> gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?</p> <p>Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine <code>ArrayIndexOutOfBounds</code>-Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf <code>null</code>, erhalten wir eine <code>NullPointerException</code>. Wenn bei einer Nutzereingabe eine Zahl erwartet wird, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls eine Exception geworfen. </p> <p>Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern:</p> <ul> <li>syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das Programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und</li> <li>logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. </li> </ul> <p>Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte, z.B. </p> <ul> <li>fehlerhafte Benutzereingabe </li> <li>Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar </li> <li>gesuchte Datei/Ordner nicht vorhanden usw. </li> </ul> <p>Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt. Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt. </p>"},{"location":"exceptions/#try-catch","title":"try-catch","text":"<p>Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem <code>index</code> auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher <code>index</code> aus dem Array ist. Allerdings binden wir diesen Versuch in einen <code>try{}</code>-Block ein. </p> <p>Sollte in einem solchen <code>try{}</code>-Block nun eine Exception geworfen werden, dann fangen wir diese in einem <code>catch(){}</code>-Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus:</p> allgemeine Syntax try-catch <pre><code>try \n{\n    // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt)\n}   \ncatch(Exception e)  \n{\n    // Behandlung der Exception \n}\n</code></pre> <p>Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile <code>3</code> aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem <code>catch</code>-Block, also nach Zeile <code>8</code> weiter. Wenn aber die Anweisung(en) in Zeile <code>3</code> einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile <code>5</code> \"aufgefangen\" und in dem Anweisungsblock in den Zeilen <code>6-8</code> behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren. </p>"},{"location":"exceptions/#beispiel-ohne-try-catch","title":"Beispiel ohne try-catch","text":"<p>Wir verdeutlichen dieses Prinzip an einem ersten Beispiel:</p> Beispiel zun\u00e4chst ohne Behandlung der Exceptions <pre><code>class Ausnahmen {\n\n    static char charAt(String s, int index)\n    {\n        char c = s.charAt(index);           // kritisch!\n        return c;\n    }\n    static double divide(int divident, int divisor)\n    {\n        double result = divident/divisor;   // kritisch!\n        return result;\n    }\n\n    public static void main(String[] args) \n    {\n        System.out.println(divide(5,0));            // ArithmeticException\n        System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n    }\n}\n</code></pre> <p>Das Beispiel enth\u00e4lt zwei Methoden <code>charAt()</code> und <code>divide</code>. Der <code>charAt</code>-Methode wird ein <code>String</code> \u00fcbergeben und ein <code>index</code>. Die Methode gibt das Zeichen (<code>char</code>) zur\u00fcck, dass im <code>String</code> unter dem <code>index</code> gespeichert ist (z.B. <code>charAt(\"Hallo\", 1)</code> gibt das <code>'a'</code> zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob <code>index</code> tats\u00e4chlich ein korrekter Index des Strings <code>s</code> ist, d.h. evtl. ist <code>index</code> kleiner als <code>0</code> oder gr\u00f6\u00dfer als die L\u00e4nge von <code>s</code> minus <code>1</code>. Die Anweisung  <code>s.charAt(index);</code> ist somit eine kritische Anweisung, denn sie kann (bei \"falschem\" <code>index</code>) eine <code>StringIndexOutOfBoundsException</code> werfen. </p> <p>Genau so ist die Anweisung <code>divident/divisor;</code> in der Methode <code>divide</code> eine kritische Anweisung, da es sein kann, dass der <code>divisior</code> gleich <code>0</code> ist. Bei der <code>int</code>-Division durch <code>0</code> wird eine <code>ArithmeticException</code> geworfen. </p> <p>Wenn die <code>main</code>-Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile <code>16</code> ab und Zeile <code>17</code> wird gar nicht mehr erreicht: </p> <pre><code>Exception in thread \"main\" java.lang.ArithmeticException: / by zero\n    at packageName.Ausnahmen.divide(Ausnahmen.java:10)\n    at packageName.Ausnahmen.main(Ausnahmen.java:16)\n</code></pre> <p>Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich <code>Ausnahmen.java:10</code> und um welche Exception es sich handelt, n\u00e4mlich <code>ArithmeticException: / by zero</code>.</p> <p>Wenn wir in der <code>main</code>-Methode Zeile <code>16</code> auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile <code>17</code> eine Exception wirft, n\u00e4mlich: </p> <pre><code>Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5\n    at java.base/java.lang.StringLatin1.charAt(StringLatin1.java:47)\n    at java.base/java.lang.String.charAt(String.java:702)\n    at packageName.Ausnahmen.charAt(Ausnahmen.java:5)\n    at packageName.Ausnahmen.main(Ausnahmen.java:17)\n</code></pre> <p>Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich <code>Ausnahmen.java:5</code> und um welche Exception es sich handelt, n\u00e4mlich <code>StringIndexOutOfBoundsException: String index out of range: 5</code>. Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile <code>47</code> in der Klasse <code>StringLatin1</code> in der dortigen Methode <code>charAt</code> die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten. </p>"},{"location":"exceptions/#beispiel-mit-try-catch","title":"Beispiel mit try-catch","text":"<p>Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir <code>try-catch</code>-Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen:</p> Beispiel mit Behandlung der Exceptions <pre><code>class Ausnahmen {\n\n    static char charAt(String s, int index)\n    {\n        char c = ' ';\n        try\n        {\n            c = s.charAt(index); // kritisch!\n        }\n        catch(StringIndexOutOfBoundsException e)\n        {\n            System.err.println(\"Der Index war ausserhalb des Strings\");\n        }\n        return c;\n    }\n\n    static double divide(int divident, int divisor)\n    {\n        double result = 0.0;\n        try\n        {\n            result = divident/divisor; // kritisch!\n        }\n        catch(ArithmeticException ae)\n        {\n            System.err.println(\"Division durch 0 nicht definiert!\");\n        }\n        return result;\n    }\n\n    public static void main(String[] args) \n    {\n        System.out.println(divide(5,0));            // ArithmeticException\n        System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n    }\n}\n</code></pre> <p>Die kritischen Anweisungen wurden nun jeweils in einen <code>try</code>-Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t <code>out</code> in den <code>println</code>-Anweisungen verwendet, sondern <code>err</code> - Zeilen <code>12</code> und <code>26</code>). </p> <p>Wenn wir das Programm nun ausf\u00fchren (in <code>main</code> muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe:</p> <pre><code>Division durch 0 nicht definiert!\n0.0\nDer Index war ausserhalb des Strings\n</code></pre> <p>Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der <code>divide</code>-Methode wird eine Exception geworfen, dann erfolgt durch Zeile <code>26</code> die Fehlerausgabe auf die Konsole. Danach wird in Zeile <code>28</code> aber <code>result</code> zur\u00fcckgegeben (hat den Wert <code>0.0</code>, den wir bei der Initailisierung in Zeile <code>19</code> angegeben haben) und dieser Wert wird durch Zeile <code>33</code> auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die <code>charAt</code>-Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile <code>34</code> das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. </p> <p>Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an:</p>"},{"location":"exceptions/#ablauf-einer-ausnahmesituation","title":"Ablauf einer Ausnahmesituation","text":"<p>Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt:</p> <ol> <li>Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp <code>Exception</code>), wenn eine Exception \"geworfen\" wird</li> <li>Die Abarbeitung des Programmcodes wird sofort unterbrochen.</li> <li>Das Laufzeitsystem sucht nach der n\u00e4chsten <code>catch</code>-Klausel und f\u00fchrt diese aus.</li> <li>Passt die gefundene <code>catch</code>-Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste <code>catch</code>-Klausel gesucht usw.\u00a0</li> </ol> <p>Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen <code>catch</code>-Klausel (Zeile <code>10</code>) ein Objekt vom Typ <code>StringIndexOutOfBoundsException</code> erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von <code>Exception</code> ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von <code>StringIndexOutOfBoundsException</code> allegmein eine <code>Exception</code> erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere <code>catch</code>-Klausel (Zeile <code>24</code>), wo wir eine <code>ArithmeticException</code> erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. Generell gilt, dass man mehrere <code>catch</code>-Bl\u00f6cke hintereinander setzen kann und der erste <code>catch</code>-Block, der dem erwarteten Parametertyp entspricht, wird ausgef\u00fchrt. </p> <p>Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" <code>catch</code>-Klausel gesprungen wird. </p>"},{"location":"exceptions/#ein-weiteres-beispiel","title":"Ein weiteres Beispiel","text":"<p>Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse <code>Ausnahmen</code> um eine weitere Methode <code>inputInt()</code>:</p> eine weitere methode inputInt() <pre><code>/*\n * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten\n * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, \n * dann muessen Sie dort noch\n * module ProjektName\n * {\n *  requires java.desktop;\n * }\n * eintragen, damit Sie das Paket javax.swing importieren koennen. \n */\nimport javax.swing.JOptionPane;\n\npublic class Ausnahmen\n{\n    static char charAt(String s, int index)\n    {\n        char c = ' ';\n        try\n        {\n            c = s.charAt(index); // kritisch!\n        }\n        catch(StringIndexOutOfBoundsException e)\n        {\n            System.err.println(\"Der Index war ausserhalb des Strings\");\n        }\n        return c;\n    }\n\n    static double divide(int divident, int divisor)\n    {\n        double result = 0.0;\n        try\n        {\n            result = divident/divisor; // kritisch!\n        }\n        catch(ArithmeticException ae)\n        {\n            System.err.println(\"Division durch 0 nicht definiert!\");\n        }\n        return result;\n    }\n\n    static int inputInt()\n    {\n        int inputInt = 0;\n        boolean inputOk = false;\n        String input =\"\";\n        while(!inputOk)\n        {\n            input = JOptionPane.showInputDialog(\"Zahl :\");\n            inputOk = true;\n            try {\n                inputInt = Integer.parseInt(input);\n            }\n            catch(NumberFormatException e)\n            {\n                inputOk = false;\n            }\n        }\n        return inputInt;\n    }\n\n\n    public static void main(String[] args) \n    {\n        System.out.println(divide(5,0));            // ArithmeticException\n        System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n        System.out.println(\"Zahl: \" + inputInt());  // NumberFormatException\n    }\n}\n</code></pre> <p>Schauen wir uns die Implementierung von <code>inputInt()</code> genauer an: </p> <ul> <li>in Zeile <code>50</code> wird ein kleines Eingabefenster erzeugt (<code>JOptionPane</code> ist eine Klasse aus dem <code>javax.swing</code>-Paket, welches wiederum im Modul <code>java.desktop</code> verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als <code>String</code> zur\u00fcckgegeben und in der Variablen <code>input</code> gespeichert. </li> <li>in Zeile <code>53</code> wird versucht, den Eingabestring <code>input</code> in ein <code>int</code> umzuwandeln. Dazu wird die Methode <code>parseInt()</code> verwendet, die zur Klasse <code>Integer</code> geh\u00f6rt (<code>Integer</code> ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). </li> <li>wenn <code>input</code> eine Zahl enth\u00e4lt, also z.B. so aussieht: <code>\"1234\"</code>, dann erzeugt <code>parseInt()</code> daraus die <code>int</code>-Zahl <code>1234</code> und alles ist ok. Wenn <code>input</code> jedoch keine Zahl enth\u00e4lt, also z.B. <code>\"hallo\"</code>, dann wirft <code>parseInt()</code> eine <code>NumberFormatException</code>, weil die Umwandlung des <code>String</code>s in ein <code>int</code> nicht m\u00f6glich ist. </li> <li>in Zeile <code>55</code> wird eine solche <code>NumberFormatException</code> aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter <code>inputOk</code> auf <code>false</code> gesetzt wird. </li> <li>der gesamte Anweisungsblock Fenster-&gt;Eingabe-&gt;try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von <code>inputOk</code> nicht <code>false</code> ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit <code>parseInt()</code> keine Exception wirft)</li> </ul> <p>\u00dcbrigens k\u00f6nnte die Anweisung <code>inputOk = true;</code> auch nach <code>parseInt()</code> in den <code>try</code>-Block geschrieben werden:</p> <pre><code>static int inputInt()\n{\n    int inputInt = 0;\n    boolean inputOk = false;\n    String input =\"\";\n    while(!inputOk)\n    {\n        input = JOptionPane.showInputDialog(\"Zahl :\");\n\n        try {\n            inputInt = Integer.parseInt(input);\n            inputOk = true;\n        }\n        catch(NumberFormatException e)\n        {\n            inputOk = false;\n        }\n    }\n    return inputInt;\n}\n</code></pre> <p>Zeile <code>12</code> wird nur genau dann erreicht, wenn <code>parseInt()</code> keine Exception wirft. Dann wird auch der <code>catch</code>-Block nicht betreten und die Schleife wird beendet. </p>"},{"location":"exceptions/#beispiel-mit-mehreren-exceptions","title":"Beispiel mit mehreren Exceptions","text":"<p>Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende <code>catch</code>-Klausel gesucht wird. Wir erweitern dazu unsere Klasse <code>Ausnahmen</code> um eine weitere Methode <code>mehrereExceptions()</code>:</p> <pre><code>public static void mehrereExceptions()\n{\n    String[] basen = {\"2\", \"8\", \"10\", \"Hi\"};\n    int base = 0;\n    double result= 0;\n    boolean ok = true;\n\n    for(int index = 0; index&lt;=4; index++) \n    {\n        try {\n            base = Integer.parseInt(basen[index]);\n            ok = true;\n        }\n        catch(NumberFormatException nfe) {\n            System.out.println(\"Keine Zahl!\");\n            ok = false;\n        }\n        catch(IndexOutOfBoundsException ioobe) {\n            System.out.println(\"Ausserhalb des Arrays\");\n            ok = false;\n        }\n        for(int exp = 0; exp&lt;6 &amp;&amp; ok; exp++) {\n            result = Math.pow(base, exp);\n            System.out.printf(\"%d ^ %d = %.0f %n\", base, exp, result);\n        }\n    }\n}\n</code></pre> <ul> <li>In Zeile <code>3</code> definieren wir uns ein <code>String[]</code> mit 4 Eintr\u00e4gen. </li> <li>Durch dieses <code>String[]</code> laufen wir mit einer <code>for</code>-Schleife (Zeile <code>8</code>) durch.</li> <li>In Zeile <code>11</code> wandeln wir jeden Eintrag aus dem <code>String[]</code> in eine <code>int</code>-Zahl um. </li> <li>An zwei Stellen k\u00f6nnen Exceptions geworfen werden:<ul> <li>Bei dem Index-basierten Zugriff auf das Array <code>basen[index]</code> in Zeile <code>11</code> kann eine <code>ArrayIndexOutOfBounds</code>-Exception geworfen werden, falls <code>index</code> kein korrekter Index des <code>String[]</code> ist (gilt f\u00fcr <code>index==4</code>).</li> <li>Bei der Umwandlung von <code>String</code> nach <code>int</code> durch <code>parseInt()</code> in Zeile <code>11</code> kann eine <code>NumberFormatException</code> geworfen werden, falls der entsprechende Eintrag im <code>String[]</code> keine Zahl ist (gilt f\u00fcr <code>basen[3]=='Hi'</code>).</li> </ul> </li> </ul> <p>Die Methode erzeugt die folgende Ausgabe:</p> <pre><code>2 ^ 0 = 1 \n2 ^ 1 = 2 \n2 ^ 2 = 4 \n2 ^ 3 = 8 \n2 ^ 4 = 16 \n2 ^ 5 = 32 \n8 ^ 0 = 1 \n8 ^ 1 = 8 \n8 ^ 2 = 64 \n8 ^ 3 = 512 \n8 ^ 4 = 4096 \n8 ^ 5 = 32768 \n10 ^ 0 = 1 \n10 ^ 1 = 10 \n10 ^ 2 = 100 \n10 ^ 3 = 1000 \n10 ^ 4 = 10000 \n10 ^ 5 = 100000 \nKeine Zahl!\nAusserhalb des Arrays\n</code></pre> <p>Das hei\u00dft, dass wenn f\u00fcr <code>parseInt(\"Hi\")</code> eine <code>NumberFormatException</code> geworfen wird, dann wird der <code>catch</code>-Block ausgef\u00fchrt, der eine <code>NumberFormatException</code> erwartet (Zeilen <code>14-17</code>). Der andere <code>catch</code>-Block wird nicht ausgef\u00fchrt. </p> <p>Wenn f\u00fcr <code>basen[4]</code> eine <code>ArrayIndexOutOfBoundsException</code> geworfen wird, dann wird der  <code>catch</code>-Block ausgef\u00fchrt, der eine <code>IndexOutOfBoundsException</code> erwartet (Zeilen <code>18-21</code>). Der andere <code>catch</code>-Block wird nicht ausgef\u00fchrt.</p> <p>Wir sehen, dass es offensichtlich auch eine <code>IndexOutOfBoundsException</code>-Klasse gibt. Das ist eine Elternklasse von <code>ArrayIndexOutOfBoundsException</code> und auch von <code>StringIndexOutOfBoundsException</code>. Wir schauen uns diese Vererbungshierarchie von <code>Exception</code> nun mal an:</p>"},{"location":"exceptions/#die-vererbungshierarchie-der-klasse-exception","title":"Die Vererbungshierarchie der Klasse Exception","text":"<p>Wenn Sie sich die Klasse <code>Exception</code> in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen:</p> <p></p> <p>Alle Exception-Klassen erben von der Klasse <code>Exception</code>, die im <code>java.lang</code>-Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden:</p> <ul> <li>checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen <code>try-catch</code>-Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem <code>try</code>-Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). </li> <li>unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse <code>RunTimeException</code> ab. Wir werden uns genau mit diesen uncheck Exceptions, also von <code>RunTimeException</code> abgeleiteten Klassen besch\u00e4ftigen. </li> </ul> <p>Es gibt von <code>RunTimeException</code> noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die <code>IllegalArgumentException</code>-Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene <code>Exception</code>-Klassen erstellen. </p>"},{"location":"exceptions/#try-catch-finally","title":"try-catch-finally","text":"<p>Prinzipiell besteht das Konstrukt <code>try</code> und <code>catch</code> nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem <code>finally</code>-Block. Der <code>finally</code>-Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt:</p> <pre><code>    try \n    {\n        // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt)\n    }   \n    catch(Exception e)  \n    {\n        // Behandlung der Exception \n    }\n    finally\n    {\n        // Aufraeumen, z.B. Schliessen von Dateien, Beenden von \n        // Verbindungen zu Servern, Datenbanken etc.\n    }\n</code></pre> <p>Typischerweise wird der <code>finally</code>-Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden <code>finally</code> jedoch nicht sehr oft implementieren. </p>"},{"location":"exceptions/#throws-eine-exception-weiterreichen","title":"throws - eine Exception weiterreichen","text":"<p>Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem <code>try-catch</code>-Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort <code>throws</code> verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um <code>throws</code> und danach kommt der entsprechende Typ der Exception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus:</p> <pre><code>[modifizierer] [rueckgabetyp] methodenname throws ExceptionType\n{\n    // Anweisungsblock\n    // wirft (evtl.) Exception\n}   \n</code></pre> <p>Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse <code>Ausnahmen</code> um die Methode <code>getValueAtIndex</code>: </p> <pre><code>static int getValueAtIndex(int[] field, int index) throws ArrayIndexOutOfBoundsException\n{\n    return field[index];\n}\n\n\npublic static void main(String[] args) \n{\n    System.out.println(divide(5,0));            // ArithmeticException\n    System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n    System.out.println(\"Zahl: \" + inputInt());  // NumberFormatException\n    mehrereExceptions();\n\n    int value = 0;\n    boolean ok = true;\n    int[] field = {8, 3,-4, 2, -9};\n    try\n    {\n        value = getValueAtIndex(field,-3);\n    }\n    catch(ArrayIndexOutOfBoundsException e)\n    {\n        System.out.println(\"Index ausserhalb des Arrays!\");\n        ok = false;\n    }\n    if(ok) \n    {\n        System.out.println(\"value : \" + value);\n    }\n}\n</code></pre> <p>Obwohl die Methode eine kritische Anweisung enth\u00e4lt (<code>field[index]</code>), ist diese Anweisung nicht in einen <code>try-catch</code>-Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine <code>ArrayIndexOutOfBoundsException</code>) geworfen wird. Wir geben das im Methodenkopf mithilfe von <code>throws ArrayIndexOutOfBoundsException</code> bekannt. Die aufrufende Methode (<code>main</code>) kann nun selbst den Aufruf der Methode <code>getValueAtIndex()</code> in einen <code>try-catch</code>-Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode <code>getValueAtIndex()</code> zur\u00fcckgegebene Wert ausgegeben. </p> <p>Wenn wir an unsere einleitenden Beispiele denken (Methoden <code>charAt()</code> und <code>divide()</code>), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von <code>getValueAtIndex()</code> vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei <code>charAt()</code>. Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln. </p>"},{"location":"exceptions/#schoner-code","title":"Sch\u00f6ner Code","text":"<p>Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. </p> <p>Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: </p> <ol> <li>eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP)</li> <li>\u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich)</li> <li>\u2192 lassen Sie Methode, die etwas erledigt, eine Exception werfen und leiten Sie diese weiter (<code>throws</code>) </li> <li>\u2192 fangen Sie den Fehler in einer anderen Methode ab (<code>try</code>)</li> <li>\u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers (<code>catch</code>) in eine dritte Methode auslagern (single responsibility)</li> </ol> <p>H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt (<code>try</code>) im <code>catch</code>-Block den Fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an. </p>"},{"location":"exceptions/#throw-eigene-exceptions-erzeugen","title":"throw - eigene Exceptions erzeugen","text":"<p>Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich <code>throw</code>. Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort <code>throws</code> sehr \u00e4hnlich. Mit <code>throw</code> erzeugen (werfen) wir eine eigene Exception, mit <code>throws</code> wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. </p> <p>Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe <code>Triangle</code>im ersten Semester bereits \u00fcberlegt, dass dadurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. Das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird?</p> <p>Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes <code>throw</code> wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja (\"automatisch\" durch die Laufzeitumgebung) geworfen. </p> <p>F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten:</p> <ul> <li>entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse <code>Exception</code> oder von der Klasse <code>RunTimeException</code> ab (<code>extends Exception</code> bzw. <code>extends RunTimeException</code>) oder</li> <li>wir verwenden eine bereits existierende Exception-Klasse (typischerweise <code>IllegalArgumentException</code>).</li> </ul>"},{"location":"exceptions/#throw-new-illegalargumentexception","title":"throw new IllegalArgumentException","text":"<p>Wir implementieren unsere Klasse <code>Triangle</code> so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine <code>IllegalArgumentException</code> werfen. Dieser Exception kann ein <code>String</code> als Parameter \u00fcbergeben werden, der im <code>catch</code>-Block mittels <code>getMessage()</code> wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist.</p> Triangle mit eigenen IllegalArgumentExceptions <pre><code>public class Triangle\n{\n    private int a,b,c;\n\n    public Triangle(int a, int b, int c) throws IllegalArgumentException\n    {\n        if(a&lt;=0 || b&lt;=0 || c&lt;=0) \n        {\n            throw new IllegalArgumentException(\"Seiten muessen groesser als 0 sein!\");\n        }\n        else if(a&gt;=(b+c) || b&gt;=(a+c) || c&gt;=(a+b)) \n        {\n            throw new IllegalArgumentException(\"Kein Dreieck!\");\n        }\n        else \n        {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n    public static void main(String[] args) \n    {\n        Triangle d;\n\n        try {\n            d = new Triangle(3,4,5);        //(3,4,0) und (3,4,8) probieren\n        }\n        catch(IllegalArgumentException e) \n        {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n</code></pre> <p>Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile <code>5</code> - <code>throws IllegalArgumentException</code>). Im Konstruktor werden die Parameterwerte gepr\u00fcft und</p> <ul> <li>entweder eine <code>IllegalArgumentException</code> geworfen, falls eine Seite kleiner gleich 0 ist (Zeile <code>9</code> - <code>throw new</code>) </li> <li>oder eine <code>IllegalArgumentException</code> geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile <code>13</code> - <code>throw new</code>) </li> <li>oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen <code>17-19</code>).</li> </ul> <p>Die Erzeugung eines <code>Triangle</code>-Objektes (also der Aufruf des Konstruktors) ist nun in einen <code>try-catch</code>-Block eingebettet (Zeilen <code>26-32</code>). Beachten Sie, dass es sein kann, dass <code>d</code> nach Aufruf des Konstruktors immernoch <code>null</code> ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die <code>main</code>-Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen.</p>"},{"location":"exceptions/#eigene-exception-klasse-definieren","title":"Eigene Exception-Klasse definieren","text":"<p>Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von <code>Triangle</code>. Diese eigenen Exception-Klassen erben von der Klasse <code>Exception</code>. Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem <code>try-catch</code>-Block abgefangen und behandelt werden. </p> Eigene Klasse IllegalTriangleException <pre><code>public class IllegalTriangleException extends Exception\n{\n    public IllegalTriangleException(String s) {\n        super(s);\n    }\n\n    public IllegalTriangleException() {\n        super(\"Each side has to be smaller than the sum of the other sides!\");\n    }\n}\n</code></pre> <p>Die Klasse <code>IllegalTriangleException</code> verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. </p> Eigene Klasse IllegalSideLengthException <pre><code>public class IllegalSideLengthException extends Exception\n{\n\n    public IllegalSideLengthException(String s) {\n        super(s);\n    }\n\n    public IllegalSideLengthException() {\n        super(\"Sides must be greater than zero!\");\n    }\n}\n</code></pre> <p>Die Klasse <code>IllegalSideLengthException</code> verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von <code>Exception</code> erzeugt und dem eine Fehlermeldung als <code>String</code> im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als <code>String</code> \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. </p> <p>Die Anwendung dieser beiden Exception-Klassen in der Klasse <code>Triangle</code> k\u00f6nnte nun so aussehen (wir haben hier auch gleich die <code>main</code>-Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen):</p> Triangle mit den selbst definierten Exception-Klassen <pre><code>public class Triangle\n{\n    private int a,b,c;\n\n    public Triangle(int a, int b, int c) throws Exception\n    {\n        if(a&lt;=0 || b&lt;=0 || c&lt;=0) \n        {\n            throw new IllegalTriangleException();\n        }\n        else if(a&gt;=(b+c) || b&gt;=(a+c) || c&gt;=(a+b)) \n        {\n            throw new IllegalSideLengthException();\n        }\n        else \n        {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n\n    public static void main(String[] args) \n    {\n        Triangle d;\n\n        try {\n            d = new Triangle(3,4,5);        //(3,4,0) und (3,4,8) probieren\n        }\n        catch(Exception e) \n        {\n            System.out.println(e.getMessage());\n        }\n\n    }\n}\n</code></pre> <p>Beide eigenen Klassen sind ja auch vom Laufzeittyp <code>Exception</code>, da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der <code>catch</code>-Klausel mit <code>Exception</code> (Zeile <code>30</code>) passend. Wenn Sie anstelle der Zeilen <code>27-33</code> nur <code>d = new Triangle(3,4,5);</code> schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem <code>try-catch</code>-Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an <code>Surround with try/catch</code>. Das sollten Sie einmal ausprobieren. </p> <p>Wenn Sie anstelle von <code>Exception</code> von der Klasse <code>RunTimeException</code> erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist sehr strittig, ob man lieber checked oder unchecked Exceptions erstellt. Einerseits sind die Exceptions ja genau dazu da, dass sie abgefangen und behandelt werden. Andererseits erzeugt das Abfangen und Behandeln von Exception viel Boilerplate-Code. Moderne Programmiersprachen, wie z.B. Kotlin haben gar keine checked Exceptions mehr.</p> <p>Success</p> <p>Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von <code>Exception</code>, insb. von <code>RunTimeException</code>). Mithilfe von <code>try-catch-[finally]</code> k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von <code>throws</code> zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort <code>throw</code> weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem <code>try-catch</code>-Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...</p>"},{"location":"generics/","title":"Generics","text":"<p>Ein generischer Typ (generic type) ist eine Klasse oder ein Interface, die mit einem oder mehreren Typen parametrisiert ist. Wir kennen die Anwendung von Generics bereits aus Collections. So sind z.B. die Typen <code>List</code> und <code>Set</code> mit dem generischen Typen <code>E</code> parametrisiert. Generell gilt also <code>List&lt;E&gt;</code> und <code>Set&lt;E&gt;</code>, wobei <code>E</code> f\u00fcr einen beliebigen (Referenz-)Typen f\u00fcr die Elemente in der Liste bzw. der Menge stehen. Den konkreten Typ der Elemente gibt man dann bei der Deklaration an:</p> <pre><code>List&lt;String&gt; words = new ArrayList&lt;&gt;();     // Liste, die Strings enthaelt\nSet&lt;Integer&gt; numbers = new HashSet&lt;&gt;();     // menge, die Integer enthaelt\n</code></pre> <p>Wir zeigen hier nun, wie wir uns eine eigene generische Klasse schreiben k\u00f6nnen:</p> MyGenericClass.java <pre><code>public class MyGenericClass&lt;T&gt;\n{\n    T value;\n\n    public MyGenericClass(T value)\n    {\n        this.value = value;\n    }\n\n    public T getValue()\n    {\n        return value;\n    }\n}\n</code></pre> <p>Wir parametrisieren im Klassenkopf die Klasse <code>MyGenericClass</code> einfach mittels <code>&lt;T&gt;</code> mit einem Typen und verwenden diesen Platzhalter <code>T</code> \u00fcberall dort, wo der Typ verwendet wird, z.B. bei der Deklaration der Objektvariablen <code>value</code>, beim Parameter im Konstruktor und beim R\u00fcckgabetyp des Getters.</p> <p>Bei der Objekterzeugung kann nun jeder beliebige (Referenz-)Typ anstelle von <code>T</code> gesetzt werden. Dazu typisieren wir:</p> <pre><code>MyGenericClass&lt;String&gt; testMitString = new MyGenericClass&lt;&gt;(\"Hallo\");\nSystem.out.println(testMitString.getValue());\n\nMyGenericClass&lt;Integer&gt; testMitInteger = new MyGenericClass&lt;&gt;(42);\nSystem.out.println(testMitInteger.getValue());\n</code></pre> <p>Zur Typisierung kann jeder beliebige Referenztyp, also auch <code>Konto</code>, <code>Rectangle</code>, <code>Person</code>, <code>Student</code> usw. verwendet werden, nicht aber Wertetypen. Beachten Sie, dass wenn wir unsere Klasse mit <code>String</code> typisieren, dann muss im Konstruktor auch ein <code>String</code> \u00fcbergeben werden und wenn <code>Integer</code> dann dort auch ein <code>Integer</code>. Andernfalls l\u00e4sst sich das Programm nicht \u00fcbersetzen. Eine Klasse (bzw. ein Interface) kann mit beliebig vielen generischen Typen parametrisiert werden. </p> <p>Welche Bezeichnungen Sie f\u00fcr die generischen Typen verwenden, bleibt Ihnen \u00fcberlassen. K\u00f6nnte z.B. auch <code>Hallo</code> sein. es gibt aber Konventionen, an die Sie sich ruhig halten sollten:</p> Platzhalter \u00a0Bedeutung <code>E</code> \u00a0Element <code>K</code> \u00a0Key <code>N</code> \u00a0Number <code>T</code> \u00a0Type <code>V</code> \u00a0Value <code>S</code>, <code>U</code> \u00a02. und 3. Typ <p>Manchmal werden an die generischen Typen spezielle Anforderungen gestellt. Angenommen, wir wollen die Klasse <code>MyGenericClass&lt;T&gt;</code> um folgende Methode erweitern:</p> <pre><code>```java linenums=\"18\"\npublic boolean isBigger(MyGenericClass&lt;T&gt; other)\n{\n    return this.value.compareTo(other.value) &gt; 0;\n}\n```\n</code></pre> <p>Dann br\u00e4uchten wir die Zusicherung, dass der Typ <code>T</code> auch <code>Comparable</code> implementiert hat, denn sonst k\u00f6nnten wir <code>compareTo()</code> gar nicht aufrufen. Eine solche Zusicherung l\u00e4sst sich mittels <code>&lt;T extends Comparable&lt;T&gt;&gt;</code> beschreiben: </p> MyGenericClass&gt;.java <pre><code>public class MyGenericClass&lt;T extends Comparable&lt;T&gt;&gt;\n{\n    T value;\n\n    public MyGenericClass(T value)\n    {\n        this.value = value;\n    }\n\n    public T getValue()\n    {\n        return value;\n    }\n\n    public boolean isBigger(MyGenericClass&lt;T&gt; other)\n    {\n        return this.value.compareTo(other.value) &gt; 0;\n    }\n}\n</code></pre>"},{"location":"generics/#beispiel-einfaches-interface","title":"Beispiel einfaches Interface","text":"<p>Angenommen, wir haben folgendes einfaches funktionales Interface:</p> Addable.java <pre><code>@FunctionalInterface\npublic interface Addable&lt;T, R&gt;\n{\n    public R add(T t1, T t2);\n}\n</code></pre> <p>Dann k\u00f6nnten wir uns beliebige Methoden schreiben, die ein <code>Addable</code> erwarten, z.B.</p> <pre><code>public static String concat(Addable&lt;String, String&gt; addable, String first, String second)\n{\n    return addable.add(first, second);\n}\n\npublic static Integer add(Addable&lt;Integer, Integer&gt; addable, Integer first, Integer second)\n{\n    return addable.add(first, second);\n}\n\npublic static List&lt;Integer&gt; insert(Addable&lt;Integer, List&lt;Integer&gt;&gt; addable, Integer first, Integer second)\n{\n    return addable.add(first, second);\n}\n</code></pre> <p>und bei Aufruf der Methoden jeweils mithilfe von Lambdas die Implementierung von <code>R add(T t1, T t2)</code> angeben:</p> <pre><code>System.out.println(concat( (s1, s2) -&gt; s1 + s2, \"Hallo \", \"FIW!\"));\nSystem.out.println(add( (s1, s2) -&gt; s1 + s2, 3, 4));\nSystem.out.println(insert( (s1, s2) -&gt; List.of(s1, s2), 3, 4));\n</code></pre> Wie k\u00f6nnte das Zusammenf\u00fcgen zweier Sets aussehen? <pre><code>public static Set&lt;String&gt; addAll(Addable&lt;Set&lt;String&gt;, Set&lt;String&gt;&gt; addable, Set&lt;String&gt; first, Set&lt;String&gt; second)\n{\n    return addable.add(first, second);\n}\n\nSystem.out.println(addAll( (s1, s2) -&gt; {\n    Set&lt;String&gt; all = new HashSet&lt;&gt;(s1);\n    all.addAll(s2);\n    return all;\n}, new HashSet&lt;&gt;(List.of(\"A\", \"B\", \"C\", \"D\")), new HashSet&lt;&gt;(List.of(\"C\", \"D\", \"E\", \"F\"))));\n</code></pre>"},{"location":"generics/#eine-generische-sortiermethode","title":"Eine generische Sortiermethode","text":"<p>Wir haben uns im ersten Semester verschiedene Sortiermethoden f\u00fcr Arrays unterschiedlichen Typs geschrieben. Eine generische Methode k\u00f6nnte wie folgt aussehen:</p> <pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt; void bubbleSort(T[] array) {\nfor (int bubble = 1; bubble &lt; array.length; bubble++) {\n  for (int index = 0; index &lt; array.length - bubble; index++) {\n    if (array[index].compareTo(array[index + 1]) &gt; 0) {\n      swap(index, index + 1, array);\n    }\n  }\n}\n}\n\npublic static &lt;T&gt; void swap(int i, int j, T[] a) {\n    T t = a[i];\n    a[i] = a[j];\n    a[j] = t;\n}\n</code></pre> <p>Diese Methode stellt 2 Anforderungen:</p> <ul> <li>der Typ des Arrays ist ein Referenztyp (\u00fcfr Wertetypen m\u00fcssen entsprechende Wrapperklassen verwendet werden),</li> <li>der Typ des Arrays implementiert das Interface <code>Comparable</code>. Wird ein Typ verwendet, der nicht <code>Comparable</code> implementiert hat, erhalten wir eine <code>ClassCastException</code>. </li> </ul>"},{"location":"generics/#wildcards","title":"Wildcards","text":"<p>Ein Typ kann mit der Wildcard <code>?</code> angegeben werden, dann ist jeder beliebige (Referenz-)Typ m\u00f6glich. Beispiel:</p> <pre><code>List&lt;?&gt; list = new ArrayList&lt;String&gt;();\nlist = new ArrayList&lt;Integer&gt;(); // Works with any type\n</code></pre> <p>Eine solche Wildcard wird jedoch meistens nicht wie oben, sondern entweder als Upper-Bounded-Wildcard  oder als Lower-Bounded-Wildcard. Mit der PECS-Eselsbr\u00fccke kann man sich merken, ob <code>extends</code> (Upper-Bounded-Wildcard) oder <code>super</code> (Lower-Bounded-Wildcard) verwendet werden soll. PECS steht f\u00fcr Producer-Extends, Consumer-Super.</p>"},{"location":"generics/#upper-bounded-wildcard","title":"Upper-Bounded-Wildcard","text":"<pre><code>public void printNumbers(List&lt;? extends Number&gt; list) {\n    for (Number n : list) {\n        System.out.println(n);\n    }\n}\n</code></pre> <p>Es wird eine Liste erwartet, deren Typ mindestens von <code>Number</code> abgeleitet wurde (also z.B. <code>Interger</code>, <code>Double</code>, <code>Long</code>). <code>String</code> oder <code>Boolean</code> ginge z.B. nicht. Die Liste produziert die Input-Werte.</p>"},{"location":"generics/#lower-bounded-wildcard","title":"Lower-Bounded-Wildcard","text":"<pre><code>public void addNumbers(List&lt;? super Integer&gt; list) {\n    list.add(10); // You can add Integer or its subclass\n}\n</code></pre>"},{"location":"interfaces/","title":"Interfaces","text":"<p>Interfaces sind auch abstrakte Klassen. Interfaces enthalten ausschlie\u00dflich abstrakte Methoden (keine Methode darf implementiert sein). Interfaces beschreiben Schnittstellen. F\u00fcr Interfaces wird nicht das Schl\u00fcsselwort <code>class</code>, sondern <code>interface</code> verwendet. Klassen erben nicht von Interfaces, sondern implementieren sie. Deshalb wird auch nicht das Schl\u00fcsselwort <code>extends</code>, sondern das Schl\u00fcsselwort <code>implements</code> verwendet. W\u00e4hrend in Java nur von genau einer Klasse geerbt werden kann (also auch nur von genau einer abstrakten Klasse), kann eine Klasse beliebig viele Interfaces implementieren. </p> <p>Interfaces sind automatisch <code>abstract</code>, d.h. das Schl\u00fcsselwort <code>abstract</code> muss nicht angegeben werden. Auch die Methoden in Interfaces m\u00fcssen nicht als abstrakt gekennzeichnet werden. Interfaces k\u00f6nnen, wie abstrakte Klassen auch, als Typen verwendet werden. </p> \u00a0Abtrakte Klasse \u00a0Interface es kann nur von einer (abstrakten) Klasse geerbt werden (Schl\u00fcsselwort <code>extends</code>) es k\u00f6nnen beliebig viele Interfaces implementiert werden (Schl\u00fcsselwort <code>implements</code>), mehrere Interfaces durch Komma getrennt das Schl\u00fcsselwort <code>abstract</code> deklariert eine abstrakte Klasse (und eine abstrakte Methode) das Schl\u00fcsselwort <code>interface</code> deklariert ein Interface eine abstrakte Klasse kann von einer anderen abstrakten Klasse erben und mehrere Interfaces implementieren ein Interface kann nur von einem anderen Interface erben die Eigenschaften einer abstrakten Klasse k\u00f6nnen <code>private</code>, <code>protected</code>, default und <code>public</code> sein in Interfaces sind alle Eigenschaften <code>public</code> Bsp.: <code>public abstract class Shape{ public abstract void draw(); }</code> Bsp.: <code>public interface Drawable{ void draw(); }</code>"},{"location":"interfaces/#das-interface-comparable","title":"Das Interface <code>Comparable</code>","text":"<p>Ehe wir uns ein eigenes Interface schreiben, schauen wir uns zun\u00e4chst die Verwendung eines bereits existierenden Interfaces an. Es handelt sich um das Interface Comparable aus dem <code>java.lang</code>-Paket. Wenn Sie sich die Java-Dokumentation dieses Interfaces einmal anschauen, dann sehen Sie, dass es von sehr vielen Klassen implementiert wird. Dieses Interface enth\u00e4lt genau eine (nat\u00fcrlich abstrakte) Methode <code>compareTo()</code>. Diese Methode kennen wir auch schon, denn wir haben sie betrachtet, als wir in Prog1 Strings kennengelernt haben. </p> <p>Die Methode <code>this.compareTo(Object obj)</code> wird verwendet, um zu vergleichen, ob <code>this</code> gr\u00f6\u00dfer, kleiner oder gleich <code>obj</code> ist. Das bedeutet, dass wir <code>compareTo()</code> in unserer Klasse implementieren sollten, wenn wir die Objekte unserer Klasse der Gr\u00f6\u00dfe nach ordnen wollen, wenn wir also erm\u00f6glichen wollen, dass die Objekte der Klasse sortiert werden k\u00f6nnen. </p> <p>Die Methode <code>this.compareTo(Object obj)</code> gibt ein <code>int</code> zur\u00fcck, f\u00fcr dessen Wert Folgendes gelten soll:</p> <ul> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert positiv (<code>&gt; 0</code>), dann ist <code>this</code> gr\u00f6\u00dfer als <code>obj</code>,</li> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert negativ (<code>&lt; 0</code>), dann ist <code>this</code> kleiner als <code>obj</code>,</li> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert <code>0</code>, dann ist <code>this</code> gleich <code>obj</code>.</li> </ul> <p>Angenommen, wir wollen f\u00fcr die folgende Klasse <code>Rectangle</code> (aus dem Abschnitt Abstrakte Klassen) festlegen, dass die Rechtecke der Gr\u00f6\u00dfe nach geordnet werden k\u00f6nnen. Gegeben ist also zun\u00e4chst folgende Klasse (wir verwenden hier auch <code>Shape</code> aus Abstrakte Klassen):</p> <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n}\n</code></pre> <p>Die Klasse <code>Rectangle</code> erbt also von der abstrakten Klasse <code>Shape</code> und muss deshalb die Methoden <code>perimeter()</code> und <code>area()</code> implementieren. Nun geben wir an, dass <code>Rectangle</code> auch das Interface <code>Comparable</code> implementieren soll. Dazu erg\u00e4nzen wir die erste Zeile um <code>implements Comparable</code>, d.h. die Klassendeklaration sieht jetzt so aus:</p> <pre><code>public class Rectangle extends Shape implements Comparable\n{\n</code></pre> <p>Wenn Sie das hinzuf\u00fcgen, stellen wir fest, dass ein Fehler erzeugt wird (die Klasse l\u00e4sst sich nicht compilieren). Die Fehlerausgabe besagt: <code>The type Rectangle must implement the inherited abstract method Comparable.compareTo(Object)</code>. Es werden zwei <code>QuickFixes</code> angeboten, </p> <ul> <li>entweder <code>Add unimplemented methods</code> </li> <li>oder <code>Make type Rectangle abstract</code>. </li> </ul> <p>Letzteres wollen wir aber nicht (<code>Rectangle</code> soll nicht zu einer abstrakten Klasse gemacht werden). Also w\u00e4hlen wir <code>Add unimplemented methods</code>. Eclipse f\u00fcgt uns die <code>compareTo()</code>-Methode in den Code ein:</p> <pre><code>public class Rectangle extends Shape implements Comparable\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n}\n</code></pre> <p>Jetzt l\u00e4sst sich der Code bereits compilieren, wir erhalten aber noch eine Warnung:</p> <pre><code>Comparable is a raw type. References to generic type Comparable&lt;T&gt; should be parameterized\n</code></pre> <p>Diese Warnung besagt, dass wir, wie wir das von Collections bereits kennen, auch das Interface <code>Comparable</code> typisieren sollen. Das wollen wir auch tun, denn wir implementieren dieses Interface hier f\u00fcr unsere Klasse <code>Rectangle</code>. Wir typisieren deshalb <code>Comparable</code> mit <code>Rectangle</code>: </p> <pre><code>public class Rectangle extends Shape implements Comparable&lt;Rectangle&gt;\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n}\n</code></pre> <p>Interssanterweise ist nun zwar unsere Warnung weg, aber daf\u00fcr erhalten wir erneut einen Fehler:</p> <pre><code>The type Rectangle must implement the inherited abstract method Comparable&lt;Rectangle&gt;.compareTo(Rectangle)\n</code></pre> <p>Dadurch, dass wir <code>Comparable</code> mit <code>Rectangle</code> typisieren (was korrekt ist), wird nun verlangt, dass wir nicht mehr die Methode </p> <pre><code>    @Override\n    public int compareTo(Object o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n</code></pre> <p>implementieren, sondern die Methode </p> <pre><code>    @Override\n    public int compareTo(Rectangle o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n</code></pre> <p>Der Typ des Parameters hat sich durch unsere Typisierung also ge\u00e4ndert. Das ist gut, denn dann m\u00fcssen wir nicht mehr, wie z.B. bei <code>equals(Object o)</code>, pr\u00fcfen, ob es sich bei dem \u00fcbergebenen Objekt tats\u00e4chlich um ein <code>Rectangle</code> handelt. Wir \u00e4ndern also den Parametertyp in <code>compareTo()</code>:</p> <pre><code>public class Rectangle extends Shape implements Comparable&lt;Rectangle&gt;\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Rectangle o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n}\n</code></pre> <p>In Zukunft typisieren wir das <code>Comparable</code>-Interface noch, bevor wir <code>Add unimplemented methods</code> w\u00e4hlen. Wir typisieren es stets mit der Klasse, in der wir das Interface implementieren. </p> <p>F\u00fcr die Implementierung m\u00fcssen wir uns nun \u00fcberlegen, wann ein <code>Rectangle</code>-Objekt gr\u00f6\u00dfer (kleiner/gleich) sein soll, als ein anderes. Da <code>compareTo()</code> ein <code>int</code> zur\u00fcckgibt, k\u00f6nnten wir z.B. die Summen von <code>height</code> und <code>width</code> verwenden:</p> <pre><code>    @Override\n    public int compareTo(Rectangle o) {\n        int diff = (this.height+this.width) - (o.height+o.width);\n        return diff;\n    }\n</code></pre> <p>Wenn die Summe von <code>height</code> und <code>width</code> von <code>this</code> gr\u00f6\u00dfer ist, als von <code>o</code>, dann geben wir eine positive <code>int</code>-Zahl zur\u00fcck, wenn sie kleiner ist, dann eine negative <code>int</code>-Zahl und wenn sie gleich sind, dann <code>0</code>. Damit entsprechen wir den Vorgaben von <code>compareTo()</code>. </p>"},{"location":"interfaces/#laufzeittypen-eines-rectangle-objektes","title":"Laufzeittypen eines <code>Rectangle</code>-Objektes","text":"<p>Ein <code>Rectangle</code>-Objekt ist nicht nur vom Laufzeittyp <code>Rectangle</code>, sondern auch</p> <ul> <li>von Laufzeittyp <code>Shape</code>, wegen <code>public class Rectangle extends Shape</code>, </li> <li>vom Laufzeittyp <code>Comparable</code>, wegen <code>public class Rectangle implements Comparable</code> und</li> <li>vom Laufzeittyp <code>Object</code>, weil das immer so ist, weil jede Klasse implizit von <code>Object</code> erbt. </li> </ul> <p>Wir k\u00f6nnten nun also in jeder beliebigen Klasse eine Sortiermethode haben, z.B.: </p> <pre><code>    public static void sortieren(Comparable[] unsorted)\n    {   \n        for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n        {\n            for(int index=0; index&lt;unsorted.length-bubble; index++)\n            {\n                if(unsorted[index].compareTo(unsorted[index+1]) &gt; 0) \n                {\n                    Comparable tmp = unsorted[index];\n                    unsorted[index] = unsorted[index+1];\n                    unsorted[index+1] = tmp;            \n                }\n            }\n        }\n    }\n</code></pre> <p>Die Methode implementiert Bubble-Sort. In Zeile <code>7</code> verwenden wir die <code>compareTo()</code>-Methode. Das geht genau deshalb, weil klar ist, dass ein Objekt, das (auch) vom Typ <code>Comparable</code> ist, diese Methode auf jeden Fall als Eigenschaft besitzt. Wenn wir nun in der Klasse, in der die Methode <code>sortieren()</code> implementiert ist, folgende <code>main()</code>-Methode haben:</p> <pre><code>public static void main(String[] args) {\n        Rectangle[] rectArr = new Rectangle[6];\n        rectArr[0] = new Rectangle(9, 13);\n        rectArr[1] = new Rectangle(4, 17);\n        rectArr[2] = new Rectangle(12, 5);\n        rectArr[3] = new Rectangle(8, 9);\n        rectArr[4] = new Rectangle(10, 11);\n        rectArr[5] = new Rectangle(5, 15);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        sortieren(rectArr);\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n    }\n</code></pre> <p>dann erhalten wir folgende Ausgabe:</p> <pre><code>------------------------ unsortiert --------------------------\n\n[  9 x 13 = 117,00 ] \n[  4 x 17 =  68,00 ] \n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[ 10 x 11 = 110,00 ] \n[  5 x 15 =  75,00 ] \n\n\n------------------------- sortiert ---------------------------\n\n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[  5 x 15 =  75,00 ] \n[  4 x 17 =  68,00 ] \n[ 10 x 11 = 110,00 ] \n[  9 x 13 = 117,00 ] \n</code></pre> <p>f\u00fcr den Fall, dass wir in unserer Klasse <code>Rectangle</code> auch die <code>toString()</code>-Methode wie folgt implementiert haben:</p> <pre><code>    @Override\n    public String toString()\n    {   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); \n        return s;\n    }\n</code></pre> <p>Success</p> <p>Wir haben f\u00fcr unsere Klasse <code>Rectangle</code> das Interface <code>Comparable</code> implementiert. Das bedeutet, dass wir in <code>Rectangle</code> die Methode <code>compareTo()</code> so implementiert haben, dass <code>Rectangle</code>-Objekte der Gr\u00f6\u00dfe nach sortiert werden k\u00f6nnen. Wir haben also eine Ordnung \u00fcber <code>Rectangle</code>-Objekte definiert. Nach \"au\u00dfen\" ist sichtbar, dass wir eine solche Ordnung implementiert haben, dass <code>Rectangle</code>-Objekte also sortierbar sind, weil sie (auch) vom Typ <code>Comparable</code> sind. F\u00fcr alle Objekte, die in Java existieren, wissen wir, dass sie sortierbar sind, sobald sie auch vom Typ <code>Comparable</code> sind. <code>Comparable</code> stellt also eine Schnittstelle zur Sortierbarkeit dar. Wenn wir eine eigene Klasse schreiben und wir eine Ordnung \u00fcber die Objekte dieser Klasse definieren k\u00f6nnen, sollten wir das Interface <code>Comparable</code> implementieren, denn dadurch geben wir nach \"au\u00dfen\" an, dass sich die Objekte der Klasse sortieren (ordnen) lassen.</p>"},{"location":"interfaces/#zwischenfazit","title":"Zwischenfazit","text":"<p>Wir haben nun schon mehrere Methoden kennengelernt, die wir f\u00fcr eigene Klassen implementieren sollten.</p> <ul> <li>Die <code>toString()</code>-Methode erben wir von <code>Objects</code>. Wir sollten <code>toString()</code> f\u00fcr \"unsere\" Klassen \u00fcberschreiben, damit wir eine textuelle Repr\u00e4sentation unserer Objekte haben. <code>toString()</code>wird implizit angewendet, sobald eine <code>String</code>-Repr\u00e4sentation erforderlich ist, z.B. ist <code>System.out.println(refVariable);</code>das Gleiche wie <code>System.out.println(refVariable.toString());</code>. </li> <li>Die <code>equals()</code>-Methode erben wir ebenfalls von <code>Objects</code>. Wir sollten <code>equals()</code> f\u00fcr \"unsere\" Klassen implementieren, um zu definieren, wann Objekte \"unserer\" Klasse gleich sind. Hierbei ist wichtig, zu beachten, dass <code>refVar1 == refVar2</code> ein reiner Referenzvergleich ist, der nichts dar\u00fcber aussagt, ob die Objekte gleich  sind, sondern nur ein <code>true</code> ergibt, wenn beide Variablen auf dasselbe Objekt zeigen. Die Gleichheit von Objekten wird mittels <code>equals()</code>-Methode definiert. </li> <li>Die <code>hashCode()</code>-Methode erben wir ebenfalls von <code>Objects</code>. Wir sollten <code>hashCode()</code>genau dann implementieren, wenn wir <code>equals()</code> implementieren. Wichtig ist, dass zwei Objekte den gleichen Hash-Code haben (<code>hashCode()</code> liefert den gleichen <code>int</code>-Wert zur\u00fcck), wenn die beiden Objekte laut <code>equals()</code> gleich sind. Gut ist dar\u00fcber hinaus (aber nicht Bedingung), dass zwei Objekte einen unterschiedlichen Hash-Code haben, wenn sie laut <code>equals()</code>-Methode nicht gleich sind (<code>equals()</code>liefert <code>false</code> zur\u00fcck). Der Hash-Code wird bei Hash-basierten Datentypen, wie z.B. Collections verwendet, um diese einzusortieren. </li> <li>Die Methode <code>compareTo()</code> muss implementiert werden, wenn wir das Interface <code>Comparable</code> implementieren. Mithilfe von <code>compareTo()</code> legen wir eine Ordnung \u00fcber die Objekte der Klasse fest, d.h. wir geben an, wann ein Objekt gr\u00f6\u00dfer/kleiner/gleich einem anderen Objekt der gleichen Klasse ist. Dadurch, dass wir das <code>Comparable</code>-Interface implementieren, zeigen wir nach \"au\u00dfen\", dass die Objekte unserer Klasse sortierbar  sind. </li> </ul>"},{"location":"interfaces/#eine-bessere-implementierung","title":"Eine bessere Implementierung","text":"<p>Wir haben bereits bei der Implementierung der Klasse <code>Rectangle</code> gesehen, dass wir das Interface <code>Comparable</code> bei der Implementierung von <code>Rectangle</code> typisieren sollten. Das w\u00e4re f\u00fcr eine wirklich korrekte Implementierung der Methode <code>sortieren()</code> ebenfalls angebracht. Dann w\u00fcrden wir in dieser Methode <code>Comparable</code> mit <code>Rectangle</code> typisieren:</p> <pre><code>    public static void sortieren(Comparable&lt;Rectangle&gt;[] unsorted)\n    {   \n        for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n        {\n            for(int index=0; index&lt;unsorted.length-bubble; index++)\n            {\n                if(unsorted[index].compareTo((Rectangle) unsorted[index+1]) &gt; 0) \n                {\n                    Comparable&lt;Rectangle&gt; tmp = unsorted[index];\n                    unsorted[index] = unsorted[index+1];\n                    unsorted[index+1] = tmp;            \n                }\n            }\n        }\n    }\n</code></pre> <p>Wenn wir also den Typ <code>Comparable</code> verwenden, dann erg\u00e4nzen wir ihn um die Typisierung <code>&lt;Rectangle&gt;</code> (Zeilen <code>1</code> und <code>9</code>). Das f\u00fchrt allerdings dazu, dass wir dann auch in Zeile <code>7</code> den Typ von <code>unsorted[index+1]</code> nach <code>Rectangle</code> konvertieren m\u00fcssen (<code>(Rectangle) unsorted[index+1]</code>). Damit verlieren wir aber unsere allgemeine Anwendbarkeit der Methode <code>sortieren()</code> f\u00fcr alle Klassen, die <code>Comparable</code> implementiert haben. Insbesondere w\u00fcrde die Methode dann nicht mehr f\u00fcr z.B. die Klasse <code>Circle</code> anwendbar sein: </p> <pre><code>public class Circle extends Shape implements Comparable&lt;Circle&gt;\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    @Override\n    public int compareTo(Circle o) {\n        if(this.radius &gt; o.radius) return 1;\n        else if(this.radius &lt; o.radius) return -1;\n        else return 0; // this.radius == o.radius\n    }\n\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <p>Wenn wir nun versuchen w\u00fcrden, die <code>sortieren()</code>-Methode auf ein <code>Circle[]</code> anzuwenden, lie\u00dfe sich das Programm gar nicht compilieren:</p> <pre><code>    public static void main(String[] args) \n    {\n        Circle[] circArr = new Circle[6];\n        circArr[0] = new Circle(5.0);\n        circArr[1] = new Circle(5.5);\n        circArr[2] = new Circle(4.0);\n        circArr[3] = new Circle(2.5);\n        circArr[4] = new Circle(7.0);\n        circArr[5] = new Circle(1.0);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        // sortieren(circArr);      // Fehler\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n    }\n</code></pre> <p>Deshalb w\u00e4re es eine bessere Implementierung, wenn wir das Interface <code>Comparable</code> nicht in den konkreten Klassen <code>Rectangle</code> und <code>Circle</code> (und in jeder weiteren Klasse, die wir auf der Basis von <code>Shape</code> erstellen) implementieren, sondern gleich in der Abstrakten Klasse <code>Shape</code>:</p> <pre><code>public abstract class Shape implements Comparable&lt;Shape&gt;\n{\n\n    public abstract double perimeter();\n    public abstract double area();\n\n}\n</code></pre> <p>Da <code>Shape</code> eine abstrakte Klasse ist, muss die Methode <code>compareTo()</code> nicht in <code>Shape</code> implementiert werden. Diese Methode w\u00fcrde nun <code>abstract</code> an alle Klassen vererbt, die von <code>Shape</code> erben:</p> Rectangle.javaCircle.java <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Shape o) \n    {\n        Rectangle r = (Rectangle)o;\n        int diff = (this.height+this.width) - (r.height+r.width);\n        return diff;\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <pre><code>public class Circle extends Shape\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    @Override\n    public int compareTo(Shape o) \n    {\n        Circle c = (Circle)o;\n        if(this.radius &gt; c.radius) return 1;\n        else if(this.radius &lt; c.radius) return -1;\n        else return 0;  // this.radius == c.radius\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <p>Beachten Sie, dass die Klassen <code>Rectangle</code> und <code>Circle</code> jetzt nur noch von <code>Shape</code> erben, aber nicht mehr das Interface <code>Comparable</code> implementieren (jeweils Zeile <code>1</code>). Es darf nicht mehrmals von einer Klasse implementiert werden und <code>Shape</code> implementiert es ja bereits. </p> <p>Da <code>Shape</code> diese Interface aber implementiert, wird die Methode <code>compareTo()</code> als abstrakte Methode an die Klassen <code>Rectangle</code> und <code>Circle</code> vererbt. Die Methode muss also von diesen Klassen implementiert werden. Nun wird sie aber mit dem Parametertyp <code>Shape</code> vererbt (Zeile <code>24</code> in <code>Rectangle.java</code> bzw. <code>23</code> in <code>Circle.java</code>). Dieser Parameter muss deshalb zun\u00e4chst innerhalb der Methode <code>compareTo()</code> konvertiert werden (Zeile <code>25</code> in <code>Circle.java</code> bzw. <code>26</code> in <code>Rectangle.java</code>). </p> <p>Die allgemeine Anwendung der Methode <code>sortieren()</code> in der Testklasse gelingt nun aber:</p> TestklasseShape.java <pre><code>public class TestklasseShape \n{\n\n    public static void sortieren(Comparable&lt;Shape&gt;[] unsorted)\n    {   \n        for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n        {\n            for(int index=0; index&lt;unsorted.length-bubble; index++)\n            {\n                if(unsorted[index].compareTo((Shape) unsorted[index+1]) &gt; 0) \n                {\n                    Comparable&lt;Shape&gt; tmp = unsorted[index];\n                    unsorted[index] = unsorted[index+1];\n                    unsorted[index+1] = tmp;            \n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) \n    {\n        Rectangle[] rectArr = new Rectangle[6];\n        rectArr[0] = new Rectangle(9, 13);\n        rectArr[1] = new Rectangle(4, 17);\n        rectArr[2] = new Rectangle(12, 5);\n        rectArr[3] = new Rectangle(8, 9);\n        rectArr[4] = new Rectangle(10, 11);\n        rectArr[5] = new Rectangle(5, 15);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        sortieren(rectArr);\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n\n        Circle[] circArr = new Circle[6];\n        circArr[0] = new Circle(5.0);\n        circArr[1] = new Circle(5.5);\n        circArr[2] = new Circle(4.0);\n        circArr[3] = new Circle(2.5);\n        circArr[4] = new Circle(7.0);\n        circArr[5] = new Circle(1.0);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        sortieren(circArr);\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n    }\n}\n</code></pre> <p>Wir k\u00f6nnen nun alle Objekte sortieren lassen, die auf der Klasse <code>Shape</code> basieren. </p> <pre><code>------------------------ unsortiert --------------------------\n\n[  9 x 13 = 117,00 ] \n[  4 x 17 =  68,00 ] \n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[ 10 x 11 = 110,00 ] \n[  5 x 15 =  75,00 ] \n\n\n------------------------- sortiert ---------------------------\n\n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[  5 x 15 =  75,00 ] \n[  4 x 17 =  68,00 ] \n[ 10 x 11 = 110,00 ] \n[  9 x 13 = 117,00 ] \n\n\n------------------------ unsortiert --------------------------\n\n(radius: 5,00 -&gt; area:  78,54 ] \n(radius: 5,50 -&gt; area:  95,03 ] \n(radius: 4,00 -&gt; area:  50,27 ] \n(radius: 2,50 -&gt; area:  19,63 ] \n(radius: 7,00 -&gt; area: 153,94 ] \n(radius: 1,00 -&gt; area:   3,14 ] \n\n\n------------------------- sortiert ---------------------------\n\n(radius: 1,00 -&gt; area:   3,14 ] \n(radius: 2,50 -&gt; area:  19,63 ] \n(radius: 4,00 -&gt; area:  50,27 ] \n(radius: 5,00 -&gt; area:  78,54 ] \n(radius: 5,50 -&gt; area:  95,03 ] \n(radius: 7,00 -&gt; area: 153,94 ] \n</code></pre>"},{"location":"interfaces/#eine-noch-bessere-implementierung","title":"Eine noch bessere Implementierung","text":"<p>Obwohl wir nun in <code>Shape</code> das Interface <code>Comparable</code> implementieren, geben wir die Verantwortung der Implementierung der Methode <code>compareTo()</code> an die konkreten Klassen <code>Rectangle</code> und <code>Circle</code> weiter. Es stellt sich die Frage, ob sich die <code>compareTo()</code>-Methode nicht bereits in <code>Shape</code> implementieren lie\u00dfe. Die Antwort auf diese Frage sollte ja lauten, denn ansonsten sollten wir das Interface gar nicht bereits durch die abstrakte Klasse <code>Shape</code> implementieren lassen. Wir haben in <code>Shape</code> gen\u00fcgend Informationen, um die <code>compareTo()</code>-Methode zu implementieren. Wir k\u00f6nnen daf\u00fcr entweder <code>perimeter()</code> oder <code>area()</code> verwenden. Wir entscheiden uns f\u00fcr die Verwendung von <code>area()</code>:</p> Shape.java <pre><code>public abstract class Shape implements Comparable&lt;Shape&gt;\n{\n\n    public abstract double perimeter();\n    public abstract double area();\n\n    @Override\n    public int compareTo(Shape o) \n    {   \n        return (this.area() - o.area());\n    }\n\n}\n</code></pre> <p>In abstrakten Klassen m\u00fcssen nicht, im Gegensatz zu Interfaces, alle Methoden abstrakt sein. Es k\u00f6nnen auch Methoden bereits implementiert werden. Diese Methoden m\u00fcssen dann nicht mehr in den Klassen implementiert werden, die von der abstrakten Klasse erben. Die Klassen <code>Rectangle</code> und <code>Circle</code> ben\u00f6tigen also keine eigene Implementierung der <code>compareTo()</code>-Methode mehr:</p> Rectangle.javaCircle.java <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <pre><code>public class Circle extends Shape\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <p>Wir haben ausgenutzt, dass in der Klasse <code>Shape</code> bereits gen\u00fcgend Informationen vorliegen, um die Methode <code>compareTo()</code> korrekt f\u00fcr alle Klassen zu implementieren, die von <code>Shape</code> erben. Diese Methode muss dann von diesen konkreten Klassen nicht mehr implementiert werden. Wir vermeiden so doppelten Code. Die <code>testklasseShape</code> bleibt unver\u00e4ndert f\u00fcr alle abgeleiteten Klassen aus <code>Shape</code> anwendbar. </p>"},{"location":"interfaces/#functional-interfaces","title":"Functional Interfaces","text":"<p>Zusammenfassung Interfaces: In Interfaces k\u00f6nnen wir definieren:</p> <ul> <li>Konstanten (Variablen, denen nur einmal ein Wert zugewiesen werden kann - globale Variablen in Interfaces sind automatisch deklariert als <code>public static final</code>),</li> <li>abstrakte Methoden (Methoden, die nicht impementiert sind, d.h. keinen Methodenk\u00f6rper haben),</li> <li>statische Methoden (implementierte Methoden als <code>static</code> deklariert),</li> <li>sogenannte <code>default</code>-Methoden (implementierte Methoden, die mithilfe des Schl\u00fcsselwortes <code>default</code> deklariert werden)</li> </ul> <p>Wir betrachten ein Beispiel <code>Printable</code>:</p> Interface Printable.java <pre><code>public interface Printable\n{\n    void print(String s);\n\n    default void print()\n    {\n        print(\"default\");\n    }\n}\n</code></pre> <p>Es enth\u00e4lt eine abstrakte Methode und eine <code>default</code>-Methode (nur, um eine solche einmal zu zeigen). Wichtig ist, dass dieses Interface genau eine abstrakte Methode enth\u00e4lt. Prinzipiell ist es guter Stil, dass ein Interface m\u00f6glichst wenig abstrakte Methoden enth\u00e4lt, denn sobal eine Klasse ein Interface implementiert, muss diese Klasse ja alle abstrakten Methoden des Interfaces implementieren. F\u00fcr mehrer abstrakte Methoden ist es meist besser, diese auf mehrere Interfaces aufzuteilen, dann m\u00fcssen nicht eventuell unn\u00f6tige Methoden implementiert werden. </p> <p>Es kommt deshalb h\u00e4ufig vor, dass ein Interface genau eine abstrakte Methode enth\u00e4lt. In einem solchen Fall sprechen wir von sogenannten Functional Interfaces.</p> <p>Ein Functional Interface enth\u00e4lt genau eine abstrakte Methode.</p> <p>Functional Interfaces sind sehr sinnvoll und kommen h\u00e4ufig vor. Um sicherzustellen, dass es sich wirklich um ein Functional Interface handelt, verwenden wir die Annotation <code>@FunctionalInterface</code>. Dadurch wird es nicht m\u00f6glich, eine weitere abstrakte Methode hinzuzuf\u00fcgen:</p> Functional Interface Printable.java <pre><code>@FunctionalInterface\npublic interface Printable\n{\n    void print(String s);\n\n    default void print()\n    {\n        print(\"default\");\n    }\n}\n</code></pre> <p>Typische Vertreter von Functional Interfaces in Java sind Comparable, Predicate, Consumer, Supplier und Function. Das erstgenannte haben wir bereits kennengelernt. Mit den letzten vier besch\u00e4ftigen wir uns im folgenden Kapitel, in dem es um Lambda-Ausdr\u00fccke geht. </p>"},{"location":"junit/","title":"JUnit-Tests","text":"<p>Testen von Programmen ist wichtig. Ohne Testen ist es kaum m\u00f6glich, Fehler in Programmen zu entdecken. Bis jetzt haben wir unsere Programme immer durch reines Anwenden getestet, d.h. wir haben die implementierten Methoden aufgerufen und ihnen unterschiedliche Parameterwerte \u00fcbergeben. Wir werden das jetzt \u00e4ndern und nutzen daf\u00fcr JUnit.</p>"},{"location":"junit/#allgemeines-zum-unit-testen","title":"Allgemeines zum (Unit-)Testen","text":"<p>Der ber\u00fchmte Informatiker Edsger W. Dijkstra hat \u00fcber das Testen gesagt:</p> <p>Durch Testen kann man stets nur die Anwesenheit, nie aber die Abwesenheit von Fehlern beweisen</p> <p>Das bedeutet, wir k\u00f6nnen durch das Testen Fehler finden. Wenn wir aber keine finden, dann wissen wir nicht, ob das Programm dann auch keine Fehler mehr enth\u00e4lt. Es ist leider nicht m\u00f6glich, grunds\u00e4tzlich die Fehlerfreiheit von Programmen zu pr\u00fcfen. Aber das Testen stellt ein wichtiges Werkzeug dar, um Fehler zu entdecken. </p> <p>Es gibt verschiedene Arten von Tests:</p> <p></p> <p>In der Abbildung erkennen wir, dass die Unit-Tests, die wir hier kennenlernen wollen, am besten automatisierbar, am h\u00e4ufigsten und am einfachsten sind. Mit Unit-Tests k\u00f6nnen wir Methoden und Klassen testen, wobei wir die Tests implementieren. Die Idee ist, dass wir funktionale Einzelteile eines Programms separat und isoliert vom Rest auf ihre Korrektheit hin \u00fcberpr\u00fcfen. Wir versuchen extra, so wenig wie m\u00f6glich die Effekte anderer Funktionalit\u00e4ten bzw. Komponenten in die Tests einflie\u00dfen zu lassen. Das erfolgt dann in den Komponenten- bzw. Integrationstests. Das hat zwei Vorteile: einerseits ist der zu pr\u00fcfende Funktionsumfang \u00fcberschaubar und andererseits k\u00f6nnen diese Unit-Tests leicht automatisiert ausgef\u00fchrt werden. Es gibt, wie bereits eingangs erw\u00e4hnt, keine Garantie von Fehlerfreiheit. Ein Nachteil der Unit-Tests besteht darin, dass sie schwierig f\u00fcr Methoden zu gestalten sind, in denen es Abh\u00e4ngigkeiten von der Laufzeitumgebung oder anderen Komponenten gibt.    </p>"},{"location":"junit/#junit","title":"JUnit","text":"<p>F\u00fcr das Unit-Testen von Java-Programmen gibt es das Werkzeug JUnit. Wir zeigen die Verwendung von JUnit an einem einf\u00fchrenden Beispiel. Angenommen, wir haben folgende kleine Javaklasse <code>Fakultaet</code>:</p> <pre><code>public class Fakultaet {\n\n    public long fakultaet(int number) throws IllegalArgumentException\n    {\n        if(number &lt; 1) \n        {\n            throw new IllegalArgumentException(\"Zahl muss groesser gleich 1 sein!\");\n        }\n        long result = 1;\n        for(int i = 2; i &lt;= number; i++) \n        {\n            long tmp = result;\n            result *= i;\n            if(tmp &gt; result)\n            {\n                throw new IllegalArgumentException(\"Overflow!\");\n            }\n        }\n        return result;\n    }\n\n    public void print(int number)\n    {\n        System.out.printf(\"%3d! = %,d %n\", number, fakultaet(number));\n    }\n\n}\n</code></pre> <p>Diese Klasse enth\u00e4lt eine Methode <code>fakultaet()</code>, welche ein <code>int</code> als Eingabeparameter erwartet und den Wert der Fakult\u00e4tsberechnung als <code>long</code> zur\u00fcckgibt. Ist der Eingabewert kleiner als <code>1</code> wird eine <code>IllegalArgumentException</code> geworfen. Tritt w\u00e4hrend der Berechnung der Fakult\u00e4t ein Wertebereichs\u00fcberlauf auf (der gr\u00f6\u00dfte Wert in <code>long</code> ist <code>9,223,372,036,854,775,807</code>), dann wird ebenfalls eine <code>IllegalArgumentException</code> geworfen. Die <code>print()</code>-Methode gibt die Berechnung geeignet aus. Angenommen, eine <code>main()</code>-Methode (oder eine andere) w\u00fcrde die Klasse in der folgenden Form verwenden:</p> <pre><code>public static void main(String[] args) \n{\n    Fakultaet f1 = new Fakultaet();\n    int nr = 0;\n    while(nr &lt; 22)\n    {\n        try {\n            f1.print(nr);\n        }\n        catch(IllegalArgumentException e) {\n            System.out.println(\"number = \" + nr + \" : \" + e.getMessage());\n        }\n        nr++;\n    }\n}\n</code></pre> <p>, dann w\u00e4re die Ausgabe: </p> <pre><code>number = 0 : Zahl muss gr\u00f6\u00dfer gleich 1 sein!\n  1! = 1 \n  2! = 2 \n  3! = 6 \n  4! = 24 \n  5! = 120 \n  6! = 720 \n  7! = 5.040 \n  8! = 40.320 \n  9! = 362.880 \n 10! = 3.628.800 \n 11! = 39.916.800 \n 12! = 479.001.600 \n 13! = 6.227.020.800 \n 14! = 87.178.291.200 \n 15! = 1.307.674.368.000 \n 16! = 20.922.789.888.000 \n 17! = 355.687.428.096.000 \n 18! = 6.402.373.705.728.000 \n 19! = 121.645.100.408.832.000 \n 20! = 2.432.902.008.176.640.000 \nnumber = 21 : Overflow!\n</code></pre>"},{"location":"junit/#intellij","title":"IntelliJ","text":"<p>Klicken Sie im Editor in der Klasse <code>Fakultaet</code> auf den Klassennamen <code>Fakultaet</code>, w\u00e4hlen die Tastenkombination Option+Enter (Windows/Linux Alt+Enter) und w\u00e4hlen <code>Create Test</code>. Es erscheint ein Dialog:</p> <p></p> <p>Als <code>Testing library</code> w\u00e4hlen wir <code>JUnit5</code>. Sollten Sie diese noch nicht haben, wird sie zum Download angeboten und mithilfe von <code>Fix</code> k\u00f6nnen Sie diese herunterladen. Den vorgeschlagenen Namen <code>FakulatetTest</code> f\u00fcr die Testklasse akzeptieren wir und klicken unter Member alle Methoden an, f\u00fcr die wir Tests schreiben wollen (beide, sowohl <code>fakultaet()</code> als auch <code>print()</code>). </p> <p>Sie m\u00fcssen eventuell noch einmalig die <code>junit</code>-Bibliothek zum Klassenpfad hinzuf\u00fcgen. Dann wird eine Klasse <code>FakultaetTest</code> erzeugt:</p> <pre><code>package vorbereitungen.testen;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass FakultaetTest\n{\n\n    @Test\n    void fakultaet()\n    {\n    }\n\n    @Test\n    void print()\n    {\n    }\n}\n</code></pre> <p>Sie k\u00f6nnen die Klasse <code>FakultaetTest</code> auch wie gewohnt per <code>New -&gt; Java Class</code> erstellen. </p>"},{"location":"junit/#eclipse","title":"Eclipse","text":"<p>Wir wollen diese Klasse <code>Fakultaet</code> nun mithilfe von <code>JUnit</code> testen. Dazu w\u00e4hlen wir <code>File --&gt; New --&gt; JUnit Test Case</code>:</p> <p></p> <p>Es erscheint folgender Dialog:</p> <p></p> <p>Beachten Sie, dass unter <code>Class under test:</code> die Klasse <code>Fakultaet</code> eingetragen ist (oder Sie geben Sie dort ein). Der Name der Klasse wird mit <code>FakultaetTest</code> vorgeschlagen. Beachten Sie auch, dass bei den RadioButtons oben <code>New JUnit Jupiter test</code> ausgew\u00e4hlt ist. Klicken Sie auf <code>Finish</code>. </p> <p>Es entsteht folgende <code>FakultaetTest</code>-Klasse:</p> <pre><code>import static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass FakultaetTest {\n\n    @Test\n    void test() {\n        fail(\"Not yet implemented\");\n    }\n\n}\n</code></pre> <p>Sollte es bei Ihnen Probleme bei der Erstellung der JUnit-Testklasse geben, dann beachten Sie folgende 2 Anforderungen:</p> <ol> <li> <p>Im <code>Java Build Path</code> muss <code>JUnit</code> enthalten sein:</p> <p></p> <p>Hilfestellungen dazu finden Sie z.B. hier, hier oder hier. Beachten Sie, dass wir nicht <code>JUnit 4</code>, sondern <code>JUnit 5 (JUnit Jupiter)</code> verwenden! </p> </li> <li> <p>In der <code>module-info.java</code> muss <code>requires org.junit.jupiter.api;</code> eingetragen sein. </p> </li> </ol>"},{"location":"junit/#tests-implementieren","title":"Tests implementieren","text":"<p>Eine JUnit-Testklasse enth\u00e4lt keine <code>main()</code>-Methode, ist aber ausf\u00fchrbar. Sie enth\u00e4lt stattdessen Methoden, die mit <code>@Test</code> annotiert sind. Diese <code>@Test</code>-Methoden enthalten Zusicherungen (sogenannte Assertions). Mit diesen Assertions geben Sie das erwartete Ergebnis des Testfalls an. </p>"},{"location":"junit/#assertions","title":"Assertions","text":"<p>Es gibt unterschiedliche M\u00f6glichkeiten, das tats\u00e4chliche Ergebnis der Ausf\u00fchrung mit dem erwarteten Ergebnis zu vergleichen:</p> <ul> <li>Gleichheit, Ungleichheit, kleiner, gr\u00f6\u00dfer</li> <li><code>null</code>, nicht <code>null</code></li> <li>gleiche Objekte (<code>equals()</code>)</li> </ul> <p>Diese Vergleiche werden mittels Assertions durchgef\u00fchrt. Folgende Tabelle gibt einen \u00dcberblick \u00fcber einige der am meisten verwendeten Assertions an. Alle Assertions, die es gibt, finden Sie hier.</p> Assertion Beschreibung <code>fail(message)</code> L\u00e4sst den Test scheitern (fail) mit Nachricht <code>message</code>. Wird genutzt, um zu \u00fcberpr\u00fcfen, ob Code unerreichbar ist oder bevor der Test implementiert ist. <code>assertTrue(cond,m)</code> \u00dcberpr\u00fcft, ob Bedingung <code>cond</code> wahr ist oder scheitert mit Nachricht <code>m</code> <code>assertFalse(cond,m)</code> \u00dcberpr\u00fcft, ob Bedingung <code>cond</code> false ist oder scheitert mit Nachricht <code>m</code> <code>assertEquals(a,b,m)</code> \u00dcberpr\u00fcft, ob Parameter <code>a</code> und <code>b</code> gleich sind oder scheitert mit Nachricht <code>m</code> <code>assertArrayEquals(a,b,m)</code> \u00dcberpr\u00fcft, ob Inhalte der Arrays <code>a</code> und <code>b</code> gleich sind oder scheitert mit Nachricht <code>m</code> <code>assertNull(o,m)</code> \u00dcberpr\u00fcft, ob Object <code>o==null</code> ist oder scheitert mit Nachricht <code>m</code> <code>assertNotNull(o,m)</code> \u00dcberpr\u00fcft, ob Object <code>o!=null</code> ist oder scheitert mit Nachricht <code>m</code> <code>assertSame(o1,o2,m)</code> \u00dcberpr\u00fcft, ob Objektreferenz <code>o1==o2</code> ist oder scheitert mit Nachricht <code>m</code> <code>assertNotSame(o1,o2,m)</code> \u00dcberpr\u00fcft, ob Objektreferenz <code>o1!=o2</code> ist oder scheitert mit Nachricht <code>m</code> <p>Derzeit verwenden wir in unserer Testklasse nur die Assertion <code>fail()</code>. Diese steht aber nur daf\u00fcr, dass wir diesen Test noch implementieren m\u00fcssen. Das machen wir gleich.</p>"},{"location":"junit/#annotationen","title":"Annotationen","text":"<p>Neben den Assertions gibt es auch noch Annotationen, die beim Testen eine Rolle spielen. Eine Annotation haben wir bereits verwendet: <code>@Test</code>. Hier einen \u00dcberblick \u00fcber die h\u00e4ufigsten Annotationen:</p> Annotation  Beschreibung                   @Test                  public void method()                               Die Methode ist eine Testmethode                               @BeforeEach                  public void method()                               Die Methode wird vor jedem Test ausgef\u00fchrt                               @AfterEach                  public void method()                               Die Methode wird nach jedem Test ausgef\u00fchrt                               @BeforeAll                  public static void method()                               Die Methode wird einmalig ausgef\u00fchrt bevor die Tests starten (static!)                               @AfterAll                  public static void method()                               Die Methode wird einmalig ausgef\u00fchrt nachdem die Tests gelaufen sind"},{"location":"junit/#methode-fakultaet-testen","title":"Methode <code>fakultaet()</code> testen","text":"<p>Wir schreiben unsere erste Testmethode und wollen darin die Methode <code>fakultaet()</code> testen:</p> <pre><code>import static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass FakultaetTest {\n\n    @Test\n    void testFakultaet6() \n    {\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        long result = f.fakultaet(6);\n\n        // then\n        assertEquals(720, result, \"6! should be 720\");\n    }\n\n}\n</code></pre> <p>Wir haben dazu die Testmethode umbenant in <code>testFakultaet6()</code>, da wir f\u00fcr die Eingabe <code>6</code> die korrekte Ausf\u00fchrung testen wollen. Wir gehen nach dem <code>given-when-then</code>-Prinzip vor und haben es hier mithilfe von Zeilenkommentaren betont. Wir erzeugen zun\u00e4chst ein <code>Fakultaet</code>-Objekt und wenden dann die <code>fakultaet()</code>-Methode f\u00fcr den Eingabeparameter <code>6</code> an. Das Ergebnis speichern wir in <code>result</code>. Nun kommt unsere erste Assertion zum Einsatz. Wir verwenden die Assertion <code>assertEquals</code>. Diese erwartet mindestens zwei Parameter. Der erste Parameter gibt das erwartete Resultat an (<code>720</code>) und der zweite Parameter ist der berechnete Wert (<code>result</code>). Der dritte Parameter ist optional und steht f\u00fcr die Zeichenkette, die ausgegeben wird, falls der berechnete Wert nicht dem erwarteteten Wert entspricht. </p> <p>Wir h\u00e4tten hier auch die Assertion <code>assertTrue(720==result, \"6! should be 720\")</code> verwenden k\u00f6nnen. </p>"},{"location":"junit/#test-ausfuhren","title":"Test ausf\u00fchren","text":""},{"location":"junit/#intellij_1","title":"IntelliJ","text":"<p>Zur Ausf\u00fchrung der Testklasse w\u00e4hlen wir <code>Run FakultaetTest with Coverage</code>.</p> <p></p> <p>Im unteren Teil von IntelliJ finden wir die Ausgabe \u00fcber den erfolgreichen Test:</p> <p></p> <p>Wenn wir uns nun die Klasse <code>Fakulatet</code> anschauen, dann sehen wir am linekn Rand die Farben Rot, Gr\u00fcn, gelb in den einzelnen Zeilen. </p> <p></p> <p>Gr\u00fcn zeigt an, dass diese Zeile im Test ausgef\u00fchrt wurde und Rot nicht. Gelb haben wir typischerweise an Bedingungen und zeigt an, dass nur ein m\u00f6gliches Ergebnis (<code>true</code> oder <code>false</code>) ausgewertet wurde. Ziel ist es, eine 100%ige testabdeckung zu erreichen (alle Code-Zeilen sollen gr\u00fcn sein). Die Prozentangaben der Abdeckung sehen Sie auch in dem Fenster neben dem Editor. </p> <p></p> <p>Nur, um mal zu zeigen, wie ein Test aussieht, der fehlschl\u00e4gt, geben wir einfach an, dass <code>721</code> das erwartete Resultat sein soll:</p> <pre><code>assertEquals(721, result, \"6! should be 720\");  // 721 ist natuerlich falsch - nur zum zeigen\n</code></pre> <p>Dann sieht das Resultat so aus:</p> <p></p>"},{"location":"junit/#eclipse_1","title":"Eclipse","text":"<p>Unter <code>Run</code> w\u00e4hlen Sie nun <code>Coverage</code> (<code>Strg-Umschalt-F11</code>). Die Ansicht von Eclipse wechselt. Sie k\u00f6nnen unter <code>Run</code> auch <code>Coverage As --&gt; JUnit Test</code> w\u00e4hlen. Das ist gleich. Auf der linken Seite in Eclipse erscheint ein gr\u00fcner Balken als Zeichen daf\u00fcr, dass alle Tests (derzeit nur einer) erfolgreich durchlaufen wurden. Darunter sind die Tests aufgef\u00fchrt mit einem kleinen gr\u00fcnen Check am Icon. Der Test war erfolgreich. </p> <p>Wenn wir uns nun unsere <code>Fakultaet</code>-Klasse anschauen, dann sehen wir folgendes Bild:</p> <p></p> <p>Hier wird die Testabdeckung angezeigt. Die gr\u00fcn markierten Zeilen wurden durch den Test ausgef\u00fchrt. Die gelb markierten Zeilen sind Bedingungen, die <code>false</code> ergaben und f\u00fcr die es (noch) keinen Test gibt, der <code>true</code> f\u00fcr diese Bedingungen ergibt. Die roten Zeilen wurden in noch keinem Test ausgef\u00fchrt. Wir erstellen deshalb weitere Tests, um eine vollst\u00e4ndige Testabdeckung zu erzielen. </p>"},{"location":"junit/#exceptions-testen","title":"Exceptions testen","text":"<p>Um das Werfen einer Exception zu testen, bietet sich die Assertion <code>assertThrows()</code> an (siehe hier. Diese Assertion  erwartet als ersten Parameter die erwartete <code>Exception</code>, in unserem Fall also <code>IllegalArgumentException</code>. Beachten Sie, dass der Typ <code>Class</code> (siehe hier) erwartet wird. Diesen erhalten wir, indem wir <code>.class</code> an den Klasennamen (also hier <code>IllegalArgumentException</code> anh\u00e4ngen). Der Unterschied zwischen <code>.class</code> und <code>.getClass()</code> ist der, dass bei <code>getClass()</code> bereits ein Objekt der Klasse existieren muss (wird auf ein Objekt der Klasse angewendet), w\u00e4hrend <code>.class</code> auf die Klasse angewendet werden kann, ohne dass ein Objekt der Klasse existieren muss. </p> <p>Der zweite Parameter der <code>assertThrows</code>-Methode erwartet ein <code>Executable</code> (siehe hier). Dies ist ein Interface mit genau einer Methode, n\u00e4mlich <code>execute()</code>. Es ist \u00fcblich, dieses <code>Excutable</code> in der Schreibweise der funktionalen Programmierung (sie z.B. hier) zu definieren. Die Testmethode, um Eingabeparameter kleiner <code>1</code> zu testen, k\u00f6nnte z.B. so aussehen:</p> <pre><code>    @Test\n    void testFakultaetSmallerThan1() \n    {\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt;\n        f.fakultaet(0));\n\n        // then\n        assertEquals(\"Zahl muss groesser gleich 1 sein!\", exception.getMessage());\n    }\n</code></pre> <p>Nach dem gleichen Prinzip k\u00f6nnen wir auch den Wertebereichs\u00fcberlauf testen:</p> <pre><code>    @Test\n    void testFakultaetOverflow() \n    {\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt;\n        f.fakultaet(22));\n\n        // then\n        assertEquals(\"Overflow!\", exception.getMessage());\n    }\n</code></pre> <p>Betrachten wir die Testabdeckung der Klasse <code>Fakultaet</code>, dann ist diese bereits sehr gut. Die Methode <code>fakulataet()</code> hat eine 100%ige Testabdeckung. Nur die Methode <code>print()</code> fehlt noch. </p>"},{"location":"junit/#intellij_2","title":"IntelliJ","text":""},{"location":"junit/#eclipse_2","title":"Eclipse","text":""},{"location":"junit/#konsolenausgaben-testen","title":"Konsolenausgaben testen","text":"<p>Es ist nicht \u00fcblich, Konsolenausgaben zu testen. Normalerweise werden die Ausgebestrings mit der <code>toString()</code>-Methode erzeugt und diese Methode wird dann auch getestet (z.B. mittels <code>assertEquals()</code>). Wir haben hier aber keine <code>toString()</code>-Methode und zeigen deshalb, wie die <code>print()</code>-Methode getestet werden k\u00f6nnte. Dazu wird die Standardausgabe \"verbogen\". Wir merken uns, den urspr\u00fcnglichen <code>System.out</code>-Stream, der ein <code>PrintStream</code> aus dem Paket <code>java.io</code> ist. Dann erzeugen wir einen eigenen <code>ByteArrayOutputStream</code> (ebenfalls aus <code>java.io</code>). Nachdem wir unsere Ausgabe abgeschlossen haben, setzen wir <code>System.out</code> wieder auf das urspr\u00fcngliche Ausgabeger\u00e4t, damit die Konsolenausgaben wieder erfolgen k\u00f6nnen. Unsere Testmethode f\u00fcr die <code>print()</code>-Methode k\u00f6nnte dann so aussehen:</p> <pre><code>    @Test\n    void testFakultaetPrint6() \n    {\n        PrintStream originalOut = System.out;       // System.out merken (Standardausgabegeraet Konsole)\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        System.setOut(new PrintStream(out));\n        // given\n        Fakultaet f = new Fakultaet();\n\n        // when\n        f.print(6);\n\n        // then\n        assertEquals(\"  6! = 720 \\n\", out.toString(), \"should print 6! = 720 with linebreak\");\n        System.setOut(originalOut);                 // System.out wieder auf das Standardausgabegeraet setzen\n    }\n</code></pre> <p>Beachten Sie sowohl die Leerzeichen im Ausgabestring als auch den Zeilenumbruch. Nun haben wir eine vollst\u00e4ndige Testabdeckung unserer <code>Fakultaet</code>-Klasse:</p>"},{"location":"junit/#intellij_3","title":"IntelliJ","text":""},{"location":"junit/#eclipse_3","title":"Eclipse","text":"<p>Success</p> <p>Wir haben unsere erste Klasse mit <code>JUnit</code> getestet. Die wesentlichen Assertions, die verwendet werden, sind <code>assertEquals()</code>, <code>assertTrue()</code> und <code>assertThrows()</code>. Mit diesen Assertions k\u00f6nnen die allermeisten Methoden getestet werden. Beim testen von Arrays wird auch h\u00e4ufig <code>assertArrayEquals()</code> verwendet. W\u00e4hlen Sie am besten eine beliebige Klasse aus den bisherigen \u00dcbungen oder Aufgaben aus, um selbst\u00e4ndig daf\u00fcr <code>JUnit</code>-Tests zu schreiben. </p>"},{"location":"junit/#test-driven-development","title":"Test-Driven Development","text":"<p>Unit Tests k\u00f6nnen entweder nach Erstellung des Programmcodes geschrieben werden, um diesen nachtr\u00e4glich zu testen oder vor Erstellung des Programmcodes. Wenn wir die Tests vor der Erstellung des Programmcodes erstellen, dann beschreiben wir mit den Tests die Anforderungen an den zu erstellenden Code. Wir werden hier lernen, wie die Erstellung der Tests und des Programmcodes Hand-in_Hand erfolgen k\u00f6nnen. Diese Vorgehensweise nennt sich Test-driven developement (TDD). </p> <p>Wir werden, wie \u00fcblich, TDD anhand eines Beispiels einf\u00fchren. Unser Vorgehen l\u00e4sst sich wie folgt beschreiben:</p> <ol> <li>Wir schreiben einen Test, der die Anforderung f\u00fcr einen m\u00f6glichst kleinen iterativen Schritt bei der Erstellung des Programmcodes beschreibt. </li> <li>Wir schreiben m\u00f6glichst wenig Programmcode, so dass der Test genau erf\u00fcllt wird. </li> <li>Wir gehen wieder zu 1. und beschreiben den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test.</li> <li>Wir wiederholen 2. f\u00fcr den neuen Test usw. </li> </ol> <p>Die folgende Abbildung visualisiert das Vorgehen. </p> <p></p> <p>Ausgangspunkt ist immer ein Test. Wir implementieren solange, bis dieser und alle vorher implementierten Tests erfolgreich durchlaufen werden. Dann schreiben wir einen weiteren Test und implementieren wieder so lange, bis dieser und alle vorher geschreibenen Tests erfolgreich durchlaufen werden. Dieses Vorgehen wird so lange wiederholt, so lange wir weitere Testf\u00e4lle hinzuf\u00fcgen k\u00f6nnen, die jeweils neue Anforderungen beschreiben. Zur Implementierung des Codes geh\u00f6rt auch das Refactoring, d.h. wir verbessern bisher geschriebenen Code durch neue Tests. </p>"},{"location":"junit/#tdd-fur-einen-time-zeit-umrechner","title":"TDD f\u00fcr einen Time-Zeit-Umrechner","text":"<p>Angenommen, wir wollen einen einfachen Konverter erstellen, der eine Uhrzeit im 12-Stunden-Zeitsystem (mit <code>am</code> und <code>pm</code>) in eine 24-Stundendarstellung umwandelt (von <code>String</code> nach <code>String</code>). Im Web findet man einige Beispiel, z.B. hier. Dazu erstellen wir uns zun\u00e4chst eine Klasse <code>UmrechnungTimeZeit.java</code>, die die Methode <code>convert()</code> enth\u00e4lt. Diese Methode erwartet einen <code>String</code> mit einer 12-Stunden-Zeit <code>time</code> und gibt einen <code>String</code> zur\u00fcck, der die <code>time</code> im 24-Stundenformat darstellt.</p> UmrechnungTimeZeit.java <pre><code>public class UmrechnungTimeZeit {\n\n    public String convert(String time)\n    {\n        return \"\";\n    }\n\n}\n</code></pre> <p>Das ist unsere Klasse in der Augangssituation. Bevor wir anfangen, zu implemntieren, wollen wir uns zun\u00e4chst einen ersten einfachen Test schreiben, der uns eine erste Anforderung (einen ersten Testfall) beschreibt. Dazu w\u00e4hlen wir in Eclipse <code>File --&gt; New --&gt; JUnit Test Case</code>. Es erscheint folgendes Fenster: </p> <p></p> <p>Wir w\u00e4hlen <code>New JUnit Jupiter test</code> aus und benennen unsere Testklasse <code>TestUmrechnungTimeZeit</code> und geben an, dass die <code>Class under test</code> die Klasse <code>UmrechnungTimeZeit</code> ist (Auswahl durch <code>Browse...</code>). Wenn wir dann auf <code>Finish</code> klicken, erscheint:</p> <p></p> <p>Das best\u00e4tigen wir mit <code>OK</code>. Es wird die <code>TestUmrechnungTimeZeit.java</code> erstellt, die so aussieht:</p> TestUmrechnungTimeZeit.java <pre><code>import static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\nclass TestUmrechnungTimeZeit {\n\n    @Test\n    void test() {\n        fail(\"Not yet implemented\");\n    }\n\n}\n</code></pre> <p>Sollten Fehler beim Import der <code>junit.jupiter</code>-Pakete angezeigt werden, dann m\u00fcssen Sie in Ihre <code>module-info.java</code> noch folgende Anweisung einf\u00fcgen: </p> Einf\u00fcgen in die module-info.java <pre><code>    requires org.junit.jupiter.api;\n</code></pre> <p>Die Klasse <code>TestUmrechnungTimeZeit.java</code> ist eine JUnit-Testklasse. </p> Video zur testgetriebenen Entwicklung <p>Die folgende testgetriebene Entwicklung wurde im folgenden Video gezeigt: </p>"},{"location":"junit/#eine-erste-testmethode-fur-unser-beispiel","title":"Eine erste Testmethode f\u00fcr unser Beispiel","text":"<p>Zun\u00e4chst einmal schauen wir uns an, wie wir unsere Testklasse ausf\u00fchren. Dazu w\u00e4hlen wir in Eclipse unter <code>Run --&gt; Run As ... --&gt; JUnit Test</code>. Oder Sie w\u00e4hlen gleich den mittleren der gezeigten drei Buttons . Dann erhalten Sie folgendes Bild:</p> <p></p> <p>Auf der linken Seite sehen Sie im <code>JUnit</code>-Reiter einen roten Querbalken. Dieser zeigt an, dass ein Test fehlgeschlagen ist. Im Editor-Fenster wird der fehlgeschlagene Test rot markiert. Es ist klar, dass der Test fehlschl\u00e4gt, denn das bezweckt ja die Assertion <code>fail()</code>. Links unten sieht man den <code>Failure trace</code>. Dort ist in der ertsen Zeile die Fehlermeldung <code>Not yet implemented</code> zu sehen - das ist die Nachricht, die der <code>fail()</code>-Assertion \u00fcbergeben wurde.</p> <p>Wir implementieren nun die erste Testmethode. Dazu benennen wir die Methode <code>test()</code> um in <code>testConvert1amTo1()</code>. In unserem ersten Test wollen wir \u00fcberpr\u00fcfen, ob unsere Methode <code>convert(String time)</code> korrekt arbeitet, wenn ihr der <code>String</code> <code>1:00 am</code> \u00fcbergeben wird. Die Idee ist nun die folgende: wir definieren unsere Testmethode so, dass wir angeben, welches Ergebnis wir erwarten, wenn der String <code>1:00 am</code> \u00fcbergeben wird. Wir erwarten das Ergebnis <code>1:00</code>.</p> <p>Generell sollte eine Testmethode in der folgenden Form aufgebaut sein:</p> <ul> <li><code>given (preperation)</code>: gibt die Voraussetzungen des Tests an, z.B. die Erzeugung eines Objektes; bei uns: die Erzeugung eines <code>UmrechnungTimeZeit</code>-Objektes,</li> <li><code>when (execution)</code>: beschreibt, was und wie ausgef\u00fchrt werden soll; bei uns: die Ausf\u00fchrung der Methode <code>convert()</code> mit dem Parameterwert <code>\"1:00 am\"</code>,</li> <li><code>then (verification)</code>: beschreibt, wie sich das Ergebnis der Ausf\u00fchrung in Bezug auf das erwartete Ergebnis verhalten soll; bei uns: <code>assertEquals(tatsaechlichesErgebnis, \"1:00\")</code>.</li> </ul> <p>Nach Umbenennung der Methode <code>test()</code> in <code>TestUmrechnungTimeZeit.java</code> in <code>testConvert1amTo1(String time)</code> und Implementierung dieser Methode sieht die Klasse <code>TestUmrechnungTimeZeit.java</code> nun so aus:</p> TestUmrechnungTimeZeit.java <pre><code>import static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\nclass TestUmrechnungTimeZeit {\n\n    @Test\n    void testConvert1amTo1() {\n        // preperation --&gt; given\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // execution --&gt; when\n        String zeit = utz.convert(\"1:00 am\");\n\n        // verification --&gt; then\n        assertEquals(\"1:00\", zeit);             \n    }\n\n}\n</code></pre> <p>In der Testmethode erzeugen wir uns also zun\u00e4chst ein Objekt von <code>UmrechnungTimeZeit</code>, damit wir die Objektmethode <code>convert()</code> \u00fcberhaupt aufrufen k\u00f6nnen (Zeile <code>9</code>). Dann rufen wir die <code>convert()</code>-Methode auf und \u00fcbergeben ihr den String <code>\"1:00 am\"</code>. Das Ergebnis der Methode wird in der Variablen <code>zeit</code> gespeichert (Zeile <code>12</code>). Dann vergleichen wir das tats\u00e4chliche Ergebnis (<code>zeit</code>) mit dem erwarteten Ergebnis (<code>\"1:00\"</code>) und wollen, dass beide gleich sind (<code>assertEquals()</code>).</p> <p>Somit haben wir einen m\u00f6glichst kleinen iterativen Schritt hin zur fertigen Implementierung als Test beschrieben. Unsere n\u00e4chste Aufgabe ist nun, m\u00f6glichst wenig Programmcode zu schreiben, so dass der Test genau erf\u00fcllt wird. Diese Aufgabe erledigen wir auf ganz simple Weise, indem unsere <code>convert()</code>-Methode einfach den String <code>\"1:00\"</code> zur\u00fcckgibt. </p> UmrechnungTimeZeit.java <pre><code>public class UmrechnungTimeZeit {\n\n    public String convert(String time)\n    {\n        return \"1:00\";\n    }\n\n}\n</code></pre> <p>Das erscheint uns auf den ersten Blick v\u00f6llig sinnlos - und das ist es nat\u00fcrlich irgendwie auch. Aber wir erinnern uns: wir wollen m\u00f6glichst wenig Programmcode schreiben, so dass der Test genau erf\u00fcllt wird. Und das machen wir hier. Wenn wir nun unsere Testklasse ausf\u00fchren, dann sehen wir:</p> <p></p> <p>Auf der linken Seite ist nun ein gr\u00fcner Balken zu sehen, d.h. alle unsere Tests (bis jetzt haben wir nur einen) sind korrekt. Unsere Methode <code>convert()</code> arbeitet in Bezug auf unsere Tests korrekt. </p> <p>Nun f\u00fcgen wir einen zweiten Test hinzu. Dazu k\u00f6nnen wir die Methode <code>testConvert1amTo1()</code> einfach kopieren. Die neue Methode nennen wir <code>testConvert1amTo1()</code>, da wir nun testen wollen, ob unsere Methode auch den String <code>\"2:00 am\"</code> korrekt nach <code>\"2:00\"</code> umwandelt. Mit diesem Test beherzigen wir das Prinzip, den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test zu beschreiben. Dieser m\u00f6glichst kleine Schritt ist f\u00fcr uns der Schritt von <code>\"1:00 am\"</code> nach <code>\"2:00 am\"</code>.</p> <p>Die neue Testmethode sieht so aus:</p> TestUmrechnungTimeZeit.java <pre><code>import static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\nclass TestUmrechnungTimeZeit {\n\n    @Test\n    void testConvert1amTo1() {\n        // preperation --&gt; given\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // execution --&gt; when\n        String zeit = utz.convert(\"1:00 am\");\n\n        // verification --&gt; then\n        assertEquals(\"1:00\", zeit);             \n    }\n\n    @Test\n    void testConvert2amTo2() {\n        // preperation --&gt; given\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // execution --&gt; when\n        String zeit = utz.convert(\"2:00 am\");\n\n        // verification --&gt; then\n        assertEquals(\"2:00\", zeit);             \n    }\n\n}\n</code></pre> <p>Wenn wir die Testklasse nun ausf\u00fchren, ohne die <code>convert()</code>-Methode zu \u00e4ndern, erhalten wir folgendes Bild:</p> <p></p> <p>Der Balken im <code>JUnit</code>-Fenster ist rot. Darunter wird uns angegeben, dass der Testfall <code>testConvert1amTo1()</code> immer noch korrekt ist (gr\u00fcner Haken), aber der Testfall <code>testConvert2amTo2()</code> ist gescheitert (blaues Kreuz). Im Editorfenster ist rot unterlegt, welche Assertion gescheitert ist (<code>assertEquals(zeit, \"2:00\");</code>). </p> <p>Wir brauchen nun also eine Idee, wie wir die <code>convert()</code>-Methode anpassen k\u00f6nnen, so dass beide Testf\u00e4lle korrekt ausgef\u00fchrt werden. Wir versuchen es mit der Idee, einfach die ersten vier Zeichen des \u00fcbergebenen Strings <code>time</code> zur\u00fcckzugeben:</p> UmrechnungTimeZeit.java <pre><code>public class UmrechnungTimeZeit {\n\n    public String convert(String time)\n    {\n        return time.substring(0,4);\n    }\n\n}\n</code></pre> <p>Wenn wir nun unsere Testklasse ausf\u00fchren, dann sind beide Testf\u00e4lle korrekt. Auf diese Art und Weise entwickeln wir nach und nach eine Implementierung der <code>convert()</code>-Methode. Dazu f\u00fcgen wir nach und nach immer weitere Testf\u00e4lle unserer Testklasse hinzu. Mindestens noch f\u00fcr folgende F\u00e4lle:</p> <code>time</code> \u00a0erwartetes Ergebnis <code>\"1:15 am\"</code> <code>\"1:15\"</code> <code>\"11:00 am\"</code> <code>\"11:00\"</code> <code>\"11:15 am\"</code> <code>\"11:15\"</code> <code>\"1:00 pm\"</code> <code>\"13:00\"</code> <code>\"2:00 pm\"</code> <code>\"14:00\"</code> <code>\"1:15 pm\"</code> <code>\"13:15\"</code> <code>\"11:00 pm\"</code> <code>\"23:00\"</code> <code>\"11:15 pm\"</code> <code>\"23:15\"</code> <code>\"12:00 am\"</code> <code>\"0:00\"</code> <code>\"12:01 am\"</code> <code>\"0:01\"</code> <code>\"12:00 pm\"</code> <code>\"12:00\"</code> <code>\"12:01 pm\"</code> <code>\"12:01\"</code> <code>\"12:00 noon\"</code> <code>\"12:00\"</code> <code>\"12:00 midnight\"</code> <code>\"0:00\"</code> <p>Das Auswahl der Testwerte ist ganz offensichtlich ein wichtiges Thema und bestimmt die Korrektheit der sp\u00e4teren Implementierung mit. Es ist wichtig, keinen Testfall zu vergessen. Leider gibt es daf\u00fcr keine formalen Regeln, sondern nur intuitive Vorgaben. Es wird immer versucht, \"Grenzwerte\" zu ermitteln, um wirklich alle Testf\u00e4lle abzudecken. </p>"},{"location":"junit/#quellcode-aus-dem-video","title":"Quellcode aus dem Video","text":"<p>Im Video \u00fcber JUnit wurde folgender Quellcode erzeugt:</p> UmrechnungTimeZeit.javaUmrechnungTimeZeit.javamodule-info.java <pre><code>package videos.video4;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class UmrechnungTimeZeit {\n\n    public String convert(String time)\n    {\n        final int LAST_THREE_CHARS = 3; // \" pm\" or \" am\"\n        if(time.endsWith(\"am\"))\n        {\n            return time.substring(0,(time.length()-LAST_THREE_CHARS));\n        }\n        else    // ends with pm\n        {\n            final int DIFFERENCE_BETWEEN_H_TO_HH = 12;\n            int hourInt = this.getHoursInt(time);\n            hourInt += DIFFERENCE_BETWEEN_H_TO_HH;\n            String minutes = this.getMinutesStr(time);\n\n            String zeit = hourInt + \":\" + minutes;\n            return zeit;\n        }       \n    }\n\n    String getHoursStr(String time)\n    {\n        String[] allStr = time.split(\":\");\n        return allStr[0];\n    }\n\n    String getMinutesStr(String time)\n    {\n        final int FIRST_TWO_CHARS = 2;\n        String[] allStr = time.split(\":\");\n        String afterDouble = allStr[1];\n        String minutesStr = afterDouble.substring(0, FIRST_TWO_CHARS);\n        return minutesStr;\n    }\n\n    int getHoursInt(String time)\n    {\n        String hoursStr = this.getHoursStr(time);\n        int hoursInt = Integer.valueOf(hoursStr);\n        return hoursInt;\n    }\n\n}\n</code></pre> <pre><code>package videos.video4;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass UmrechnungTimeZeitTest {\n\n    @Test\n    void testConvert1amTo1() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"1:00 am\");\n\n        // than (verification)\n        assertEquals(\"1:00\", zeit, \"1:00 am to 1:00 not working\");\n    }\n\n    @Test\n    void testConvert2amTo2() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"2:00 am\");\n\n        // than (verification)\n        assertEquals(\"2:00\", zeit, \"2:00 am to 2:00 not working\");\n    }\n\n\n    @Test\n    void testConvert9amTo9() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"9:00 am\");\n\n        // than (verification)\n        assertEquals(\"9:00\", zeit);\n    }   \n\n    @Test\n    void testConvert10amTo10() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"10:00 am\");\n\n        // than (verification)\n        assertEquals(\"10:00\", zeit);\n    }\n\n    @Test\n    void testConvert1115amTo1115() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"11:15 am\");\n\n        // than (verification)\n        assertEquals(\"11:15\", zeit);\n    }\n\n    @Test\n    void testConvert1pmTo13() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"1:00 pm\");\n\n        // than (verification)\n        assertEquals(\"13:00\", zeit);\n    }\n\n\n    @Test\n    void testConvert3pmTo15() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"3:00 pm\");\n\n        // than (verification)\n        assertEquals(\"15:00\", zeit);\n    }\n\n\n    @Test\n    void testConvert545pmTo1745() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"5:45 pm\");\n\n        // than (verification)\n        assertEquals(\"17:45\", zeit);\n    }\n\n    @Test\n    void testConvert11pmTo23() \n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String zeit = utz.convert(\"11:00 pm\");\n\n        // than (verification)\n        assertEquals(\"23:00\", zeit);\n    }\n\n    @Test\n    void testGetHoursStr11pm()\n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String hour = utz.getHoursStr(\"11:00 pm\");\n\n        // than (verification)\n        assertEquals(\"11\", hour);\n    }\n\n    @Test\n    void testGetHoursStr1pm()\n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String hour = utz.getHoursStr(\"1:00 pm\");\n\n        // than (verification)\n        assertEquals(\"1\", hour);\n    }\n\n\n    @Test\n    void testGetHoursInt1pm()\n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        int hours = utz.getHoursInt(\"1:00 pm\");\n\n        // than (verification)\n        assertEquals(1, hours);\n    }\n\n\n    @Test\n    void testGetHoursInt11pm()\n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        int hours = utz.getHoursInt(\"11:00 pm\");\n\n        // than (verification)\n        assertEquals(11, hours);\n    }\n\n    @Test\n    void testGetMinutes1pm()\n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String minutes = utz.getMinutesStr(\"1:00 pm\");\n\n        // than (verification)\n        assertEquals(\"00\", minutes);\n    }\n\n    @Test\n    void testGetMinutes11pm()\n    {\n        // given (preperation)\n        UmrechnungTimeZeit utz = new UmrechnungTimeZeit();\n\n        // when (execution)\n        String minutes = utz.getMinutesStr(\"11:00 pm\");\n\n        // than (verification)\n        assertEquals(\"00\", minutes);\n    }\n}\n</code></pre> <pre><code>module SoSe2021 {\n    requires java.desktop;\n    requires org.junit.jupiter.api;\n}\n</code></pre>"},{"location":"junit/#noch-ein-kleines-beispiel","title":"Noch ein kleines Beispiel","text":"<p>Wir betrachten die Klasse <code>Power</code> mit </p> <pre><code>public class Power {\n    private int base;\n    private int exp;\n\n    public Power(int base, int exp)\n    {\n        this.base = base;\n        this.exp = exp;\n    }\n\n    public double value()\n    {\n        double value = 1.0;\n        if(exp &gt; 0)\n        {\n            for(int i=0; i&lt;exp; i++)\n            {\n                value *= base;\n            }\n        }\n        else\n        {\n            for(int i=0; i&lt;-exp; i++)\n            {\n                value *= base;\n            }\n            value = 1.0 / value;\n        }\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"(\" + this.base + \"^\" + this.exp + \")\";\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        Power p = (Power)o;\n        return (this.base==p.base &amp;&amp; this.exp==p.exp);\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return 7*this.base + 11*this.exp; \n    }\n}\n</code></pre> <p>F\u00fcr diese Klasse erstellen wir eine Testklasse, die neben der Annotation <code>@Test</code> auch die Annotationen <code>@BeforeAll</code> und <code>@BeforeEach</code> exemplarisch verwendet. </p> <pre><code>import static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass PowerTest {\n    static Power p1,p2,p3,p4;\n    static int testnr = 1;\n\n    @BeforeAll\n    public static void setup()\n    {\n        p1 = new Power(2,3);\n        p2 = new Power(2,3);\n        p3 = new Power(-2,3);\n        p4 = new Power(2,-3);\n    }\n\n    @BeforeEach\n    public void printBeforeTests()\n    {\n        System.out.printf(\"%n %n --------------- Test %d ------------ %n\", testnr);\n        p1.print();\n        p2.print();\n        testnr++;\n    }\n\n\n    @Test\n    void testToString() {\n        String s = p1.toString();\n\n        assertEquals(\"(2^3)\", s, \"Strings are not equal!\");\n    }\n\n    @Test\n    void testPower() {\n        assertNotNull(p1, \"no Power object\");\n    }\n\n    @Test\n    void testValue() {      \n        double value = p1.value();\n\n        assertEquals(8.0, value, \"2^3 should be 8.0\");\n    }\n\n    @Test\n    public void testEqualsObject() {\n        assertTrue(p1.equals(p2), \" 2^3 should be equal to 2^3!\");\n    }\n}\n</code></pre> <p>Diese Testklasse deckt nat\u00fcrlich viel zu wenige Testf\u00e4lle ab, aber es geht hier nur ums Prinzip. F\u00fchren Sie die Testklasse aus und beobachten Sie dabei auch die Konsole. Vor jeden Test (<code>@BeforeEach</code>) gibt es eine Ausgabe auf die Konsole. Bevor irgendein Test (<code>@Test</code>) ausgef\u00fchrt wird (<code>@BeforeAll</code>) werden verschiedene Objekte der Klasse <code>Power</code> erzeugt. In den Testf\u00e4llen werden aber nur <code>p1</code> und <code>p2</code> verwendet. Das m\u00fcsste nat\u00fcrlich noch deutlich erweitert werden.</p> <p>Success</p> <p>Wir haben JUnit-Testing kennengelernt. Unit-Tests sind eine gute M\u00f6glichkeit, einzelne Methoden automatisiert zu testen. Mithilfe von Unit-Tests k\u00f6nnen wir Code so entwicklen, dass alle formulierten Tests erfolgreich bestehen. Werden erst die Tests geschrieben und gegen die Tests implementiert, wird dieses Programmierverfahren Test-driven development genannt. Unit-Tests k\u00f6nnen aber auch verwendet werden, um existierenden Code zu testen. JUnit ist das Framework f\u00fcr Java-Unit-Tests. Ausf\u00fchrliche Informationen zu JUnit sind hier zu finden.   </p>"},{"location":"lambdas/","title":"Lambda-Ausdr\u00fccke","text":"<p>Lambda-Ausdr\u00fccke (Lambdas) sind anonyme Funktionen (Methoden), d.h. Funktionen (Methoden) ohne Namen. Lambdas werden im Zusammenhang von Functional Interfaces verwendet. Im Kontext von Lambdas sprechen wir stets eher von Funktionen als von Methoden. Die prinzipielle Syntax von Lambda-Ausdr\u00fccken ist</p> <pre><code>(params) -&gt; {body}\n</code></pre> <p>Lambda-Ausdr\u00fccke bestehen aus drei Teilen:</p> <ol> <li>einer Liste von keinem, einem oder merhrern Parametern, durch Komma getrennt und in runden Klammern <code>()</code>. Diesen Parametern muss kein Typ zugewiseen werden. Der jeweilige Tp des Parameters wird aus dem Kontext ermittelt. Besteht die Parameterliste aus genau einem Parameter, k\u00f6nnen die runden Klammern weggelassen werden.</li> <li>dem Pfeil <code>-&gt;</code>, der die Parameterliste mit dem Funktionsk\u00f6rper verbindet.</li> <li>Dem Funktionsk\u00f6rper, der nur dann in geschweiften Klammern eingefasst ist, wenn er aus mehr als einer Anweissung besteht. Wir k\u00f6nnen also auch so schreiben:</li> </ol> <pre><code>(params) -&gt; anweisung\n</code></pre> <p>Beachten Sie, dass hinter der einzelnen Anweisung kein Semikolon steht. </p>"},{"location":"lambdas/#erstes-beispiel","title":"Erstes Beispiel","text":"<p>Wir betrachten ein erstes einfaches Beispiel zur Verwendung von Lambdas. Angenommen, wir haben folgende einfache Liste </p> <pre><code>List&lt;String&gt; staedte = List.of(\"Berlin\", \"Hamburg\", \"M\u00fcnchen\", \"K\u00f6ln\", \"Frankfurt am Main\", \"D\u00fcsseldorf\",\n                \"Stuttgart\", \"Leipzig\", \"Dortmund\", \"Bremen\", \"Essen\" ,\"Dresden\");\n</code></pre> <p>und wollen jedes einzelne Element aus dieser Liste ausgeben. Das h\u00e4tten wir bis jetzt mit einer <code>for</code>-Schleife erledigt. F\u00fcr Collections steht uns die <code>forEach()</code>-Methode aus dem Iterable-Interface zur Verf\u00fcgung. Die <code>forEach()</code>-Methode ist wie folgt deklariert:</p> <pre><code>void forEach(Consumer&lt;T&gt; action)\n</code></pre> <p>Das Interessante darin ist das Consumer-Interface. Dieses stellt die Schnittstelle zu unseren Lambda-Ausdr\u00fccken dar. Das Consumer-Interface repr\u00e4sentiert eine Funktion, die einen einzelnen Parameter akzeptiert und keinen Wert zur\u00fcckliefert. Wir k\u00f6nnen nun einen Lambda-Ausdruck als Consumer definieren, z.B.:</p> <pre><code>staedte.forEach((stadt)  -&gt; System.out.println(stadt));\n</code></pre> <p>Da wir nur genau einen Parameter haben, k\u00f6nnen wir auch die runden Klammern weglassen: </p> <pre><code>staedte.forEach(stadt  -&gt; System.out.println(stadt));\n</code></pre> <p>Sollte unsere Funktion aus mehreren Anweisungen bestehen, verwenden wir geschweifte Klammern (und Semikolon):</p> <pre><code>staedte.forEach(stadt  -&gt; {\n        System.out.printf(\"%2d : \", (staedte.indexOf(stadt) + 1) );\n        stadt= stadt.toUpperCase();\n        System.out.println(stadt);\n});\n</code></pre> <p>Wir k\u00f6nnten uns den <code>Consumer</code> auch zun\u00e4chst explizit definieren und dann wiederverwenden:</p> <pre><code>Consumer&lt;String&gt; printStadt = stadt  -&gt; {\n    System.out.printf(\"%2d : \", (staedte.indexOf(stadt) + 1) );\n    stadt= stadt.toUpperCase();\n    System.out.println(stadt);\n};\nstaedte.forEach(printStadt);\n</code></pre>"},{"location":"lambdas/#functional-interfaces","title":"Functional Interfaces","text":"<p>Wir haben nun bereits Consumer kennengelernt. Consumer ist ein Functional Interface, d.h. es besitzt genau eine abstrakte Methode (<code>accept()</code>). Lambdas lassen sich nur in Verbindung mit Functional Interfaces verwenden, denn nur dann ist eindeutig, welche Methode durch den Lambda-Ausdruck implementiert wird. Wir betrachten folgendes Beispiel zur Kl\u00e4rung (siehe Functional Interfaces):</p> <pre><code>@FunctionalInterface\npublic interface Printable\n{\n    void print(String s);\n\n    default void print()\n    {\n        print(\"default\");\n    }\n}\n</code></pre> <p><code>Printable</code> ist ein funktionales Interface, da es nur genau eine abstrakte Methode, n\u00e4mlich <code>print(String)</code> enth\u00e4lt. Die <code>print()</code>-Methode ist eine sogenannte default-Methode und bereits implementiert. </p> <p>Wir k\u00f6nnten uns nun eine Klasse definieren, die <code>Printable</code> implementiert, z.B. </p> <pre><code>public class UseInterface implements Printable\n{\n\n    @Override\n    public void print(String s)\n    {\n        System.out.println(s);\n    }\n}\n</code></pre> <p>und wenn wir nun irgendwo eine Methode haben, die ein <code>Printable</code> erwartet, kann dieser Methode ein Objekt von <code>UseInterface</code> \u00fcbergeben werden:</p> <pre><code>public class Programmklasse\n{\n    public static void printSomething(Printable p, String s)\n    {\n        p.print(s);\n    }\n\n    public static void main(String[] args)\n    {\n        UseInterface useInterface = new UseInterface();\n        printSomething(useInterface, \"hallo\");\n    }\n}\n</code></pre> <p>Das ist nat\u00fcrlich alles sehr aufw\u00e4ndig:</p> <ul> <li>wir ben\u00f6tigen eine Klasse, die <code>Printable</code> implementiert (hier: <code>UseInterface</code>),</li> <li>wir ben\u00f6tigen ein Objekt dieser Klasse </li> </ul> <p>und das alles nur, um <code>printSomething()</code> auszuf\u00fchren. Einfacher w\u00e4re es, wir w\u00fcrden direkt in <code>printSomething()</code> die <code>print()</code>-Methode des Interfaces <code>Printable</code> implementieren. Das geht und zwar unter Verwendung von Lambdas:</p> <pre><code>public class Programmklasse\n{\n    public static void printSomething(Printable p, String s)\n    {\n        p.print(s);\n    }\n\n    public static void main(String[] args)\n    {\n        // UseInterface useInterface = new UseInterface();\n        // printSomething(useInterface, \"hallo\");\n        printSomething((s) -&gt; System.out.println(s), \"hallo\" );\n    }\n}\n</code></pre> <p>Mithilfe von <code>(s) -&gt; System.out.println(s)</code> wird also die abstrakte <code>print(s)</code>-Methode aus dem (Functional) Interface <code>Printable</code> implementiert. Wir ben\u00f6tigen keine extra Klasse, die <code>Printable</code> implementiert und somit auch kein Objekt dieser Klasse. </p> <p>Das <code>Printable</code>-Interface aus unserem Beispiel ist vergleichbar mit dem Consumer-Interface, da eine Methode implementiert wird, die keinen Wert zur\u00fcckgibt. Die funktionale Methode hei\u00dft <code>accept(T)</code>. Es folgt ein kurzer \u00dcberblick \u00fcber die wesentlichen Functional Interfaces  aus dem Paket <code>java.util.function</code>.</p>"},{"location":"lambdas/#javautilfunctionconsumer","title":"java.util.function.Consumer <p>Das Functional Interface Consumer repr\u00e4sentiert eine Funktion (Methode), die einen Parameter vom Typ <code>T</code> akzeptiert, die Methode ausf\u00fchrt und keinen Wert zur\u00fcckgibt. Die funktionale Methode hei\u00dft <code>void accept(T)</code>. </p> <p>Einfaches <code>Consumer</code>-Beispiel:</p> <pre><code>Consumer&lt;String&gt; print = message -&gt; System.out.println(message);\nprint.accept(\"Hallo FIW!\");\n</code></pre>","text":""},{"location":"lambdas/#javautilfunctionfunction","title":"java.util.function.Function <p>Das Functional Interface Function repr\u00e4sentiert eine Funktion (Methode), die einen Parameter vom Typ <code>T</code>akzeptiert und durch Ausf\u00fchrung der Methode ein Resultat vom Typ <code>R</code> zur\u00fcckgibt. Die funktionale Methode hei\u00dft <code>R apply(T)</code>. </p> <p>Einfaches <code>Function</code>-Beispiel:</p> <pre><code>Function&lt;String, Integer&gt; stringLength = str -&gt; str.length();\nSystem.out.println(stringLength.apply(\"Hallo FIW!\"));           // Output: 10\n</code></pre> <p>F\u00fcr den Fall, dass zwei Parameter erwartet werden, gibt es das Functional Interface BiFunction. </p> <p>Einfaches <code>BiFunction</code>-Beispiel:</p> <pre><code>BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;\nSystem.out.println(add.apply(3,4));                             // Output: 7\n</code></pre> <p>Auf diese Weise k\u00f6nnen Sie sich auch eigene Functional Interfaces bauen (siehe z.B. hier), z.B.:</p> <pre><code>@FunctionalInterface\ninterface TriFunction&lt;T, U, V, R&gt; {\n    R apply(T t, U u, V v);\n}\n</code></pre> <p>und dann</p> <pre><code>// Using custom TriFunction\nTriFunction&lt;String, String, String, String&gt; concat = \n    (a, b, c) -&gt; a + b + c;\n\nString result = concat.apply(\"Hello\", \" \", \"World\");\nSystem.out.println(result); // Output: Hello World\n\n// More practical example\nTriFunction&lt;Double, Double, Double, Double&gt; calculateVolume = \n    (length, width, height) -&gt; length * width * height;\n\nDouble volume = calculateVolume.apply(2.0, 3.0, 4.0);\nSystem.out.println(\"Volume: \" + volume); // Output: Volume: 24.0\n</code></pre> <p>Das Functional Interface <code>Function</code> besitzt neben der SAM (single abstract method) <code>apply(T t)</code> auch noch die default-Methoden <code>andThen(Function after)</code> und <code>compose(Function before)</code>. Damit lassen sich Funktionen \"zusammenbauen\" (siehe z.B. hier):</p> <pre><code>Function&lt;Integer, Integer&gt; multiply = x -&gt; x * 2;\nFunction&lt;Integer, Integer&gt; add = x -&gt; x + 3;\n\n// Using andThen (first multiply, then add)\nFunction&lt;Integer, Integer&gt; multiplyThenAdd = multiply.andThen(add);\nSystem.out.println(multiplyThenAdd.apply(5)); // Output: 13\n\n// Using compose (first add, then multiply)\nFunction&lt;Integer, Integer&gt; addThenMultiply = multiply.compose(add);\nSystem.out.println(addThenMultiply.apply(5)); // Output: 16\n\n// andThen() and compose() are default-methods in Function\n</code></pre>","text":""},{"location":"lambdas/#javautilfunctionpredicate","title":"java.util.function.Predicate <p>Das Functional Interface Predicate repr\u00e4sentiert eine Funktion (Methode), die einen Parameter vom Typ <code>T</code>akzeptiert und durch Ausf\u00fchrung der Methode ein Resultat vom Typ <code>boolean</code> zur\u00fcckgibt. Die funktionale Methode hei\u00dft <code>boolean test(T)</code>. </p> <p>Einfaches <code>Predicate</code>-Beispiel:</p> <pre><code>Predicate&lt;Integer&gt; isEven = number -&gt; number % 2 == 0;\nSystem.out.println(isEven.test(4));                             // Output: true\n</code></pre> <p>F\u00fcr den Fall, dass zwei Parameter erwartet werden, gibt es das Functional Interface BiPredicate. </p> <p>Einfaches <code>BiPredicate</code>-Beispiel:</p> <pre><code>BiPredicate&lt;String, String&gt; equalsIgnoreCases = (str1, str2) -&gt; str1.toLowerCase().equals(str2.toLowerCase());\nSystem.out.println(equalsIgnoreCases.test(\"Hallo FIW!\", \"HALLO fiw!\"));                             // Output: true\n</code></pre> <p>Das Functional Interface <code>Predicate</code> besitzt neben der SAM (single abstract method) <code>test(T t)</code> auch noch die default-Methoden <code>and(Predicate other)</code>, <code>not(Predicate target)</code> und <code>or(Predicate other)</code>. Damit lassen sich Bedingungen \"zusammenbauen\" (siehe z.B. hier):</p> <pre><code>Predicate&lt;Person&gt; isAdult = person -&gt; person.getAge() &gt;= 18;\nPredicate&lt;Person&gt; isFromGermany = person -&gt; \"GER\".equals(person.getCountry());\nPredicate&lt;Person&gt; isNameStartsWithJ = person -&gt; person.getName().startsWith(\"J\");\n\n// Combining predicates\nPredicate&lt;Person&gt; isAdultFromGermanyWithJName = isAdult\n    .and(isFromUGermany)\n    .and(isNameStartsWithJ);\n\n// and() ist default-method in Predicate (or(), negate())\n</code></pre>","text":""},{"location":"lambdas/#javautilfunctionsupplier","title":"java.util.function.Supplier <p>Das Functional Interface Supplier repr\u00e4sentiert eine Funktion (Methode), die durch Ausf\u00fchrung der Methode ein Resultat vom Typ <code>T</code> zur\u00fcckgibt. Die funktionale Methode hei\u00dft <code>T get()</code>. <code>Supplier</code> wird z.B. benutzt, um sogenannte Fabrik-Methoden zu definieren. Fabrik-Methoden erzeugen neue Objekte. Daf\u00fcr schauen wir uns den folgenden Abschnitt Methode-Referenzen genauer an:</p>","text":""},{"location":"lambdas/#methoden-referenzen","title":"Methoden-Referenzen <p>Methoden-Referenzen sind eine syntaktische Abk\u00fcrzung, um Methoden aufzurufen. Methoden-Referenzen sind somit ein spezieller Fall f\u00fcr Lambda-Ausdr\u00fccke. Methoden-Referenzen erkennen wir an folgender Syntax </p> <pre><code>::methode\n</code></pre> <p>Es gelten folgende Regeln in Abh\u00e4ngigkeit davon, um es sich um eine statische Methode oder um eine Objektmethode handelt. Im letzteren Fall gibt es noch eine Unterscheidung, ob die Methode f\u00fcr alle (jedes beliebige) oder f\u00fcr ein ganz konkretes Objekt handelt:</p>    \u00a0Art \u00a0Syntax \u00a0Beispiel     Referenz auf eine \u00a0statische Methode  <code>Class::staticMethod</code>  <code>Integer::valueOf</code>   \u00a0Referenz auf eine  Objektmethode  eines spezifischen \u00a0Objektes  <code>referenceVariable::objectMethod</code>  <code>myNumber::getValue</code>   \u00a0Referenz auf eine  Objektmethode  eines beliebigen  Objektes  <code>Type::objectMethod</code>  <code>Integer::getValue</code>   \u00a0Referenz auf einen  Konstruktor  <code>Type::new</code>  <code>Integer[]::new</code>    <p>Bei der Verwendung von Methoden-Referenzen k\u00f6nnen wir in Lambdas sogar ganz auf die Verwendung der Parameter verzichten. Der Code wird dadurch lesbarer (siehe <code>staedte</code>-Beispiel oben):</p> <pre><code>staedte.forEach(System.out::println);\n</code></pre> <p>Einfaches Beispiel f\u00fcr <code>Supplier</code>:</p> <pre><code>Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new;\nList&lt;String&gt; list = listSupplier.get();\n</code></pre> <p>Zu weiteren Informationen \u00fcber Methodenreferenzen siehe z.B. hier.</p>","text":""},{"location":"maps/","title":"Maps","text":"<p>Maps sind auch Collections. Maps sind Mengen von Schl\u00fcssel-Werte-Paaren. Wir k\u00f6nnen uns Maps als zweispaltige Tabellen vorstellen, in denen die linke Spalte die Schl\u00fcssel (keys) enth\u00e4lt und die rechte Spalte die Werte (values). Die Schl\u00fcssel in einer Map sind immer eindeutig, d.h. keine zwei Schl\u00fcssel in einer Map sind gleich. Tats\u00e4chlich handelt es sich bei der Menge der Schl\u00fcssel um eine <code>Set</code>. </p> <p>Obwohl Maps Collections sind, wurde f\u00fcr sie nicht das Interface Collection implementiert, so wie f\u00fcr Listen und Mengen, sondern ein eigenes Interface Map. F\u00fcr Interessierte lohnt sich vielleicht auch ein Blick in die Collections Framework Documentation und das Collections Framework Tutorial.</p>"},{"location":"maps/#statt-add-und-addall-hier-put-und-putall","title":"Statt <code>add()</code> und <code>addAll()</code> hier <code>put()</code> und <code>putAll()</code>","text":"<p>Da nicht das <code>Collections</code>-Interface f\u00fcr <code>Maps</code> implementiert wurde, erfolgt das Hinzuf\u00fcgen eines Schl\u00fcssel-Werte-Paares zu einer <code>Map</code> leider auch nicht \u00fcber <code>add()</code> bzw. das Hinzuf\u00fcgen einer Collection nicht \u00fcber <code>addAll()</code>, sondern \u00fcber </p> <ul> <li><code>put(K key, V value)</code> und</li> <li><code>putAll(Map m)</code>.</li> </ul> <p><code>K</code> ist dabei ein Platzhalter f\u00fcr den Typ der Schl\u00fcssel und <code>V</code> ein Platzhalter f\u00fcr den Typ der Werte. </p>"},{"location":"maps/#typ-einer-map-und-typ-eines-schlussel-werte-paares","title":"Typ einer <code>Map</code> und Typ eines Schl\u00fcssel-Werte-Paares","text":"<p>Eine <code>Map</code> wird also mit zwei Typen typisiert:</p> <ul> <li><code>Map&lt;K, V&gt;</code></li> </ul> <p>wobei <code>K</code> den Typ der Schl\u00fcssel und <code>V</code> den Typ der Werte definiert. </p> <p>Der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist</p> <ul> <li><code>Map.Entry&lt;K,V&gt;</code></li> </ul> <p>Das sieht f\u00fcr uns nat\u00fcrlich auch erstmal ungew\u00f6hnlich aus. <code>Entry</code> ist eine innere Klasse in der Klasse <code>Map</code> (tats\u00e4chlich sind beides Interfaces). Wir nehmen das erstmal einfach so hin und merken uns: der (typisierte) Typ einer <code>Map</code> ist <code>Map&lt;K,V&gt;</code> und der (typisierte) Typ jedes einzelnen Schl\u00fcssel-Werte-Paares in dieser <code>Map</code> ist <code>Map.Entry&lt;K,V&gt;</code>. </p>"},{"location":"maps/#statt-iterator-hier-entryset","title":"Statt <code>iterator()</code> hier <code>entrySet()</code>","text":"<p>Die Objektmethode <code>iterator()</code> gibt es f\u00fcr <code>Map</code> leider auch nicht. Stattdessen wird hier die Methode <code>entrySet()</code> verwendet. Da es sich bei einer <code>Map</code> um eine <code>Set</code> von lauter Schl\u00fcssel-Werte-Paaren (jeweils Typ <code>Map.Entry&lt;K,V&gt;</code>) handelt, liefert <code>entrySet()</code> eine </p> <ul> <li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></li> </ul> <p>zur\u00fcck. Lassen Sie sich von dieser kryptischen Schreibweise nicht abschrecken! Zur\u00fcckgegeben wird eine <code>Set</code>. Diese ist typisiert und zwar mit dem Typ <code>Map.Entry</code>, welches der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist. <code>Map.Entry</code> ist selbst typisiert, n\u00e4mlich mit dem Typ der Schl\u00fcssel <code>K</code> und dem Typ der Werte <code>V</code>. F\u00fcr <code>K</code> und <code>V</code> werden bei Verwendung konkrete Typen eingesetzt. Hier sind es zun\u00e4chst nur Platzhalter. </p>"},{"location":"maps/#klassenbaum-fur-map","title":"Klassenbaum f\u00fcr <code>Map</code>","text":"<p>Der Klassenbaum f\u00fcr <code>Map</code> hat \u00c4hnlichkeiten zum Klassenbaum f\u00fcr <code>Collection</code>. Wir finden hier wieder gr\u00fcne (Interfaces), rote (abstrakte Klassen) und blaue (konkrete Klassen) Felder.</p> <p></p> <p>Auch hier ist es wieder so, dass wir <code>Map</code> als Typ f\u00fcr eine Map verwenden, aber f\u00fcr die Erzeugung konkreter Objekte die Klassen <code>EnumMap</code>, <code>HashMap</code> und <code>TreeMap</code> verwenden. Die am h\u00e4ufigsten verwendete Klasse ist <code>HashMap</code>, da sie am performantesten arbeitet. Sobald Reihenfolge/Sortierung eine Rolle spielt, wird <code>TreeMap</code> verwendet. </p>"},{"location":"maps/#erstes-beispiel","title":"Erstes Beispiel","text":"<p>Wir betrachten ein erstes Beispiel. Wir erstellen eine <code>HashMap</code> und f\u00fcgen vier Eintr\u00e4ge hinzu:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\n\npublic class Maps {\n\n    public static void main(String[] args) \n    {\n        Map&lt;String,Double&gt; m = new HashMap&lt;&gt;();\n        m.put(\"s0512345\", 1.7);     // neues Schluessel-Werte-Paar hinzugefuegt\n        m.put(\"s0587654\", 2.3);     // neues Schluessel-Werte-Paar hinzugefuegt\n        m.put(\"s0512345\", 2.7);     // Schluessel existiert bereits --&gt; Wert geaendert\n        m.put(\"s0555555\", 3.0);     // neues Schluessel-Werte-Paar hinzugefuegt\n    }\n}\n</code></pre> <ul> <li>In Zeile <code>8</code> wird unsere <code>Map</code> erzeugt. Die Referenzvariable auf die <code>Map</code> hei\u00dft <code>m</code>. Die Schl\u00fcssel sind vom Typ <code>String</code> und die Werte sind vom Typ <code>Double</code>. Das konkrete Objekt wird durch den Aufruf des Konstruktors der Klasse <code>HashMap</code> erzeugt. </li> <li>In Zeile <code>9</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein neues Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0512345\"</code>, der Wert (value) ist <code>1.7</code>. Beachten Sie, dass hier ein Auto-Boxing des <code>double</code>-Wertes <code>1.7</code> in ein <code>Double</code> stattfindet. </li> <li>In Zeile <code>10</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0587654\"</code>, der Wert (value) ist <code>2.3</code> (erneut Auto-Boxing). </li> <li>In Zeile <code>11</code> wird erneut die <code>put()</code>-Methode aufgerufen. Der Schl\u00fcssel <code>\"s0512345\"</code> existiert jedoch bereits. Deshalb wird nur der Wert ge\u00e4ndert. Aus dem alten Wert <code>1.7</code> wird nun <code>2.7</code>. Die <code>Map</code> enth\u00e4lt nach dieser Anweisung (noch nur) zwei Eintr\u00e4ge. </li> <li>In Zeile <code>12</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0555555\"</code>, der Wert (value) ist <code>3.0</code> (erneut Auto-Boxing). </li> </ul> <p>Nach diesen Anweisungen sieht unsere Map also wie folgt aus (die \u00dcberschriften der Tabelle dienen nur der Orientierung):</p> <p></p> <p>Die folgende Abbildung zeigt die Methoden, um Zugriff auf die Werte, Schl\u00fcssel und alle Eintr\u00e4ge zu erhalten:</p> <p></p> <p>Die Anwendung dieser Methoden auf unsere Map <code>m</code> zeigen die folgenden Anweisungen:</p> <pre><code>Set&lt;String&gt; keys = m.keySet();                  // Menge aller Schluessel\nCollection&lt;Double&gt; values = m.values();         // Collection aller Werte\nSet&lt;Map.Entry&lt;String, Double&gt;&gt; entries = m.entrySet();  // Menge aller Schluessel-Werte-Paare\n</code></pre> <ul> <li>die Objektmethode <code>keySet()</code> liefert die Menge aller Schl\u00fcssel zur\u00fcck; R\u00fcckgabetyp ist <code>Set&lt;K&gt;</code>,</li> <li>die Objektmethode <code>values()</code> liefert eine Collection aller Werte zur\u00fcck; R\u00fcckgabetyp ist <code>Collection&lt;V&gt;</code>,</li> <li>die Objektmethode <code>entrySet()</code> liefert die Menge aller Schl\u00fcssel-Werte-Paare zur\u00fcck; R\u00fcckgabetyp ist <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></li> </ul>"},{"location":"maps/#durch-eine-map-laufen","title":"Durch eine <code>Map</code> laufen","text":"<p>Um alle Schl\u00fcssel-Werte-Paare einer Map zu extrahieren, k\u00f6nnen wir, wie bereits erw\u00e4hnt, die Methode <code>entrySet()</code> verwenden. F\u00fcr den R\u00fcckgabetyp <code>Map.Entry&lt;K,V&gt;</code> stehen uns zwei weitere Objektmethoden zur Verf\u00fcgung:</p> <ul> <li><code>getKey()</code> liefert den Schl\u00fcssel des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist <code>K</code>,</li> <li><code>getValue()</code> liefert den Wert des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist <code>V</code>.</li> </ul> <p>Wir betrachten f\u00fcr unsere Map <code>m</code> ein Beispiel: </p> <p><pre><code>for(Map.Entry&lt;String, Double&gt; eintrag : m.entrySet())\n{\n    System.out.println( eintrag.getKey() + \"\u00a0 :\u00a0 \" + eintrag.getValue());\n}\n</code></pre> - In Zeile <code>1</code> wird die Methode <code>m.entrySet()</code> aufgerufen, diese gibt eine <code>Set&lt;Map.Entry&lt;String, Double&gt;&gt;</code> zur\u00fcck. Jeder einzelne Eintrag in dieser <code>Set</code> ist also vom Typ <code>Map.Entry&lt;String,Double&gt;</code>. Deshalb verwenden wir diesen Typ f\u00fcr unsere Variable <code>eintrag</code>. Wir nutzen hier also erneut die for-each-Schleife, um durch eine <code>Set</code> zu laufen.  - In Zeile <code>3</code> verwenden wir die Objektmethoden <code>getKey()</code> und <code>getValue()</code>, die uns von <code>Map.Entry</code> zur Verf\u00fcgung gestellt werden. <code>getKey()</code> gibt uns hier einen <code>String</code> zur\u00fcck (den Schl\u00fcssel) und <code>getValue()</code> gibt hier ein <code>Double</code> zur\u00fcck (den Wert). Hier erfolgt eine automatische Konvertierung von <code>Double</code> nach <code>String</code> (impliziter Aufruf von <code>toString()</code> f\u00fcr <code>Double</code>). </p> <p>Es erfolgt folgende Ausgabe:</p> <pre><code>s0512345\u00a0 :\u00a0 2.7\ns0555555\u00a0 :\u00a0 3.0\ns0587654\u00a0 :\u00a0 2.3\n</code></pre> <p>Wir sehen also, dass die Reihenfolge des Einf\u00fcgens der Elemente nicht gewahrt bleibt. Die Schl\u00fcssel werden auch nicht sortiert, das sieht hier nur so aus. </p> <p>Wir probieren auch noch die Objektmethoden <code>keySet()</code> und <code>value()</code> aus, die f\u00fcr eine <code>Map</code> zur Verf\u00fcgung stehen:</p> <pre><code>for(String schluessel : m.keySet())\n{\n    System.out.println(\"key : \" + schluessel);\n}\n</code></pre> <p>erzeugt: </p> <pre><code>key : s0512345\nkey : s0555555\nkey : s0587654\n</code></pre> <p>und </p> <pre><code>for(Double wert : m.values())\n{\n    System.out.println(\"value : \" + wert.toString());  // toString() wuerde auch implizit aufgerufen\n}\n</code></pre> <p>erzeugt: </p> <pre><code>value : 2.7\nvalue : 3.0\nvalue : 2.3\n</code></pre> <p>\u00dcbung</p> <p>Was wird ausgegeben? <pre><code>Map&lt;String, String&gt; accounts = new HashMap&lt;&gt;();\n\naccounts.put(\"anton\", \"anton@email.de\");\naccounts.put(\"berta\", \"berta@email.de\");\naccounts.put(\"caesar\", \"caesar@email.de\");\naccounts.put(\"anton\", \"antonius@email.de\");\n\n// Iteration ueber alle Eintraege (Map.Entry) der Map\nfor(Map.Entry&lt;String, String&gt; entry : accounts.entrySet()) \n{\n    System.out.println(\"Account : \" + entry.getKey() + \" E-Mail : \" + entry.getValue());\n}\n</code></pre></p>"},{"location":"maps/#zusammenfassung-maps","title":"Zusammenfassung Maps","text":"<ul> <li>Maps speichern Referenztypen als Schl\u00fcssel und Werte</li> <li>Maps werden typisiert mit <code>K</code> (Platzhalter f\u00fcr den Referenztyp des Schl\u00fcssels) und <code>V</code> (Platzhalter f\u00fcr den Referenztyp des Wertes) </li> <li>Maps enthalten eindeutige Zuordnungen von einem Wert zu einem Schl\u00fcssel (aber nicht umgekehrt)</li> <li>der Zugriff auf alle Eintr\u00e4ge/Schl\u00fcssel/Werte erfolgt \u00fcber Sets/Collection</li> <li>der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist <code>Map.Entry&lt;K,V&gt;</code></li> </ul> <p>Hier noch ein \u00dcberblick \u00fcber die wichtigsten Objektmethoden f\u00fcr eine <code>Map</code>. Weitere Methoden finden Sie hier.</p> Objektmethode  Beschreibung  <code>V get(K key)</code> Gibt den Wert zum Schl\u00fcssel <code>key</code> zur\u00fcck. Ist der Schl\u00fcssel <code>key</code> nicht in der <code>Map</code> enthalten, wird <code>null</code> zur\u00fcckgegeben. <code>V put(K key, V value)</code> F\u00fcgt einen neuen Eintrag mit dem Schl\u00fcssel <code>key</code> und dem Wert <code>value</code> in die <code>Map</code> ein. Wenn ein Eintrag f\u00fcr Schl\u00fcssel <code>key</code> bereits existiert, wird der <code>value</code> \u00fcberschrieben. <code>void putAll(Map m) F\u00fcgt alle Element der Map <code>m</code> in die Map ein. Wenn ein Eintrag f\u00fcr einen Schl\u00fcssel bereits existiert, wird er \u00fcberschrieben. <code>void clear()</code> Entfernt alle Elemente aus der Map. <code>boolean containsKey(Object k)</code> Gibt <code>true</code> zur\u00fcck, wenn es einen Eintrag mit dem Schl\u00fcssel <code>k</code> in der Map gibt. Der Vergleich der Schl\u00fcssel mit dem Objekt <code>k</code> erfolgt mit der <code>equals()</code>-Methode. <code>boolean containsValue(Object v)</code> Gibt <code>true</code> zur\u00fcck, wenn es einen Eintrag mit dem Wert <code>v</code> in der Map gibt. Der Vergleich der Werte mit dem Objekt <code>v</code> erfolgt mit der <code>equals()</code>-Methode. <code>boolean isEmpty()</code> Gibt <code>true</code> zur\u00fcck, wenn sich keine Elemente in der Map befinden. <code>V remove(Object key)</code> Entfernt den Eintrag mit dem Schl\u00fcssel <code>key</code> aus der Map und gibt den dazugeh\u00f6rigen Wert zur\u00fcck (wenn <code>key</code> in der Map enthalten ist, sonst <code>null</code>). <code>int size()</code> Gibt die Anzahl der Elemente in der Map zur\u00fcck. <code>Set keySet() Gibt eine <code>Set</code> mit allen Schl\u00fcsseln der Map zur\u00fcck. <code>Collection values() Gibt eine <code>Collection</code> mit allen Werten der Map zur\u00fcck. <code>Set&gt; entrySet() Gibt eine <code>Set</code> mit allen Eintr\u00e4gen (Schl\u00fcssel-Werte-Paare) als <code>Map.Entry der Map zur\u00fcck."},{"location":"optionals/","title":"Optionals","text":"<p>Ein Optional kann man sich wie einen Container vorstellen, der eigentlich daf\u00fcr da ist, einen Wert zu speichern, jedoch eventuell leer ist (keinen Wert hat). Optional wurde eingef\u00fchrt, um <code>NullPointerException</code>s zu vermeiden. Wir hatten bereits gen\u00fcgend Beispiele, in denen wir <code>null</code> zur\u00fcckgeben mussten, falls kein geeigneter Wert f\u00fcr die R\u00fcckgabe existierte. Dies sollten wir jedoch dringend vermeiden, um der aufrufenden Methode eine m\u00f6gliche <code>NullPointerException</code> zu ersparen. Mit dem Werfen geeigneter Exceptions l\u00e4sst sich dieses Problem zwar bereits l\u00f6sen, jedoch ist dann der Aufruf der Methode in einen <code>try-Catch</code>-Block erforderlich, was zu unsch\u00f6nem Code f\u00fchrt. Zudem sind solche Exceptions meistens <code>unchecked</code> und f\u00fchren unbehandelt dann trotzdem zu einem Laufzeitfehler. </p> <p>Der Haupteinsatzzweck von Optional ist als Methodenr\u00fcckgabe, wobei durch die Verwendung von <code>Optional</code> sichergestellt wird, dass es m\u00f6glich ist, dass kein Wert zur\u00fcckgegeben wird. </p> <p>Angenommen, wir haben folgenden Code:</p> <pre><code>Map&lt;String, String&gt; studieng\u00e4nge = new HashMap&lt;&gt;();\nstudieng\u00e4nge.put(\"fiw\", \"Informatik und Wirtschaft\");\nstudieng\u00e4nge.put(\"ai\", \"Angewandte Informatik\");\nstudieng\u00e4nge.put(\"imi\", \"Internationale Medieninformatik\");\nstudieng\u00e4nge.put(\"ikg\", \"Informatik, Kultur und Gesundheit\");\nSystem.out.println(studieng\u00e4nge.get(\"ai\").toUpperCase());\nSystem.out.println(studieng\u00e4nge.get(\"wi\").toUpperCase());\n</code></pre> <p>Dann w\u00fcrde in Zeile <code>7</code> eine <code>NullPointerException</code> geworfen, das die <code>get(key)</code>-Methode aus <code>Map</code> eine <code>null</code> zur\u00fcckgibt, falls der Schl\u00fcssel <code>key</code> nicht in der <code>Map</code> existiert. Prinzipiell m\u00fcsste deshalb die <code>get()</code>-Methode aus <code>Map</code> entweder in einen <code>try-catch</code>-Block eingebettet oder vorab die <code>containsKey(key)</code>-Methode aufgerufen werden. </p> <p>Der folgende Code zeigt eine m\u00f6gliche Implementierung f\u00fcr das Auslesen eines Wertes aus einer <code>Map</code> unter Verwendung von <code>Optional&lt;T&gt;</code>:</p> <pre><code>public static Optional&lt;String&gt; getValue(Map&lt;String, String&gt; sgs, String key) {\n    if (sgs.containsKey(key))\n    {\n        return Optional.of(sgs.get(key));\n    }\n    return Optional.empty();\n}\n</code></pre> <p>Zun\u00e4chst wird gepr\u00fcft, ob der Schl\u00fcssel <code>key</code> in der Map <code>sgs</code> \u00fcberhaupt existiert. Wenn nicht, wird ein leeres Optional  (<code>Optional.empty()</code>) zur\u00fcckgegeben. Wenn doch, ermitteln wir mithilfe der <code>get(key)</code>-Methode aus <code>Map</code> den Wert und geben diesen mithilfe von <code>Optional.of()</code> zur\u00fcck. </p> <p>Die aufrufende Methode kann nun mithilfe der Objektmethode <code>isPresent()</code> ermitteln, ob ein <code>Optional</code> einen Wert enth\u00e4lt (<code>true</code>) oder nicht (<code>false</code>). Ist ein Wert vorhanden, kann dieser mithilfe der Objektmethode <code>get()</code> extrahiert werden:</p> <pre><code>Optional&lt;String&gt; optionalValue = getValue(studiengaenge, \"ai\");\nif(optionalValue.isPresent()) {\n    String value = optionalValue.get();\n    System.out.println(value);\n}\n\noptionalValue = getValue(studiengaenge, \"wi\");\nif(optionalValue.isPresent()) {\n    String value = optionalValue.get();\n    System.out.println(value);\n} else {\n    System.out.println(\"Schluessel wi nicht enthalten!\");\n}\n</code></pre> <p>Anstelle der <code>isPresent()-get()</code>-Kombination kann auch die Objektethode <code>orElse()</code> verwendet werden. Diese liefert den Wert, wenn er existiert und ansonsten den Wert, der als Parameter der Methode \u00fcbergeben wird, z.B.</p> <pre><code>System.out.println(optionalValue.orElse(\"kein Eintrag!\"));\n</code></pre> <p>Beachten Sie, dass der als Parameter \u00fcbergebene Wert vom dem Typ sein muss, mit dem das <code>Optional</code> typisiert ist (hier <code>String</code>). </p> <p>Die Methode <code>isPresent()</code> kann leicht mit der Methode <code>ifPresent()</code> verwechselt werden. Diese ist eine weitere Objektmethode von <code>Optional&lt;T&gt;</code>. <code>ifPresent()</code> erwartet jedoch einen <code>Consumer</code> als Parameterwert (<code>isPresent()</code> ist parameterlos). </p> <pre><code>optionalValue.ifPresent(System.out::println);\n</code></pre> <p>Der Wert wird ausgegeben, wenn er existiert. Ansonsten wird nichts ausgegeben. </p> <p>Die Objektmethode <code>map()</code> erwartet eine <code>Function</code> und gibt ein <code>Optional</code> zur\u00fcck, z.B. </p> <pre><code>optionalValue.map(String::toUpperCase).ifPresent(System.out::println);\n</code></pre> <p>Einen \u00dcberblick \u00fcber alle Methoden von <code>Optional&lt;T&gt;</code> erhalten Sie hier. Weitergehende Beispiele finden Sie z.B. hier.</p> <p>Beachte</p> <p>Die Verwendung von <code>Optional&lt;T&gt;</code> ist einzig daf\u00fcr gedacht, als R\u00fcckgabe einer Methode verwendet zu werden. Damit wird signalisiert, dass nicht zwingend ein Wert zur\u00fcckgegeben wird, sondern eventuell auch <code>null</code>. Wir sollten jedoch keinesfalls <code>null</code> zur\u00fcckgeben, sondern stattdessen <code>Optional&lt;T&gt;</code> verwenden. Als Parametertyp oder als Typ von Obejktvariablen ist <code>Optional</code> jedoch nicht geeignet. </p>"},{"location":"optionals/#optionalint-optionaldouble-optionallong","title":"<code>OptionalInt</code>, <code>OptionalDouble</code>, <code>OptionalLong</code>","text":"<p>So, wie es f\u00fcr Stream noch die speziellen Streams  <ul> <li>IntStream, </li> <li>DoubleStream und </li> <li>LongStream </li> </ul> <p>gibt, gibt es auch f\u00fcr Optional noch die speziellen Optionals  <ul> <li>OptionalInt, </li> <li>OptionalDouble und</li> <li>OptionalLong. </li> </ul> <p>Anstelle der <code>get()</code>-Methode aus <code>Stream&lt;T&gt;</code> existiert f\u00fcr diese speziellen Klassen die Methode <code>getAsInt()</code> bzw. <code>getAsDouble()</code> bzw. <code>getAsLong()</code>. </p>"},{"location":"streams/","title":"Streams","text":"<p>Die Java Streams API erm\u00f6glicht die Erzeugung, Manipulation und Verwendung eines \"Stroms\" von Objekten. W\u00e4hrend Collections zum Speichern von Objekten verwendet werden, wird die Java Streams API zur Verarbeitung dieser Objekte verwendet, speichert die Objekte selbst jedoch nicht. </p> <ul> <li>Ein Stream ist keine Datenstruktur, sondern ein Stream erh\u00e4lt Input von Collections, Arrays, Dateien usw.</li> <li>Streams ver\u00e4ndern nicht die Datenstruktur, aus der sie stammen, sondern erzeugen ein Resultat, indem Operationen verkettet werden.</li> <li>Intermediate Operations erzeugen selbst wieder einen Stream. Dadurch k\u00f6nnen intermediate operations verkettet werden.</li> <li>Terminal Operations sind am Ende eines Streams und erzeugen das Resultat.</li> </ul> <p></p> <p>Es gibt also zwei Arten von Operationen in Streams </p> <ul> <li>Terminal Operations und  </li> <li>Intermediate Operations.</li> </ul> intermediate operations terminal operations return Stream \u00a0return non-stream Werte \u00a0k\u00f6nnen verkettet werden \u00a0k\u00f6nnen nicht verkettet werden \u00a0eine Stream-Pipeline kann mehrere intermedi\u00e4re Operationen enthalten \u00a0eine Stream-Pipeline enth\u00e4lt genau eine terminal Operation am Ende. \u00a0intermedi\u00e4re Operationen werden ausgef\u00fchrt, wenn die terminale Operation aufgerufen wird (lazy loading) \u00a0terminale Operationen triggern die Abarbeitung des Streams (eagerly loaded) \u00a0produzieren kein finales Ergebnis \u00a0produzieren das finale Ergebnis der Stream-Pipeline \u00a0Beispiele: <code>filter()</code>, <code>map()</code>, <code>distinct()</code>, <code>sorted()</code>, <code>limit()</code>, <code>skip()</code> \u00a0Beispiele: <code>forEach()</code>, <code>toArray()</code>, <code>reduce()</code>, <code>collect()</code>, <code>min()</code>, <code>max()</code>, <code>count()</code>, <code>anyMatch()</code>, <code>allMatch()</code>, <code>noneMatch()</code>, <code>findFirst()</code>, <code>findAny()</code> <p>Bevor wir uns die einzelnen Operationen n\u00e4her anschauen, betrachten wir zun\u00e4chst einige Beispiele, um eine Gef\u00fchl f\u00fcr Streams zu bekommen:</p>"},{"location":"streams/#maximum-einer-liste-von-zahlen-berechnen","title":"Maximum einer Liste von Zahlen berechnen","text":"<pre><code>List&lt;Integer&gt; age = Arrays.asList(12, 4, 16, 5, 27);\n\nint maxAge = age.stream()\n        .mapToInt(Integer::intValue)\n        .max()\n        .orElse(-1);\nSystem.out.println(\"Max age is: \" + maxAge);    // 27\n</code></pre>"},{"location":"streams/#produkt-einer-liste-von-zahlen-berechnen","title":"Produkt einer Liste von Zahlen berechnen","text":"<pre><code>List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\nint product = numList.stream()\n        .reduce(1, (a, b) -&gt; a * b);\nSystem.out.println(\"Product: \" + product);      // 5040\n</code></pre>"},{"location":"streams/#doppelungen-in-einer-liste-von-zahlen-entfernen","title":"Doppelungen in einer Liste von Zahlen entfernen","text":"<pre><code>List&lt;Integer&gt; age = Arrays.asList(12, 22, 12, 27, 31, 45, 31, 31, 51);\nList&lt;Integer&gt; distinctAge = age.stream()\n        .distinct()\n        .collect(Collectors.toList());\nSystem.out.println(\"Distinct Age List: \" + distinctAge);    // [12, 22, 27, 31, 45, 51]\n</code></pre>"},{"location":"streams/#summe-aller-geraden-zahlen-aus-einer-liste-berechnen","title":"Summe aller geraden Zahlen aus einer Liste berechnen","text":"<pre><code>List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\nint evenSum = numList.stream()\n        .filter(n -&gt; n%2 == 0)\n        .mapToInt(Integer::intValue)\n        .sum();\nSystem.out.println(\"Sum of even numbers: \" + evenSum);      // 20\n</code></pre>"},{"location":"streams/#summe-und-durchschnitt-einer-liste-von-zahlen-berechnen","title":"Summe und Durchschnitt einer Liste von Zahlen berechnen","text":"<pre><code>List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\nint sum = numList.stream()\n        .mapToInt(Integer::intValue)\n        .sum();\ndouble average = numList.stream()\n        .mapToDouble(Integer::doubleValue)\n        .average()\n        .getAsDouble();\nSystem.out.printf(\"Sum : %d and Average: %f\",sum,average);  // 28 and 4.0\n</code></pre>"},{"location":"streams/#streams-erzeugen","title":"Streams erzeugen","text":""},{"location":"streams/#stream","title":"<code>stream()</code>","text":"<p>In allen obigen Beispielen werden die Streams mithilfe von <code>stream()</code> erzeugt. Diese Methode wird durch das Interface Collection zur Verf\u00fcgung gestellt und l\u00e4sst sich immer dort anwenden, wo aus einer Collection (<code>List</code>, <code>Set</code>, <code>Map</code>, ...) ein Stream erzeugt werden soll. Ein einfaches Beispiel (sihe aber auch oben) ist</p> <pre><code>List&lt;String&gt; l1 = List.of(\"eins\", \"zwei\", \"drei\", \"vier\", \"fuenf\");\nStream&lt;String&gt; s1 = l1.stream();\ns1.forEach(System.out::println);        // eins \\n zwei \\n drei \\n vier \\n fuenf \\n\n</code></pre> <p>Die Methode <code>stream()</code> existiert nicht nur f\u00fcr Collections, sondern auch f\u00fcr Arrays. Dort ist sie aber eine statische Methode, die ein Array erwartet:</p> <pre><code>String[] array = {\"a\", \"b\", \"c\"};\nStream&lt;String&gt; stream = Arrays.stream(array);\n</code></pre> <p>Neben <code>stream()</code> gibt es noch weitere Stream-erzeugende Methoden, die wir hier kurz betrachten wollen:</p>"},{"location":"streams/#streamof","title":"<code>Stream.of()</code>","text":"<p>Die statische <code>of()</code>-Methode aus Stream erwartet ein oder mehrere Elemente, die als Stream zur\u00fcckgegeben werden, z.B.:</p> <pre><code>Stream&lt;String&gt; s2 = Stream.of(\"eins\", \"zwei\", \"drei\", \"vier\", \"fuenf\");\ns2.forEach(System.out::println);        // eins \\n zwei \\n drei \\n vier \\n fuenf \\n\n</code></pre>"},{"location":"streams/#streamgenerate","title":"<code>Stream.generate()</code>","text":"<p>Die statische <code>generate()</code>-Methode aus Stream erwartet einen <code>Supplier</code> und erzeugt daraus einen undendlichen Stream, z.B.:</p> <pre><code>Random random = new Random();\nStream&lt;Integer&gt; s3 = Stream.generate(random::nextInt);\ns3.forEach(System.out::println);     // hoert nicht auf !!!\n</code></pre> <p>Eine einfache M\u00f6glichkeit, die Anzahl der erzeugten Objekte zu begrenzen, ist die Verwendung der Methode <code>limit(long)</code> aus Stream, z.B.:</p> <pre><code>Random random = new Random();\nStream&lt;Integer&gt; s3 = Stream.generate(random::nextInt).limit(10);\ns3.forEach(System.out::println);     // 10 zufaellig erzeugte int-Werte\n</code></pre>"},{"location":"streams/#streamiterate","title":"<code>Stream.iterate()</code>","text":"<p>Die statische <code>iterate()</code>-Methode aus Stream erwartet zwei Parameter: einen sogenannten <code>seed</code> und eine Funktion <code>f</code> (einen UnaryOperator aus <code>java.util.function</code>). Die Idee ist, dass iterativ die Funktion <code>f</code> auf <code>seed</code> angewendet wird, d.h.:</p> <ol> <li><code>f(seed)</code>,</li> <li><code>f(f(seed))</code>, </li> <li><code>f(f(f(seed)))</code>,</li> <li>...</li> </ol> <pre><code>Stream&lt;Integer&gt; s4 = Stream.iterate(0, n -&gt; n + 2);\ns4.forEach(System.out::println);    // hoert nicht auf, gerade positive Zahlen zu erzeugen !!!\n</code></pre> <p>Auch hier kann z.B. wieder <code>limit(long)</code> helfen, um den Stream zu begrenzen:</p> <pre><code>Stream&lt;Integer&gt; s4 = Stream.iterate(0, n -&gt; n + 2).limit(10);\ns4.forEach(System.out::println);    // 0 2 4 6 8 10 12 14 16 18\n</code></pre>"},{"location":"streams/#intermediate-operations","title":"Intermediate Operations","text":"<p>Wir haben in den Beispielen bereits einige Beispiele f\u00fcr intermediate operations gesehen. Folgende Tabelle gibt einen \u00dcberblick \u00fcber einige der meistverwendeten intermediate operations. Intermediate Operations</p> <ul> <li>k\u00f6nnen miteinander \"verkettet\" werden,</li> <li>erwarten einen Stream und erzeugen einen einen Stream, d.h. sie transformieren einen Stream in einen anderen.</li> </ul> Operation Bedeutung Wirkung <code>map(Function mapper)</code> Wendet auf alle Elemente (Objekte) des Streams die <code>mapper</code>-Funktion an. \u00c4ndert die Anzahl der Objekte des Streams nicht. <code>filter(Predicate predicate)</code> Filtert aus einem Stream alle die Objekte, f\u00fcr die <code>predicate</code> den Wert <code>true</code> hat. \u00c4ndert die Anzahl der Objekte und gibt nur die Objekte als Stream weiter, f\u00fcr die das <code>predicate</code> gilt. <code>sorted(Comparator comparator)</code> Sortiert alle Elemente (Objekte) eines Streams wie durch <code>comparator</code> vorgegeben. Gibt es auch als <code>sorted()</code>, dann wird <code>Comparable</code> genutzt. Anzahl der Objekte bleibt gleich, Ausgabestream sortiert. <code>distinct()</code> Entfernt alle doppelten Elemente (Objekte) aus dem Stream. Doppelungen werden mittels <code>equals()</code> erkannt. \u00c4ndert die Anzahl der Objekte, jedes Objekt kommt im Ausgabestream nur noch einmal vor. <code>peek(Consumer action)</code> Wendet eine <code>action</code> auf alle Elemente (Objekte) eines Streams an. Im Unterschied zu <code>map()</code> werden hier die Elemente nicht ver\u00e4ndert. \u00c4ndert die Anzahl der Elemente nicht. <code>flatMap(Function mapper)</code> Wird typischerweise daf\u00fcr eingesetzt, um aus einem Stream von Collections einen Stream aller Elemente dieser Collections zu erzeugen. \u00c4ndert nicht die Gesamtanzahl der involvierten Objekte. Aus einem Collections-Stream wird eine Elemente-Stream. <p>Wir betrachten die genannten intermedi\u00e4ren Operationen an Beispielen, um ein Verst\u00e4ndnis dar\u00fcber zu erlangen:</p>"},{"location":"streams/#mapfunction-mapper","title":"<code>map(Function mapper)</code>","text":"<p>Die Methode <code>map()</code> erwartet einen Stream und gibt einen Stream mit gleich vielen Elementen weiter, ersetzt jedoch alle eingehenden Elemente unter Anwendung einer Funktion:</p> <p>Was wird ausgegeben?</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nArrays.stream(numbers)\n        .map(x -&gt; x * x)\n        .forEach(System.out::println);\n</code></pre> <p>Was wird ausgegeben?</p> <pre><code>List&lt;String&gt; words = List.of(\"eins\", \"zwei\", \"drei\", \"vier\", \"fuenf\");\nwords.stream()\n        .map(x -&gt; x.toUpperCase())\n        .forEach(System.out::println);\n</code></pre> <p>Was wird ausgegeben?</p> <pre><code>List&lt;String&gt; words = List.of(\"abc\", \"a\", \"abcd\", \"abcde\", \"ab\");\nwords.stream()\n        .map(x -&gt; x.length())\n        .sorted()\n        .forEach(System.out::println);\n</code></pre> <p>Was wird ausgegeben? - Beachten Sie die Reihenfolge der Ausgaben!</p> <pre><code>public record Rectangle(int width, int length)\n{\n    public int area()\n    {\n        return this.width * this.length;\n    }\n}\nSet&lt;Rectangle&gt; rectangles = new HashSet&lt;&gt;();\nrectangles.add(new Rectangle(1, 2));\nrectangles.add(new Rectangle(3, 2));\nrectangles.add(new Rectangle(1, 4));\nrectangles.add(new Rectangle(3, 4));\nrectangles.add(new Rectangle(2, 5));\nrectangles.add(new Rectangle(4, 2));\nrectangles.stream()\n        .peek(s -&gt; System.out.println(s.length() + \" x \" + s.width() + \" = \" + s.area()))\n        .map(x -&gt; x.area())\n        .peek(r -&gt; System.out.println(r))\n        .filter(x -&gt; x &lt; 5)\n        .forEach(System.out::println);\n</code></pre>"},{"location":"streams/#filterpredicate-predicate","title":"<code>filter(Predicate predicate)</code>","text":"<p>Die Methode <code>filter()</code> erwartet einen Stream und gibt einen Stream weiter, l\u00e4sst jedoch nur die Elemente durch, f\u00fcr die das <code>predicate</code> den Wert <code>true</code> ergibt. Die Elemente selbst bleiben unver\u00e4ndert:</p> <p>Was wird ausgegeben?</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nArrays.stream(numbers)\n        .filter(x -&gt; x %2 == 0)\n        .forEach(System.out::println);\n</code></pre> <p>Was wird ausgegeben?</p> <pre><code>List&lt;String&gt; l1 = List.of(\"abc\", \"a\", \"abcd\", \"abcde\", \"ab\");\nl1.stream()\n        .filter(x -&gt; x.length() &lt; 3)\n        .forEach(System.out::println);\n</code></pre> <p>Was wird ausgegeben?</p> <pre><code>Stream&lt;String&gt; s2 = Stream.of(\"eins\", \"zwei\", \"drei\", \"vier\", \"fuenf\");\ns2.filter(x -&gt; x.contains(\"ei\"))\n  .forEach(System.out::println);\n</code></pre>"},{"location":"streams/#sortedcomparator-comparator","title":"<code>sorted(Comparator comparator)</code>","text":"<p>Es gibt auch eine Methode <code>sorted()</code>. Diese kann auf Klassen angewendet werden, die das Comparable-Interface implementiert haben (z.B. String, alle Wrapper-Klassen usw.). Es wird die <code>compareTo()</code>-Methode verwendet, um die Elemente zu sortieren. Mit der Methode <code>sorted(Comparator comparator)</code> kann ein eigener Comparator implementiert werden. Dabei handelt es sich um ein Functional Interface mit der SAM <code>int compare(T o1, T o2)</code>.</p> <p>Es gibt verschiedene M\u00f6glichkeiten, Comparator anzuwenden (siehe auch \u00dcbung 9). Eine ist, die statischen Methoden des Interfaces zu verwenden, z.B. <code>Comparator.comparingInt(ToIntFunction keyExtractor)</code> (es gibt auch <code>comparingDouble(), comparingLong()</code>):</p> <p>Was wird ausgegeben? - Beachten Sie die Reihenfolge der Ausgaben!</p> <pre><code>public record Rectangle(int width, int length)\n{\n    public int area()\n    {\n        return this.width * this.length;\n    }\n}\nSet&lt;Rectangle&gt; rectangles = new HashSet&lt;&gt;();\nrectangles.add(new Rectangle(1, 2));\nrectangles.add(new Rectangle(3, 2));\nrectangles.add(new Rectangle(1, 4));\nrectangles.add(new Rectangle(3, 4));\nrectangles.add(new Rectangle(2, 5));\nrectangles.add(new Rectangle(4, 2));\nrectangles.stream()\n            .sorted(Comparator.comparingInt(Rectangle::area))\n            .forEach(System.out::println);\n</code></pre>"},{"location":"streams/#terminal-operations","title":"Terminal Operations","text":"<p>Terminal Operations beenden die Stream-Pipeline (und triggern die Ausf\u00fchrung der gesamten Stream-Pipeline). Terminal Operations liefern den Wert der Berechnung. Zu einer Stream-Pipeline  geh\u00f6rt genau eine terminale Operation (am Ende). F\u00fcr die folgenden Beispiele nehmen wir an, wir h\u00e4tten folgende Klasse (<code>record</code>) <code>Person</code>:</p> <pre><code>public record Person(String name, String stadt){\n    @Override\n    public String toString()\n    {\n        return String.format(\"%s aus %s\", name, stadt);\n    }\n}\n</code></pre> <p>und definieren folgende Liste <code>personen</code>:</p> <pre><code>List&lt;Person&gt; personen = List.of(\n        new Person(\"Alice\", \"Ankara\"),\n        new Person(\"Alice\", \"Caracas\"),\n        new Person(\"Barbara\", \"Bern\"),\n        new Person(\"Barbara\", \"Damaskus\"),\n        new Person(\"Conny\", \"Caracas\"),\n        new Person(\"Conny\", \"Bern\"),\n        new Person(\"Daniela\", \"Damaskus\"),\n        new Person(\"Daniela\", \"Caracas\"),\n        new Person(\"Elvira\",\"Bern\" ),\n        new Person(\"Elvira\",\"Ankara\" ),\n        new Person(\"Frieda\", \"Caracas\"),\n        new Person(\"Gerda\", \"Ankara\"),\n        new Person(\"Hannah\", \"Hanoi\"),\n        new Person(\"Ina\", \"Islamabad\"),\n        new Person(\"Jana\", \"Hanoi\")\n        );\n</code></pre> <p>Wir betrachten Beispiele einiger terminaler Operationen:</p>"},{"location":"streams/#foreachconsumer-action","title":"<code>forEach(Consumer action)</code>","text":"<p>Die <code>forEach()</code>-Methode kommt im Interface Stream, aber auch im Interface Iterable vor, welches von Listen und Mengen implementiert ist. <code>forEach()</code> erwartet einen Consumer, also eine Funktion, die ein Parameter erwartet und nichts zur\u00fcckgibt (also z.B. <code>System.out::println</code>). <p>Da es sich bei <code>personen</code> um eine Liste handelt, k\u00f6nnen wir <code>forEach()</code> direkt f\u00fcr die Liste aufrufen, das hat dann aber nichts mit Streams zu tun (sondern mit <code>Iterable</code>):</p> <pre><code>personen.forEach(System.out::println);\npersonen.forEach(p -&gt; System.out.println(p.name()));\n</code></pre> <p>F\u00fcr <code>Stream</code> erhalten wir aber genau die gleiche Ausgabe:</p> <pre><code>personen.stream().forEach(System.out::println);\npersonen.stream().forEach(p -&gt; System.out.println(p.name()));\n</code></pre> <p>Mit Streams  sind wir dann aber flexibler f\u00fcr intermediate operations, z.B. um doppelte Namen herauszufiltern:</p> <pre><code>personen.stream()\n        .map(p -&gt; p.name())\n        .distinct()\n        .forEach(System.out::println);\n</code></pre> <p>Werden doppelte Namen ausgegeben (J/N)?</p> <pre><code>personen.stream()\n        .distinct()\n        .forEach(p -&gt; System.out.println(p.name()));\n</code></pre>"},{"location":"streams/#reducet-identity-binaryoperatort-accumulator","title":"<code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>","text":"<p>Die Methode reduce() geh\u00f6rt zu den reduction operations (auch fold genannt). reduction operations erwarten eine Sequenz von Input-Elementen (einen Stream) und kombinieren diese zu einem einzigen Wert. Der <code>reduce()</code>-Methode wird eine Funktion (BinaryOperator) \u00fcbergeben. Diese Funktion wird auf jedes einzelne Element angewendet und zu einem Result akkumuliert. Das Prinzip ist wie folgt:</p> <pre><code>     T result = identity;\n     for (T element : this stream)\n         result = accumulator.apply(result, element)\n     return result;\n</code></pre> <p>Was wird ausgegeben?</p> <pre><code>    int[] numbers = {1, 2, 3, 4};\n    int result = Arrays.stream(numbers1).reduce(0, (x, y) -&gt; (x + y));\n    System.out.println(\"result = \" + result);\n</code></pre> <p>Was wird ausgegeben?</p> <pre><code>    int[] numbers = {1, 2, 3, 4};\n    int result = Arrays.stream(numbers1).reduce(1, (x, y) -&gt; (x * y));\n    System.out.println(\"result = \" + result);\n</code></pre>"},{"location":"streams/#collectcollector-collector","title":"<code>collect(Collector&lt;&gt; collector)</code>","text":"<p>Die Methode <code>collect()</code> geh\u00f6rt ebenfalls zu den reduction operations. Das Ergebnis von <code>collect()</code> ist typischerweise eine Collection.  Wir k\u00f6nnen mithilfe von <code>collect()</code> z.B. eine einfache Liste der Namen der Personen (siehe oben) erstellen:</p> <pre><code>List&lt;String&gt; namensListe = personen.stream()\n    .map(p -&gt; p.name())\n    .collect(Collectors.toList());\n</code></pre> <p>Wir k\u00f6nnen auch angeben, dass eine <code>Set</code> erzeugt werden soll. Diese enth\u00e4lt (im Gegensatz zur Liste) keine Doppelungen:</p> <pre><code>Set&lt;String&gt; namensSet = personen.stream()\n        .map(p -&gt; p.name())\n        .collect(Collectors.toCollection(TreeSet::new));\n</code></pre> Erstellen Sie eine <code>HashSet</code>, die alle St\u00e4dte aus <code>personen</code> enth\u00e4lt und geben Sie diese aus! <pre><code>Set&lt;String&gt; stadtSet = personen.stream()\n        .map(p -&gt; p.stadt())\n        .collect(Collectors.toCollection(HashSet::new));\nstadtSet.forEach(System.out::println);\n</code></pre> <p>Unter Verwendung von <code>Collector.groupingBy()</code> kann eine <code>Map</code> erstellt werden, deren Schl\u00fcssel dem angegebenen <code>groupingBy</code>-Element entspricht:</p> <pre><code>Map&lt;String, List&lt;Person&gt;&gt; personenStadt\n        = personen.stream()\n        .collect(\n            Collectors.groupingBy(\n                Person::stadt\n            )\n        );\npersonenStadt.entrySet().stream().forEach(System.out::println);\n</code></pre> <p>Ausgabe: </p> <pre><code>Bern=[Barbara aus Bern, Conny aus Bern, Elvira aus Bern]\nCaracas=[Alice aus Caracas, Conny aus Caracas, Daniela aus Caracas, Frieda aus Caracas]\nAnkara=[Alice aus Ankara, Elvira aus Ankara, Gerda aus Ankara]\nHanoi=[Hannah aus Hanoi, Jana aus Hanoi]\nIslamabad=[Ina aus Islamabad]\nDamaskus=[Barbara aus Damaskus, Daniela aus Damaskus]\n</code></pre> <p>Das kann dann sogar nochmal beliebig verschachtelt werden, z.B.:</p> <pre><code>Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; personenStadtName\n        = personen.stream()\n        .collect(\n            Collectors.groupingBy(\n                Person::name,\n                Collectors.groupingBy(\n                    Person::stadt\n                )\n            )\n        );\npersonenStadtName.entrySet().stream().forEach(System.out::println);\n</code></pre> <p>Ausgabe: </p> <pre><code>Barbara={Bern=[Barbara aus Bern], Damaskus=[Barbara aus Damaskus]}\nAlice={Caracas=[Alice aus Caracas], Ankara=[Alice aus Ankara]}\nHannah={Hanoi=[Hannah aus Hanoi]}\nJana={Hanoi=[Jana aus Hanoi]}\nGerda={Ankara=[Gerda aus Ankara]}\nConny={Bern=[Conny aus Bern], Caracas=[Conny aus Caracas]}\nIna={Islamabad=[Ina aus Islamabad]}\nElvira={Bern=[Elvira aus Bern], Ankara=[Elvira aus Ankara]}\nFrieda={Caracas=[Frieda aus Caracas]}\nDaniela={Caracas=[Daniela aus Caracas], Damaskus=[Daniela aus Damaskus]}\n</code></pre> <p>Es wird also nach <code>name</code> gruppiert und in jeder Namensgruppe dann nochmal nach <code>stadt</code>. Um nur die Namen nach St\u00e4dten zu gruppieren, kann bspw. </p> <pre><code>Map&lt;String, List&lt;String&gt;&gt; personenNameStaedte\n        = personen.stream()\n        .collect(Collectors.groupingBy(\n                Person::name,\n                Collectors.mapping(\n                        Person::stadt,\n                        Collectors.toList())));\npersonenNameStaedte.entrySet().stream().forEach(System.out::println);\n</code></pre> <p>Ausgabe: </p> <pre><code>Barbara=[Bern, Damaskus]\nAlice=[Ankara, Caracas]\nHannah=[Hanoi]\nJana=[Hanoi]\nGerda=[Ankara]\nConny=[Caracas, Bern]\nIna=[Islamabad]\nElvira=[Bern, Ankara]\nFrieda=[Caracas]\nDaniela=[Damaskus, Caracas]\n</code></pre> <p>verwendet werden. <code>Collector.groupingBy()</code> erwartet also entweder </p> <ul> <li>1 Parameter (<code>Function classifier</code>), um in einer <code>Function</code> anzugeben, wonach gruppiert werden soll (z.B. <code>Person::stadt</code>) oder</li> <li>2 Parameter (<code>Function classifier</code> und <code>Collector downstream</code>), um einerseits in einer <code>Function</code> anzugeben, wonach gruppiert werden soll und andererseits einen weiteren kaskadierenden <code>Collector</code> f\u00fcr eine \"innere\" Gruppierung anzugeben. </li> </ul> <p>Es gibt noch eine Implementierung mit 3 Parametern (siehe Collectors), aber 1-2 gen\u00fcgen uns bereits .</p>"},{"location":"streams/#allmatchpredicatet-p-anymatchpredicatet-p","title":"<code>allMatch(Predicate&lt;T&gt; p)</code>, <code>anyMatch(Predicate&lt;T&gt; p)</code>","text":"<p>Den Methoden <code>allMatch(Predicate p)</code> und <code>anyMatch(Predicate p)</code> wird ein Predicate \u00fcbergeben und sie geben ein <code>boolean</code> zur\u00fcck. Ein <code>Predicate</code> ist eine Funktion \u00fcber einen Parameter, die ein <code>boolean</code> zur\u00fcckgibt.</p> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 20);\nboolean answer = list.stream().allMatch(n-&gt; n % 3 ==0);\n</code></pre> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 21);\nboolean answer = list.stream().allMatch(n-&gt; n % 3 ==0);\n</code></pre> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 20);\nboolean answer = list.stream().anyMatch(n-&gt; n % 3 ==0);\n</code></pre>"},{"location":"streams/#mincomparatort-c-maxcomparatort-c","title":"<code>min(Comparator&lt;T&gt; c)</code>, <code>max(Comparator&lt;T&gt; c)</code>","text":"<p>Den Methoden <code>min(Comparator&lt;T&gt; c)</code> und <code>max(Comparator&lt;T&gt; c)</code> wird ein Comparator \u00fcbergeben und sie geben das \"kleinste\" bzw. \"gr\u00f6\u00dfte\" Element aus dem Stream zur\u00fcck. Ein <code>Comparator</code> ist eine Funktion \u00fcber zwei Parameter, die ein <code>int</code> zur\u00fcckgibt. Die SAM des Interfaces <code>Comparator</code> ist <code>compare(T o1, T o2)</code> und hat die gleiche Bedeutung, wie <code>compareTo()</code> aus <code>Comparable</code>, d.h. wenn <code>o1</code> \"gr\u00f6\u00dfer\" ist als <code>o2</code>, dann ist der R\u00fcckgabewert von <code>compare() &gt; 0</code>.</p> <p>Beachten Sie, dass <code>min()</code> und <code>max()</code> tats\u00e4chlich ein Optional zur\u00fcckgeben, d.h. der Wert k\u00f6nnte auch <code>null</code> sein. Wir m\u00fcssen deshalb stets noch z.B. <code>get()</code> f\u00fcr das zur\u00fcckgegebene <code>Optional</code> aufrufen. Diese Funktion gibt den Wert zur\u00fcck, wenn er existiert (ansonsten wird eine <code>NoSuchElementException</code> geworfen). <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 20);\nint answer = list.stream().min((a,b) -&gt; a - b).get();\n</code></pre> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>Person answer = personen.stream().min((a,b) -&gt; a.name().compareTo(b.name())).get();\n</code></pre> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>Person answer = personen.stream().max((a,b) -&gt; a.stadt().length() - b.stadt().length()).get();\n</code></pre> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 20);\nint answer = list.stream().max((a,b) -&gt; a % 4 - b % 4).get();\n</code></pre>"},{"location":"streams/#sum-average-count","title":"<code>sum()</code>, <code>average()</code>, <code>count()</code>","text":"<p>Die Methoden <code>sum()</code>, <code>average()</code>, <code>count()</code> sind Methoden aus dem Interface IntStream. Die Methode <code>count()</code> gibt es aber auch bereits in <code>Stream</code>. Neben <code>IntStream</code> gibt es auch <code>DoubleStream</code> und <code>LongStream</code>. In allen drei Stream-Arten kommen die hier diskutierten Methoden vor. Wir zeigen aber alles am Beispiel von <code>IntStream</code>.</p> <p>Aus einem Stream k\u00f6nnen wir mithilfe von <code>mapToInt()</code> oder <code>flatMapToInt()</code> einen <code>IntStream</code> erzeugen. Beide Methoden erwarten als Parameter eine ToIntFunction. Diese besitzt als SAM die Methode <code>applyAsInt(T value)</code> und gibt einen <code>int</code> zur\u00fcck. </p> <p>Die Methode <code>sum()</code> gibt ein <code>int</code> zur\u00fcck, <code>count()</code> ein <code>long</code> und <code>average()</code> ein OptionalDouble, dessen <code>double</code>-Wert wir durch <code>getAsDouble()</code> erhalten k\u00f6nnen. </p> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 4, 5, 6);\nint answer = list.stream().mapToInt(p -&gt; p).sum();      // int\n</code></pre> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>long answer = list.stream().count();                    // long\n</code></pre> <p>Welchen Wert hat <code>answer</code>?</p> <pre><code>double answer = list.stream().mapToInt(p -&gt; p).average().getAsDouble();  // double\n</code></pre>"},{"location":"streams/#typische-fehler-mit-streams","title":"Typische Fehler mit Streams","text":"<p>Jetzt noch einige Empfehlungen, um typische Fehler mit Streams zu vermeiden (siehe z.B. hier). </p>"},{"location":"streams/#ein-stream-ist-nur-einmal-terminierbar","title":"Ein Stream ist nur einmal terminierbar","text":"<p>Jeder Stream kann nur einmal terminiert werden. Folgender Code f\u00fchrt deshalb zu einem Fehler:</p> <p>Fehler</p> <pre><code>    List&lt;String&gt; fruits = Arrays.asList(\"apple\", \"banana\", \"orange\", \"mango\");\n\n    // create a stream\n    Stream&lt;String&gt; fruitStream = fruits.stream();\n\n    // count() is terminal operation - closes the stream\n    long count = fruitStream.count();\n    System.out.println(\"Number of fruits: \" + count);\n\n    // try to reuse the same stream - this will fail!\n    List&lt;String&gt; upperCaseFruits = fruitStream\n            .map(String::toUpperCase)\n            .collect(Collectors.toList());\n</code></pre> <p>Es wird eine <code>IllegalStateException</code> geworfen:</p> <pre><code>Exception in thread \"main\" java.lang.IllegalStateException: stream has already been operated upon or closed\n</code></pre> <p>Richtig</p> <pre><code>    List&lt;String&gt; fruits = Arrays.asList(\"apple\", \"banana\", \"orange\", \"mango\");\n\n    // eigener Stream fuer count()\n    long count = fruits.stream().count();\n    System.out.println(\"Number of fruits: \" + count);\n\n    // eigener Stream fuer collect()\n    List&lt;String&gt; upperCaseFruits = fruits.stream()\n        .map(String::toUpperCase)\n        .collect(Collectors.toList());\n\n    System.out.println(\"Uppercase fruits: \" + upperCaseFruits);\n</code></pre> <p>Ausgabe:</p> <pre><code>Number of fruits: 4\nUppercase fruits: [APPLE, BANANA, ORANGE, MANGO]\n</code></pre>"},{"location":"streams/#nebenlaufiges-andern-wahrend-der-iteration","title":"Nebenl\u00e4ufiges \u00c4ndern w\u00e4hrend der Iteration","text":"<p>Wenn wir aus einer <code>Collection</code> einen Stream erzeugen, darf die <code>Collection</code> nicht ge\u00e4ndert werden, w\u00e4hrend wir den Stream abarbeiten. Beispielsweise f\u00fchrt folgender Code zu einem Fehler:</p> <p>Fehler</p> <pre><code>    List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));\n\n    // nicht die Collection aendern, waehrend der Stream abgearbeitet wird!\n    numbers.stream().forEach(number -&gt; {\n        if (number % 2 == 0) {\n            numbers1.add(number * 2);\n        }\n    });\n</code></pre> <p>Es wird eine <code>ConcurrentModificationException</code> geworfen:</p> <pre><code>Exception in thread \"main\" java.util.ConcurrentModificationException\n</code></pre> <p>Richtig</p> <pre><code>    List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));\n\n    // neue Collection mit den gewuenschten Aenderungen erzeugen \n    List&lt;Integer&gt; modifiedNumbers = numbers.stream()\n        .flatMap(number -&gt; {\n            if (number % 2 == 0) {\n                return Stream.of(number, number * 2);\n            }\n            return Stream.of(number);\n        })\n        .collect(Collectors.toList());\n\n    System.out.println(\"Original numbers: \" + numbers);\n    System.out.println(\"Modified numbers: \" + modifiedNumbers);\n</code></pre> <p>Ausgabe:</p> <pre><code>Original numbers: [1, 2, 3, 4, 5]\nModified numbers: [1, 2, 4, 3, 4, 8, 5]\n</code></pre>"},{"location":"streams/#optionale-werte-behandeln","title":"Optionale Werte behandeln","text":"<p>Wenn wir keine <code>Optional</code> Werte behandeln, k\u00f6nnen wir <code>NullPointerException</code> oder <code>NoSuchElementException</code> riskieren:</p> <p>Fehler</p> <pre><code>    List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Bob\");\n\n    // keine Optional-Behandlung!\n    String firstLongName = names.stream()\n            .filter(name -&gt; name.length() &gt; 10)\n            .findFirst()\n            .get();     // wirft NoSuchElementException\n</code></pre> <p>Es wird eine <code>NoSuchElementException</code> geworfen:</p> <pre><code>Exception in thread \"main\" java.util.NoSuchElementException: No value present\n    at java.base/java.util.Optional.get(Optional.java:xxx)\n</code></pre> <p>Richtig</p> <pre><code>    List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Bob\");\n\n    // orElse\n    String firstLongName = names.stream()\n            .filter(name -&gt; name.length() &gt; 10)\n            .findFirst()\n            .orElse(\"No long name found\");\n\n    // orElseGet - returns String \"Default name\"\n    String computedName = names.stream()\n            .filter(name -&gt; name.length() &gt; 10)\n            .findFirst()\n            .orElseGet(() -&gt; \"Default Name\");\n\n    // ifPresent  - void, prints if present \n    names.stream()\n            .filter(name -&gt; name.length() &gt; 10)\n            .findFirst()\n            .ifPresent(name -&gt; System.out.println(\"Found long name: \" + name));\n\n    // orElseThrow - wirft eigene Exception\n    try {\n        String requiredName = names.stream()\n                .filter(name -&gt; name.length() &gt; 10)\n                .findFirst()\n                .orElseThrow(() -&gt; new IllegalStateException(\"No long name found\"));\n    } catch (IllegalStateException e) {\n        System.out.println(\"Handled exception: \" + e.getMessage());\n    }\n\n    System.out.println(\"firstLongName : \" + firstLongName);\n    System.out.println(\"computedName : \" + computedName);\n</code></pre> <p>Ausgabe:</p> <pre><code>Handled exception: No long name found\nfirstLongName : No long name found\ncomputedName : Default Name\n</code></pre>"},{"location":"streams/#effiziente-operation-fur-collections-verwenden","title":"Effiziente Operation f\u00fcr Collections verwenden","text":"<p>Die Verwendung ineffizienter Operationen f\u00fcr Collections kann zu schlechter Performanz f\u00fchren. Ist nicht v\u00f6llig falsch, aber der sinnvolle Einsatz von Operationen \u00fcber Collections ist besser:</p> <p>ineffizient</p> <pre><code>    List&lt;String&gt; words = Arrays.asList(\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\");\n\n    // Inefficient way to count occurrences\n    Map&lt;String, Long&gt; wordCounts = words.stream()\n            .collect(Collectors.toMap(\n                    word -&gt; word,\n                    word -&gt; 1L,\n                    (count1, count2) -&gt; count1 + 1\n            ));\n    wordCounts.entrySet().stream().forEach(System.out::println);\n</code></pre> <p>Ausgabe:</p> <pre><code>banana=2\ncherry=1\napple=2\n</code></pre> <p>besser</p> <pre><code>    List&lt;String&gt; words = Arrays.asList(\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\");\n\n    // Efficient counting using groupingBy\n    Map&lt;String, Long&gt; wordCounts = words.stream()\n            .collect(Collectors.groupingBy(\n                    Function.identity(),\n                    Collectors.counting()\n            ));\n\n    // Efficient distinct collection\n    List&lt;String&gt; uniqueWords = words.stream()\n            .distinct()\n            .collect(Collectors.toList());\n\n    // Efficient grouping with downstream collector\n    Map&lt;Integer, List&lt;String&gt;&gt; wordsByLength = words.stream()\n            .collect(Collectors.groupingBy(\n                    String::length,\n                    Collectors.toList()\n            ));\n\n    // Efficient partitioning\n    Map&lt;Boolean, List&lt;String&gt;&gt; partitioned = words.stream()\n            .collect(Collectors.partitioningBy(\n                    word -&gt; word.length() &gt; 5\n            ));\n\n    System.out.printf(\"%n%n----------- wordCounts ---------------%n%n\");\n    wordCounts.entrySet().stream().forEach(System.out::println);\n    System.out.printf(\"%n%n----------- uniqueWords --------------%n%n\");\n    uniqueWords.stream().forEach(System.out::println);\n    System.out.printf(\"%n%n---------- wordsByLength -------------%n%n\");\n    wordsByLength.entrySet().stream().forEach(System.out::println);\n    System.out.printf(\"%n%n----------- partitioned --------------%n%n\");\n    partitioned.entrySet().stream().forEach(System.out::println);\n</code></pre> <p>Ausgabe:</p> <pre><code>----------- wordCounts ---------------\n\nbanana=2\ncherry=1\napple=2\n\n\n----------- uniqueWords --------------\n\napple\nbanana\ncherry\n\n\n---------- wordsByLength -------------\n\n5=[apple, apple]\n6=[banana, cherry, banana]\n\n\n----------- partitioned --------------\n\nfalse=[apple, apple]\ntrue=[banana, cherry, banana]\n</code></pre>"},{"location":"streams/#beispiele-streams-und-lambdas","title":"Beispiele Streams und Lambdas","text":"<p>Die folgenden Beispiele sind Medium: 50 Java 8 Lambda Snippets Every Developer Should Know entnommen. Da es ein <code>member-only article</code> ist, poste ich den Inhalt (hoffentlich legaler Weise ) hier. </p>"},{"location":"streams/#iterating-list-using-lambda","title":"Iterating List using Lambda","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nlist.forEach(item -&gt; System.out.println(item));\n</code></pre>"},{"location":"streams/#filtering-a-list-with-lambda","title":"Filtering a List with Lambda","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"JavaScript\", \"Python\");\nList&lt;String&gt; filteredList = list.stream()\n    .filter(s -&gt; s.startsWith(\"J\"))\n    .collect(Collectors.toList());\nfilteredList.forEach(System.out::println);\n</code></pre>"},{"location":"streams/#sorting-a-list-using-lambda","title":"Sorting a List using Lambda","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Lambda\", \"Kafka\");\nlist.sort((s1, s2) -&gt; s1.compareTo(s2));\nlist.forEach(System.out::println);\n</code></pre>"},{"location":"streams/#using-a-custom-functional-interface","title":"Using a Custom Functional Interface","text":"<pre><code>@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);\n}\n\npublic static void main(String[] args) {\n    Calculator add = (a, b) -&gt; a + b;\n    Calculator multiply = (a, b) -&gt; a * b;\n    System.out.println(\"Addition: \" + add.calculate(5, 3));\n    System.out.println(\"Multiplication: \" + multiply.calculate(5, 3));\n}\n</code></pre>"},{"location":"streams/#lambda-with-map-iteration","title":"Lambda with Map Iteration","text":"<pre><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"Java\", 8);\nmap.put(\"Spring\", 5);\nmap.put(\"Lambda\", 1);\nmap.forEach((key, value) -&gt; System.out.println(key + \": \" + value));\n</code></pre>"},{"location":"streams/#lambda-in-comparator","title":"Lambda in Comparator","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Lambda\", \"Kafka\");\nlist.sort(Comparator.comparingInt(String::length));\nlist.forEach(System.out::println);\n</code></pre>"},{"location":"streams/#method-reference-with-lambda","title":"Method Reference with Lambda","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Lambda\", \"Kafka\");\nlist.forEach(System.out::println);\n</code></pre>"},{"location":"streams/#lambda-with-optional","title":"Lambda with Optional","text":"<pre><code>Optional&lt;String&gt; optional = Optional.of(\"Java\");\noptional.ifPresent(s -&gt; System.out.println(\"Value is present: \" + s));\n</code></pre>"},{"location":"streams/#lambda-with-predicate","title":"Lambda with Predicate","text":"<pre><code>Predicate&lt;String&gt; isEmpty = s -&gt; s.isEmpty();\nSystem.out.println(isEmpty.test(\"\"));       // true\nSystem.out.println(isEmpty.test(\"Java\"));   // false\n</code></pre>"},{"location":"streams/#lambda-with-bifunction","title":"Lambda with BiFunction","text":"<pre><code>BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;\nSystem.out.println(add.apply(2, 3)); // 5\n</code></pre>"},{"location":"streams/#lambda-with-consumer","title":"Lambda with Consumer","text":"<pre><code>Consumer&lt;String&gt; print = s -&gt; System.out.println(s);\nprint.accept(\"Hello, World!\"); // Hello, World!\n</code></pre>"},{"location":"streams/#lambda-with-supplier","title":"Lambda with Supplier","text":"<pre><code>Supplier&lt;String&gt; supplier = () -&gt; \"Java\";\nSystem.out.println(supplier.get()); // Java\n</code></pre>"},{"location":"streams/#lambda-with-stream-sorted","title":"Lambda with Stream Sorted","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Banana\", \"Pear\", \"Grapes\");\nlist.stream()\n    .sorted()\n    .forEach(System.out::println);\n</code></pre>"},{"location":"streams/#lambda-with-stream-count","title":"Lambda with Stream Count","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nlong count = numbers.stream()\n    .count();\nSystem.out.println(\"Count: \" + count); // Count: 5\n</code></pre>"},{"location":"streams/#lambda-with-stream-anymatch","title":"Lambda with Stream AnyMatch","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nboolean containsJava = list.stream()\n    .anyMatch(s -&gt; s.equals(\"Java\"));\nSystem.out.println(\"Contains 'Java': \" + containsJava); // true\n</code></pre>"},{"location":"streams/#lambda-with-stream-allmatch","title":"Lambda with Stream AllMatch","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(2, 4, 6, 8, 10);\nboolean allEven = numbers.stream()\n    .allMatch(n -&gt; n % 2 == 0);\nSystem.out.println(\"All even: \" + allEven); // true\n</code></pre>"},{"location":"streams/#lambda-with-stream-nonematch","title":"Lambda with Stream NoneMatch","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nboolean nonePython = list.stream()\n    .noneMatch(s -&gt; s.equals(\"Python\"));\nSystem.out.println(\"Contains no 'Python': \" + nonePython); // true\n</code></pre>"},{"location":"streams/#lambda-with-stream-findfirst","title":"Lambda with Stream FindFirst","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nOptional&lt;String&gt; first = list.stream()\n    .findFirst();\nfirst.ifPresent(System.out::println); // Java\n</code></pre>"},{"location":"streams/#lambda-with-stream-findany","title":"Lambda with Stream FindAny","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nOptional&lt;String&gt; any = list.stream()\n    .findAny();\nany.ifPresent(System.out::println);\n</code></pre>"},{"location":"streams/#lambda-for-summing-integers","title":"Lambda for Summing Integers","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = numbers.stream()\n    .mapToInt(Integer::intValue)\n    .sum();\nSystem.out.println(\"Sum: \" + sum); // Sum: 15\n</code></pre>"},{"location":"streams/#lambda-for-max-integer","title":"Lambda for Max Integer","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint max = numbers.stream()\n    .mapToInt(Integer::intValue)\n    .max()\n    .orElse(Integer.MIN_VALUE);\nSystem.out.println(\"Max: \" + max); // Max: 5\n</code></pre>"},{"location":"streams/#lambda-for-min-integer","title":"Lambda for Min Integer","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint min = numbers.stream()\n    .mapToInt(Integer::intValue)\n    .min()\n    .orElse(Integer.MAX_VALUE);\nSystem.out.println(\"Min: \" + min); // Min: 1\n</code></pre>"},{"location":"streams/#lambda-for-joining-strings","title":"Lambda for Joining Strings","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nString joined = list.stream()\n    .collect(Collectors.joining(\", \"));\nSystem.out.println(joined); // Java, Spring, Lambda\n</code></pre>"},{"location":"streams/#lambda-for-joining-without-delimiter","title":"Lambda for Joining Without Delimiter","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nString joined = list.stream()\n    .collect(Collectors.joining());\nSystem.out.println(joined); // JavaSpringLambda\n</code></pre>"},{"location":"streams/#lambda-with-stream-maptoint","title":"Lambda with Stream MapToInt","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nlist.stream()\n    .mapToInt(String::length)\n    .forEach(System.out::println); // 4, 6, 6\n</code></pre>"},{"location":"streams/#lambda-with-stream-collect-to-set","title":"Lambda with Stream Collect to Set","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\", \"Spring\");\nSet&lt;String&gt; set = list.stream()\n    .collect(Collectors.toSet());\nset.forEach(System.out::println); // Java, Spring, Lambda\n</code></pre>"},{"location":"streams/#lambda-with-stream-groupingby","title":"Lambda with Stream GroupingBy","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\", \"Java\");\nMap&lt;String, Long&gt; frequency = list.stream()\n    .collect(Collectors.groupingBy(s -&gt; s, Collectors.counting()));\nfrequency.forEach((k, v) -&gt; System.out.println(k + \": \" + v));\n// Java: 2, Spring: 1, Lambda: 1\n</code></pre> <pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nMap&lt;Integer, List&lt;String&gt;&gt; map = list.stream()\n    .collect(Collectors.groupingBy(String::length));\nmap.forEach((k, v) -&gt; System.out.println(k + \": \" + v));\n// 4: [Java], 6: [Spring, Lambda]\n</code></pre>"},{"location":"streams/#lambda-with-stream-partitioningby","title":"Lambda with Stream PartitioningBy","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nMap&lt;Boolean, List&lt;Integer&gt;&gt; partitioned = numbers.stream()\n    .collect(Collectors.partitioningBy(n -&gt; n % 2 == 0));\npartitioned.forEach((k, v) -&gt; System.out.println(k + \": \" + v));\n// true: [2, 4, 6, 8, 10], false: [1, 3, 5, 7, 9]List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nMap&lt;Boolean, List&lt;Integer&gt;&gt; partitioned = numbers.stream()\n    .collect(Collectors.partitioningBy(n -&gt; n % 2 == 0));\npartitioned.forEach((k, v) -&gt; System.out.println(k + \": \" + v));\n// true: [2, 4, 6, 8, 10], false: [1, 3, 5, 7, 9]\n</code></pre>"},{"location":"streams/#lambda-with-stream-counting","title":"Lambda with Stream Counting","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nlong count = list.stream()\n    .collect(Collectors.counting());\nSystem.out.println(\"Count: \" + count); // Count: 3\n</code></pre>"},{"location":"streams/#lambda-with-stream-summarizingint","title":"Lambda with Stream SummarizingInt","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nIntSummaryStatistics stats = numbers.stream()\n    .collect(Collectors.summarizingInt(Integer::intValue));\nSystem.out.println(\"Sum: \" + stats.getSum());\nSystem.out.println(\"Average: \" + stats.getAverage());\nSystem.out.println(\"Max: \" + stats.getMax());\nSystem.out.println(\"Min: \" + stats.getMin());\n</code></pre>"},{"location":"streams/#lambda-with-stream-tomap","title":"Lambda with Stream ToMap","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nMap&lt;String, Integer&gt; map = list.stream()\n    .collect(Collectors.toMap(s -&gt; s, String::length));\nmap.forEach((k, v) -&gt; System.out.println(k + \": \" + v));\n// Java: 4, Spring: 6, Lambda: 6\n</code></pre>"},{"location":"streams/#lambda-for-creating-a-stream","title":"Lambda for Creating a Stream","text":"<pre><code>Stream&lt;String&gt; stream = Stream.of(\"Java\", \"Spring\", \"Lambda\");\nstream.forEach(System.out::println);\n</code></pre>"},{"location":"streams/#lambda-with-stream-limit","title":"Lambda with Stream Limit","text":"<pre><code>Stream&lt;String&gt; stream = Stream.of(\"Java\", \"Spring\", \"Lambda\", \"Kafka\");\nstream.limit(2)\n    .forEach(System.out::println); // Java, Spring\n</code></pre>"},{"location":"streams/#lambda-with-stream-peek","title":"Lambda with Stream Peek","text":"<pre><code>Stream&lt;String&gt; stream = Stream.of(\"Java\", \"Spring\", \"Lambda\", \"Kafka\");\nstream.peek(System.out::println)\n    .collect(Collectors.toList());\n</code></pre>"},{"location":"streams/#lambda-with-stream-distinct","title":"Lambda with Stream Distinct","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Java\", \"Lambda\");\nlist.stream()\n    .distinct()\n    .forEach(System.out::println);\n// Java, Spring, Lambda\n</code></pre>"},{"location":"streams/#lambda-with-stream-flatmap","title":"Lambda with Stream FlatMap","text":"<pre><code>List&lt;List&lt;String&gt;&gt; listOfLists = Arrays.asList(\n    Arrays.asList(\"Java\", \"Spring\"),\n    Arrays.asList(\"Lambda\", \"Kafka\")\n);\nlistOfLists.stream()\n    .flatMap(List::stream)\n    .forEach(System.out::println);\n// Java, Spring, Lambda, Kafka\n</code></pre>"},{"location":"streams/#lambda-with-stream-reduce","title":"Lambda with Stream Reduce","text":"<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = numbers.stream()\n    .reduce(0, (a, b) -&gt; a + b);\nSystem.out.println(\"Sum: \" + sum); // Sum: 15\n</code></pre>"},{"location":"streams/#lambda-with-stream-filter-and-map","title":"Lambda with Stream Filter and Map","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nlist.stream()\n    .filter(s -&gt; s.startsWith(\"J\"))\n    .map(String::toUpperCase)\n    .forEach(System.out::println);\n// JAVA\n</code></pre>"},{"location":"streams/#lambda-with-stream-sorted-with-comparator","title":"Lambda with Stream Sorted with Comparator","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nlist.stream()\n    .sorted((s1, s2) -&gt; s2.compareTo(s1)) // reverse order\n    .forEach(System.out::println);\n// Spring, Lambda, Java\n</code></pre>"},{"location":"streams/#lambda-with-stream-iterate","title":"Lambda with Stream Iterate","text":"<pre><code>Stream.iterate(0, n -&gt; n + 2)\n    .limit(5)\n    .forEach(System.out::println);\n// 0, 2, 4, 6, 8\n</code></pre>"},{"location":"streams/#lambda-with-stream-generate","title":"Lambda with Stream Generate","text":"<pre><code>Stream.generate(() -&gt; \"Java\")\n    .limit(3)\n    .forEach(System.out::println);\n// Java, Java, Java\n</code></pre>"},{"location":"streams/#lambda-with-stream-of-primitives","title":"Lambda with Stream of Primitives","text":"<pre><code>IntStream.range(1, 4)\n    .forEach(System.out::println);\n// 1, 2, 3\n</code></pre>"},{"location":"streams/#lambda-with-stream-to-array","title":"Lambda with Stream to Array","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\nString[] array = list.stream()\n    .toArray(String[]::new);\nSystem.out.println(Arrays.toString(array));\n// [Java, Spring, Lambda]\n</code></pre>"},{"location":"streams/#lambda-with-stream-collect-to-list","title":"Lambda with Stream Collect to List","text":"<pre><code>Stream&lt;String&gt; stream = Stream.of(\"Java\", \"Spring\", \"Lambda\");\nList&lt;String&gt; collectedList = stream\n    .collect(Collectors.toList());\nSystem.out.println(collectedList);\n// [Java, Spring, Lambda]\n</code></pre>"},{"location":"uebungen/","title":"\u00dcbungen","text":""},{"location":"uebungen/#ubung-1-codereview-und-static","title":"\u00dcbung 1 (Codereview und static)","text":"Was ist an diesem Code alles falsch? <pre><code>package uebungen.uebung1;\n\n/*\n * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius)\n * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit)\n */\n\npublic class Konvertierung {\n\n    private double celsius;\n    private double fahrenheit;\n\n    public Konvertierung(double celsius) \n    {       \n        this.celsius = celsius;\n        this.fahrenheit = celsius * 1.8 + 32;       \n    }\n\n    public Konvertierung(double fahrenheit) \n    {       \n        this.celsius = fahrenheit - 32 * 5/9;\n        this.fahrenheit = fahrenheit;       \n    }\n\n    public void print()\n    {\n        System.out.println(this.celsius + \"\\u00B0C = \" + this.fahrenheit + \"\\u00B0F\");\n    }\n}\n</code></pre> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 1 <pre><code>package uebungen.uebung1;\n\n/*\n * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius)\n * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit)\n */\n\npublic class Konvertierung {\n\n    private Konvertierung() {\n\n    }\n\n    public static double celsiusToFahrenheit(double celsius) {\n        final double FACTOR_CELSIUS_TO_FAHRENHEIT = 1.8;\n        final int DIFFERENCE_CELSIUS_TO_FAHRENHEIT = 32;\n\n        double fahrenheit = celsius * FACTOR_CELSIUS_TO_FAHRENHEIT \n                + DIFFERENCE_CELSIUS_TO_FAHRENHEIT; \n\n        return fahrenheit;\n    }\n\n    public static double fahrenheitToCelsius(double fahrenheit) {\n        final double FACTOR_FAHRENHEIT_TO_CELSIUS = 5.0/9.0;\n        final int DIFFERENCE_FAHRENHEIT_TO_CELSIUS = 32;\n\n        double celsius = (fahrenheit - DIFFERENCE_FAHRENHEIT_TO_CELSIUS) * FACTOR_FAHRENHEIT_TO_CELSIUS;\n\n        return celsius;\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-2-string-und-algorithmisches-denken","title":"\u00dcbung 2 (String und algorithmisches Denken)","text":"\u00dcbung 2 <ol> <li> <p>Erstellen Sie im Paket <code>uebungen.uebung2</code> eine Java-Klasse <code>Uebung2</code> mit <code>main()</code>-Methode. In diese Klasse implementieren wir statische Methoden. \u00d6ffnen Sie zum L\u00f6sen der \u00dcbung am besten die JavaDoc-Dokumentation der Klasse String. \u00dcberlegen Sie sich, bevor Sie jeweils anfangen zu implementieren, genau, wie Sie vorgehen m\u00f6chten.</p> </li> <li> <p>Implementieren Sie eine Methode <code>static boolean isBinaryNumber(String s)</code>. Diese Methode \u00fcberpr\u00fcft, ob der <code>String s</code> einer Bin\u00e4rzahl entspricht, d.h. ob er nur <code>0</code> und <code>1</code> enth\u00e4lt. </p> </li> <li> <p>Testen Sie die Methode <code>isBinaryNumber(String s)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(isBinaryNumber(\"101101\"));   // true\nSystem.out.println(isBinaryNumber(\"0\"));        // true\nSystem.out.println(isBinaryNumber(\"101a01\"));   // false\nSystem.out.println(isBinaryNumber(\"101201\"));   // false\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>static int binaryToDecimal(String s)</code>. Diese Methode wandelt den <code>String s</code> in eine Dezimalzahl um, wenn <code>s</code> einer Bin\u00e4rzahl entspricht. Wenn <code>s</code> keiner Bin\u00e4rzahl entspricht, wird <code>-1</code> zur\u00fcckgegeben. </p> </li> <li> <p>Testen Sie die Methode <code>binaryToDecimal(String s)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(binaryToDecimal(\"101101\"));  // 45\nSystem.out.println(binaryToDecimal(\"0\"));       // 0\nSystem.out.println(binaryToDecimal(\"000001\"));  // 1\nSystem.out.println(binaryToDecimal(\"100000\"));  // 32\nSystem.out.println(binaryToDecimal(\"101a01\"));  // -1\nSystem.out.println(binaryToDecimal(\"101201\"));  // -1\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>static String toLowerCase(String input)</code>. Diese Methode wandelt alle Gro\u00dfbuchstaben ('A'...'Z') in Kleinbuchstaben um (und nur diese - alle anderen Zeichen bleiben erhalten). Schauen Sie sich dazu auch nochmal die ASCII-Tabelle an.</p> </li> <li> <p>Testen Sie die Methode <code>toLowerCase(String input)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(toLowerCase(\"abcdEFG\"));     // abcdefg\nSystem.out.println(toLowerCase(\"abcd123EFG\"));  // abcd123efg\nSystem.out.println(toLowerCase(\"ABC XYZ !%\"));  // abc xyz !%\n</code></pre></p> </li> </ol> <p>Zusatz:</p> <ol> <li> <p>Implementieren Sie eine Methode <code>static boolean isPalindrome(String input)</code>. Diese Methode pr\u00fcft, ob es sich bei <code>input</code> um ein Palindrom handelt (also von vorne nach hinten genauso gelesen werden kann, wie von hinten nach vorne). Gro\u00df- und Kleinschreibung wird nicht ber\u00fccksichtigt! Die Methode substring(int,int) aus <code>String</code> ist dabei wahrscheinlich n\u00fctzlich!</p> </li> <li> <p>Testen Sie die Methode <code>isPalindrome(String input)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(isPalindrome(\"Otto\"));       // true\nSystem.out.println(isPalindrome(\"abc_CBA\"));    // true\nSystem.out.println(isPalindrome(\"abc_-CBA\"));   // false\nSystem.out.println(isPalindrome(\"-\"));          // true\nSystem.out.println(isPalindrome(\"Dreh mal am Herd\"));   // false \n</code></pre></p> </li> <li> <p>Angenommen, Sie sollen f\u00fcr einen gegebenen <code>String</code> angeben, ob er korrekt geklammerte Ausdr\u00fccke enth\u00e4lt (nur die Klammern betrachten). Wie w\u00fcrden Sie vorgehen? Nicht implementieren, nur nachdenken. Folgende Beispiele: <pre><code>((()))()(())        // korrekt\n((())               // nicht korrekt\n(()))               // nicht korrekt\n())(                // nicht korrekt\n</code></pre></p> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 <pre><code>package uebungen.uebung2.loesung;\n\npublic class Uebung2 {\n\n    public static boolean isBinaryNumber(String s)\n    {\n        for(int index=0; index &lt; s.length(); index++)\n        {\n            char c = s.charAt(index);\n            if(!(c=='0' || c=='1'))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int binaryToDecimal(String s)\n    {\n        final int STRING_IS_NOT_A_BINARY_NUMBER = -1;\n        if(!isBinaryNumber(s))\n        {\n           return STRING_IS_NOT_A_BINARY_NUMBER;\n        }\n        int positionValue = 1;\n        int decimalNumber = 0;\n        int exp = 0;\n        for(int index = s.length()-1; index &gt;= 0; index--)\n        {\n            char c = s.charAt(index);\n            int digit = c - '0';\n            int value = digit * positionValue;\n            decimalNumber += value;\n            positionValue *= 2;\n        }\n\n        return decimalNumber;\n    }\n\n    public static String toLowerCase(String input)\n    {\n        String output = \"\";\n        final int UPPER_TO_LOWER = 32;\n\n        for(int index=0; index &lt; input.length(); index++)\n        {\n            char c = input.charAt(index);\n            if(c &gt;= 'A' &amp;&amp; c&lt;= 'Z')\n            {\n                c += UPPER_TO_LOWER;    // \"automatic\" type cast c = (char)(c + UPPER_TO_LOWER)\n            }\n            output += c;\n        }\n        return output;\n    }\n\n    public static boolean isPalindrome(String input)\n    {\n        String s = toLowerCase(input);\n        boolean palindrome = true;\n        while(palindrome &amp;&amp; s.length() &gt; 1)\n        {\n            char c1 = s.charAt(0); \n            char c2 = s.charAt(s.length() - 1);\n            if(c1 == c2)\n            {\n                s = s.substring(1,s.length() - 1);\n            }\n            else \n            {\n                palindrome = false;\n            }\n        }\n        return palindrome;\n    }\n\n    public static boolean checkBraces(String input)\n    {\n        int nrOpening = 0;  // man koennte auch fuer jede oeffnende ++ und\n        int nrClosing = 0;  // jede schliessende -- und dann nur eine Variable\n                            // dann pruefen, ob nie negativ\n        boolean correct = true;\n        for(int index=0; correct &amp;&amp; index &lt; input.length(); index++)\n        {\n            char c = input.charAt(index);\n            if(c== '(') \n            {\n                nrOpening++;\n            }\n            else if(c== ')') \n            {\n                nrClosing++;\n            }\n\n            if(nrClosing &gt; nrOpening)   // dann waere hier &lt; 0\n            {\n                correct = false;\n            }\n        }\n        if(nrOpening != nrClosing)      // dann waere hier == 0\n        {\n            correct = false;\n        }\n        return correct;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isBinaryNumber(\"101101\"));   // true\n        System.out.println(isBinaryNumber(\"0\"));        // true\n        System.out.println(isBinaryNumber(\"101a01\"));   // false\n        System.out.println(isBinaryNumber(\"101201\"));   // false\n\n        System.out.println(binaryToDecimal(\"101101\"));  // 45\n        System.out.println(binaryToDecimal(\"0\"));       // 0\n        System.out.println(binaryToDecimal(\"000001\"));  // 1\n        System.out.println(binaryToDecimal(\"100000\"));  // 32\n        System.out.println(binaryToDecimal(\"101a01\"));  // -1\n        System.out.println(binaryToDecimal(\"101201\"));  // -1\n\n        System.out.println(toLowerCase(\"abcdEFG\"));     // abcdefg\n        System.out.println(toLowerCase(\"abcd123EFG\"));  // abcd123efg\n        System.out.println(toLowerCase(\"ABC XYZ !%\"));  // abc xyz !%\n\n        System.out.println(isPalindrome(\"Otto\"));       // true\n        System.out.println(isPalindrome(\"abc_CBA\"));    // true\n        System.out.println(isPalindrome(\"abc_-CBA\"));   // false\n        System.out.println(isPalindrome(\"-\"));          // true\n        System.out.println(isPalindrome(\"Dreh mal am Herd\"));   // false\n        // das letzte waere okay, wenn man bei der Pruefung\n        // die Leerzeichen ignorieren wuerde, waere auch moeglich\n    }\n\n}\n</code></pre>"},{"location":"uebungen/#ubung-3-enum-und-zweidimensionale-arrays","title":"\u00dcbung 3 (enum und zweidimensionale Arrays)","text":"\u00dcbung 3 <ol> <li> <p>Gegeben ist die folgende Klasse <code>TicTacToe</code>:</p> <pre><code>package uebungen.uebung3;\n\npublic class TicTacToe \n{\n    enum State {EMPTY, RED, BLACK};\n    State[][] field;\n\n    public TicTacToe()\n    {\n        field = new State[3][3];\n        for(int i=0; i&lt;field.length; i++)\n          for(int j=0; j&lt;field[i].length; j++)\n            field[i][j]=State.EMPTY;\n    }\n\n    public void makeMove(int i, int j, State player)\n    {\n        if(field[i][j]==State.EMPTY &amp;&amp; player!=State.EMPTY)   \n            field[i][j]=player;\n    }\n}\n</code></pre> </li> <li> <p>F\u00fcgen Sie alle notwendigen Klammern <code>{ }</code> ein, so dass die Anweisungsbl\u00f6cke korrekt geklammert sind. </p> </li> <li> <p>Erweitern Sie die Klasse <code>TicTacToe</code> um eine <code>print()</code>-Methode, die das Spielfeld auf die Konsole ausgibt (Setzen Sie z.B. f\u00fcr den Player <code>RED</code> ein <code>x</code> und f\u00fcr den Player <code>Black</code> ein <code>o</code> und f\u00fcr <code>EMPTY</code> ein Leerzeichen oder ein <code>-</code>). Die Ausgabe nach jeweils 2 Z\u00fcgen von <code>RED</code> und <code>BLACK</code> k\u00f6nnte dann z.B. so aussehen: </p> <pre><code>- o o \n- x - \n- - x \n</code></pre> </li> <li> <p>Erweitern Sie die Klasse <code>TicTacToe</code> um eine <code>gewonnen()</code>-Methode (<code>true</code>, wenn ein Spieler drei Felder horizontal, diagonal oder vertikal belegt hat; ansonsten <code>false</code>).</p> </li> <li>Erweitern Sie die Klasse <code>TicTacToe</code> um eine <code>unentschieden()</code>-Methode (<code>true</code>, wenn alle Felder besetzt sind, aber kein Spieler gewonnen hat; ansonsten <code>false</code>).</li> <li>Erstellen Sie eine Test-Klasse mit <code>main()</code>-Methode. Erstellen sie darin ein Objekt der Klasse <code>TicTacToe</code>. F\u00fchren Sie Z\u00fcge aus (<code>makeMove()</code>) und pr\u00fcfen Sie, ob gewonnen wurde oder unentschieden ist (mit entsprechenden Ausgaben). </li> <li> <p>F\u00fcr 6. m\u00fcssen Sie in der Testklasse Ihr <code>enum State</code> importieren. Warum ist das so? Was k\u00f6nnten Sie machen, damit das nicht notwendig ist?</p> </li> <li> <p>Zusatz: Sie k\u00f6nnen die Klasse <code>TicTacToe</code> beliebig erweitern, z.B.:</p> <ul> <li>um Ausgaben, wenn gewonnen bzw. es unentschieden ist,</li> <li>um Fehler in den Indizes <code>i</code> und <code>j</code> bei der <code>makeMove()</code>-Methode abzufangen,</li> <li>eine Methode <code>spielen()</code> implementieren, die zuf\u00e4llig f\u00fcr die Spieler die Steine setzt usw.</li> </ul> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 TicTacToe.javaState.javaProgrammklasse.java <pre><code>package uebungen.uebung3;\n\nimport java.util.Random;\n\npublic class TicTacToe\n{\n    //enum State {EMPTY, RED, BLACK};\n    State[][] field;\n    State player;\n\n    public TicTacToe()\n    {\n        this.field = new State[3][3];\n        this.player = State.RED;\n        for(int row=0; row&lt;this.field.length; row++)\n        {\n            for (int col = 0; col &lt; this.field[row].length; col++)\n            {\n                this.field[row][col] = State.EMPTY;\n            }\n        }\n    }\n\n    private void swapPlayer()\n    {\n        this.player = (this.player == State.BLACK) ? State.RED : State.BLACK;\n    }\n\n    public void makeMove(int row, int col, State player)\n    {\n        if(this.field[row][col]==State.EMPTY &amp;&amp; player!=State.EMPTY)\n        {\n            this.field[row][col] = player;\n        }\n    }\n\n    public void print()\n    {\n        for(int row=0; row&lt;this.field.length; row++)\n        {\n            for (int col = 0; col &lt; this.field[row].length; col++)\n            {\n                /*\n                if(this.field[row][col] == State.EMPTY)\n                {\n                    System.out.print(\"- \");\n                }\n                else if(this.field[row][col] == State.RED)\n                {\n                    System.out.print(\"x \");\n                }\n                else if(this.field[row][col] == State.BLACK)\n                {\n                    System.out.print(\"o \");\n                }\n\n                 */\n                /*\n                switch(this.field[row][col]) {\n                    case EMPTY: System.out.print(\"- \"); break;\n                    case RED:   System.out.print(\"x \"); break;\n                    case BLACK: System.out.print(\"o \"); break;\n                }\n\n                 */\n                switch(this.field[row][col]) {\n                    case EMPTY -&gt; { System.out.print(\"- \"); }\n                    case RED -&gt; { System.out.print(\"x \"); }\n                    case BLACK -&gt; { System.out.print(\"o \"); }\n                }\n\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    private boolean won(State player)\n    {\n        // drei in einer Zeile ?\n        for(int row=0; row&lt;this.field.length; row++)\n        {\n            if(this.field[row][0]==player &amp;&amp; this.field[row][1]==player &amp;&amp; this.field[row][2]==player)\n            {\n                return true;\n            }\n        }\n\n        // drei in einer Spalte ?\n        for(int col=0; col&lt;this.field.length; col++)\n        {\n            if(this.field[0][col]==player &amp;&amp; this.field[1][col]==player &amp;&amp; this.field[2][col]==player)\n            {\n                return true;\n            }\n        }\n\n        // Diagonale von links oben nach rechts unten\n        if(this.field[0][0]==player &amp;&amp; this.field[1][1]==player &amp;&amp; this.field[2][2]==player)\n        {\n            return true;\n        }\n\n        // Diagonale von links unten nach rechts oben\n        if(this.field[2][0]==player &amp;&amp; this.field[1][1]==player &amp;&amp; this.field[0][2]==player)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean won()\n    {\n        return this.won(State.RED) ||this.won(State.BLACK);\n    }\n\n    private boolean full()\n    {\n        for(int row=0; row&lt;this.field.length; row++)\n        {\n            for(int col=0; col&lt;this.field[row].length; col++)\n            {\n                if(this.field[row][col]==State.EMPTY)\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean draw()\n    {\n        return this.full() &amp;&amp; !this.won();\n    }\n\n    public void printResult()\n    {\n        if(this.won(State.RED))\n        {\n            System.out.println(\"Rot hat gewonnen!\");\n        }\n        else if(this.won(State.BLACK))\n        {\n            System.out.println(\"Schwarz hat gewonnen!\");\n        }\n        else if(this.draw())\n        {\n            System.out.println(\"Unentschieden!\");\n        }\n    }\n\n    private boolean winPossible()\n    {\n        for(int row=0; row&lt;this.field.length; row++)\n        {\n            for(int col=0; col&lt;this.field[row].length; col++)\n            {\n                if(this.field[row][col]==State.EMPTY)\n                {\n                    this.field[row][col] = this.player;\n                    if(this.won(this.player))\n                    {\n                        this.field[row][col] = State.EMPTY;\n                        return true;\n                    }\n                    this.field[row][col] = State.EMPTY;\n                }\n            }\n        }\n        return false;\n    }\n\n    public void makeRandomMove()\n    {\n        Random r = new Random();\n        int row = r.nextInt(this.field.length);\n        int col = r.nextInt(this.field[row].length);\n        while(this.field[row][col] != State.EMPTY)\n        {\n            row = r.nextInt(this.field.length);\n            col = r.nextInt(this.field[row].length);\n        }\n        this.field[row][col] = this.player;\n        this.swapPlayer();\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung3;\n\npublic enum State\n{\n    EMPTY, RED, BLACK\n}\n</code></pre> <pre><code>package uebungen.uebung3;\n\npublic class Programmklasse\n{\n    public static void main(String[] args)\n    {\n        TicTacToe ttt = new TicTacToe();\n        /*\n        ttt.print();\n        ttt.makeMove(1, 2, State.RED);\n        ttt.print();\n        ttt.makeMove(1, 1, State.BLACK);\n        ttt.print();\n\n         */\n        while(!( ttt.won() || ttt.draw() ))\n        {\n            ttt.makeRandomMove();\n            ttt.print();\n        }\n        ttt.printResult();\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-4-exceptions","title":"\u00dcbung 4 (Exceptions)","text":"\u00dcbung 4 <ol> <li> <p>Schreiben Sie ein Programm zur Eingabe von zwei Zahlen mithilfe der Klasse <code>JOptionPane</code> und deren Division! Fangen Sie folgende Ausnahmen ab:</p> <ul> <li>Falls die Eingabe keiner Zahl entspricht.</li> <li>Falls die zweite Zahl eine 0 ist.</li> </ul> </li> <li> <p>Scenario:</p> <ul> <li>Fenster zur Eingabe von Zahl 1 \u00f6ffnet sich:  </li> <li>falsche Eingabe - keine Zahl:   </li> <li>Fenster \u00f6ffnet sich erneut (andere Nachricht!):   </li> <li>Fenster zur Eingabe von Zahl 2 \u00f6ffnet sich:   </li> <li>die Division Zahl1/Zahl2 schl\u00e4gt fehl (<code>ArithmeticException</code>), deshalb (andere Nachricht!):   </li> <li>Ergebnis   </li> </ul> </li> </ol> <p>Zusatz</p> <ol> <li>Lagern Sie eine solche Eingabem\u00f6glichkeit in eine wiederverwendbare Methode aus, z.B. <code>public int inputInt(int min, int max)</code>, welche die eingegebene Zahl zur\u00fcckgibt, wobei die eingegebene Zahl im Bereich <code>[min, max]</code> liegen muss.</li> </ol> <p>Viel Spa\u00df!</p> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 4 <pre><code>package uebungen.uebung4;\n\nimport javax.swing.*;\n\npublic class Uebung4\n{\n    public static int inputInt(String message)\n    {\n        boolean inputOk = false;\n        int number = 0;\n        while(!inputOk)\n        {\n            String input = JOptionPane.showInputDialog(message);\n\n            try {\n                number = Integer.parseInt(input);\n                inputOk = true;\n            }\n            catch(NumberFormatException e) {\n                message = \"Es war keine Zahl! Bitte Zahl eingeben!\";\n            }\n        }\n        return number;\n    }\n\n    public static int inputInt(int min, int max)\n    {\n        String message = \"Zahl im Bereich zwischen \" + min + \" und \" + max + \": \";\n        boolean inputOk = false;\n        int number = 0;\n        while(!inputOk)\n        {\n            String input = JOptionPane.showInputDialog(message);\n\n            try {\n                number = Integer.parseInt(input);\n                if(number &gt;= min &amp;&amp; number &lt;= max) {\n                    inputOk = true;\n                }\n                else {\n                    message = \"Zahl muss im Bereich zwischen \" + min + \" und \" + max + \" sein !\";\n                }\n            }\n            catch(NumberFormatException e) {\n                message = \"Es war keine Zahl! Bitte Zahl eingeben!\";\n            }\n        }\n        return number;\n    }\n\n    public static int reverseNumber(int number)\n    {\n        int result = 0;\n        int copy = number;\n        while(copy != 0)\n        {\n            result = result * 10 + copy % 10;\n            copy /= 10;\n        }\n        return result;\n    }\n\n    public static int crossSum(int number)\n    {\n        int crossSum = 0;\n        int copy = number;\n        while(copy != 0)\n        {\n            crossSum += copy % 10;\n            copy /= 10;\n        }\n        return crossSum;\n    }\n\n\n\n    public static void main(String[] args)\n    {\n        int zahl1 = inputInt(\"Zahl 1\");\n\n        boolean number2Valid = false;\n        String message = \"Zahl 2\";\n        int zahl2 = 0;\n        int divisor = 0;\n        while (!number2Valid) {\n            zahl2 = inputInt(message);\n            try {\n                divisor = zahl1 / zahl2;\n                number2Valid = true;\n            } catch (ArithmeticException e) {\n                message = \"Zahl darf nicht 0 sein!\";\n            }\n        }\n        message = zahl1 + \" / \" + zahl2 + \" = \" + divisor;\n        JOptionPane.showMessageDialog(null, message, \"ERGEBNIS\", JOptionPane.PLAIN_MESSAGE);\n\n        System.out.println(inputInt(1,6));\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-5-try-with-resource-und-eigene-exception-klassen","title":"\u00dcbung 5 (try-with-resource und eigene Exception-Klassen)","text":"\u00dcbung 5 <ol> <li> <p>Laden Sie sich folgende Datei herunter: staedte.csv, erstellen Sie in Ihrem Workspace einen <code>assets</code>-Ordner (direkt im Projektordner neben <code>src</code>und <code>out</code>).</p> </li> <li> <p>Erstellen Sie eine Klasse <code>Uebung5</code> mit <code>main</code>-Methode und kopieren Sie in die Klasse folgende statische Methode:</p> <pre><code>public static void printCSVFileUsingFileReader()\n{\n    String filePath = \"assets/staedte.csv\";\n    FileReader fileReader = new FileReader(filePath);\n    BufferedReader bufferedReader = new BufferedReader(fileReader);\n    String line;\n    while ((line = bufferedReader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n</code></pre> <p>Die Methode l\u00e4sst sich so nicht \u00fcbersetzen. Warum nicht? \u00c4ndern Sie die Methode so, dass sie ausf\u00fchrbar ist und rufen Sie sie in der <code>main</code>-Methode auf. </p> </li> <li> <p>Eine andere M\u00f6glichkeit f\u00fcr das Einlesen einer Datei ist die Verwendung von <code>Scanner</code>:</p> <pre><code>public static void printCSVFileUsingScanner()\n{\n    Scanner scanner = new Scanner(new File(\"assets/staedte.csv\"));\n\n    while (scanner.hasNextLine()) {\n        System.out.println(scanner.nextLine());\n    }\n\n    scanner.close();\n}\n</code></pre> <p>Auch diese Methode l\u00e4sst sich so nicht \u00fcbersetzen. \u00c4ndern Sie die Methode so, dass sie ausf\u00fchrbar ist und rufen Sie sie in der <code>main</code>-Methode auf. </p> </li> <li> <p>(wenn die Zeit knapp ist, dann Zusatz ;-) \u00c4ndern Sie die Ausgabe so, dass folgende \"Tabelle\" auf der Konsole erscheint:</p> <pre><code>| Rang | Name                 |       1970 |       1980 |       1990 |       2000 |       2010 |       2020 |       2023 | Bundesland           | \n|   1. | Berlin               |  3.208.719 |  3.048.759 |  3.433.695 |  3.382.169 |  3.460.725 |  3.664.088 |  3.662.381 | Berlin               | \n|   2. | Hamburg              |  1.793.640 |  1.645.095 |  1.652.363 |  1.715.392 |  1.786.448 |  1.852.478 |  1.851.596 | Hamburg              | \n|   3. | M\u00fcnchen              |  1.311.978 |  1.298.941 |  1.229.026 |  1.210.223 |  1.353.186 |  1.488.202 |  1.488.719 | Bayern               | \n|   4. | K\u00f6ln                 |    849.451 |    976.694 |    953.551 |    962.884 |  1.007.119 |  1.083.498 |  1.024.408 | Nordrhein-Westfalen  | \n|   5. | Frankfurt am Main    |    666.179 |    629.375 |    644.865 |    646.550 |    679.664 |    764.104 |    749.596 | Hessen               | \n|   6. | D\u00fcsseldorf           |    660.963 |    590.479 |    575.794 |    569.364 |    588.735 |    620.523 |    616.319 | Nordrhein-Westfalen  | \n|   7. | Stuttgart            |    634.202 |    580.648 |    579.988 |    583.874 |    606.588 |    630.305 |    613.111 | Baden-W\u00fcrttemberg    | \n|   8. | Leipzig              |    583.885 |    562.480 |    511.079 |    493.208 |    522.883 |    597.493 |    608.013 | Sachsen              | \n|   9. | Dortmund             |    640.642 |    608.297 |    599.055 |    588.994 |    580.444 |    587.696 |    601.343 | Nordrhein-Westfalen  | \n|  10. | Bremen               |    592.533 |    555.118 |    551.219 |    539.403 |    547.340 |    566.573 |    584.332 | Bremen               | \n|  11. | Essen                |    696.419 |    647.643 |    626.973 |    595.243 |    574.635 |    582.415 |    574.082 | Nordrhein-Westfalen  | \n|  12. | Dresden              |    502.432 |    516.225 |    490.571 |    477.807 |    523.058 |    556.227 |    563.019 | Sachsen              | \n|  13. | N\u00fcrnberg             |    478.181 |    484.405 |    493.692 |    488.400 |    505.664 |    515.543 |    526.606 | Bayern               | \n|  14. | Hannover             |    521.003 |    534.623 |    513.010 |    515.001 |    522.686 |    534.049 |    520.290 | Niedersachsen        | \n|  15. | Duisburg             |    452.721 |    558.089 |    535.447 |    514.915 |    489.559 |    495.885 |    503.185 | Nordrhein-Westfalen  | \n|  16. | Wuppertal            |    417.694 |    393.381 |    383.660 |    366.434 |    349.721 |    355.004 |    358.592 | Nordrhein-Westfalen  | \n|  17. | Bochum               |    343.809 |    400.757 |    396.486 |    391.147 |    374.737 |    364.454 |    357.024 | Nordrhein-Westfalen  | \n|  18. | Bielefeld            |    168.609 |    312.708 |    319.037 |    321.758 |    323.270 |    333.509 |    331.519 | Nordrhein-Westfalen  | \n|  19. | Bonn                 |    275.722 |    288.148 |    292.234 |    302.247 |    324.899 |    330.579 |    321.680 | Nordrhein-Westfalen  | \n|  20. | Mannheim             |    332.378 |    304.303 |    310.411 |    306.729 |    313.174 |    309.721 |    316.256 | Baden-W\u00fcrttemberg    | \n</code></pre> </li> <li> <p>Implementieren Sie die Methode <code>public static Integer getInteger(Integer[] values, int index)</code>. Es k\u00f6nnen 2 Probleme auftreten</p> <ul> <li>der <code>index</code> passt nicht zum Array,</li> <li>das Element im Array zeigt auf kein Objekt (Referenz ist `null).</li> </ul> <p>Definieren Sie die Klassen <code>MyIndexOutOfBoundsException</code> und <code>MyNullPointerException</code>. Beide erben von <code>RuntimeException</code>. Wenn Sie in der <code>main</code>-Methode folgende Aufrufe haben</p> <pre><code>Integer[] values = new Integer[3];\nvalues[0] = Integer.valueOf(0);\nvalues[2] = Integer.valueOf(2);\nfor(int index = 0; index &lt;= 3; index++) {\n    try {\n        System.out.println(getInteger(values, index));\n    }\n    catch (MyIndexOutOfBoundsException e) {\n        System.out.println(e.getMessage());\n    }\n    catch (MyNullPointerException e) {\n        System.out.println(e.getMessage());\n    }\n}\nSystem.out.println(\"Ende\");\n</code></pre> <p>dann soll die Ausgabe wie folgt sein:</p> <pre><code>0\nno object!\n2\nindex 3 ist out of bounds! length = 3\nEnde\n</code></pre> <p>Wie implementieren Sie Ihre Exception-Klassen?</p> </li> <li> <p>Welchen Unterschied macht es, ob Ihre Exception-Klassen von <code>RuntimeException</code> erben oder von <code>Exception</code> ?</p> </li> </ol> <p>Advanced/Zusatz</p> <ol> <li> <p>Wir haben die <code>try-catch()</code>-Anweisung bisher wie folgt kennengelernt:</p> <pre><code>try {\n    // kritische Anweisung_en\n}\ncatch(RuntimeException e) {\n    //Behandlung der Exception\n}\n</code></pre> <p>Es gibt eine weitere M\u00f6glichkeit, die sogenannte <code>try-with-resources</code>-Anweisung:</p> <pre><code>try ( // Ressource ) {\n    // kritische Anweisung_en\n}\ncatch(Exception e) {\n    //Behandlung der Exception\n}\n</code></pre> <p>Hier haben wir nach <code>try</code> runde Klammern und darin werden sogenannte Ressourcen verwaltet. </p> <p>Eine Ressource ist eine Objekt, das wieder geschlossen werden mussen, wenn die Nutzung der Ressource abgeschlossen ist.</p> <p>Typische Vertreter solcher Ressourcen sind FileReader und BufferedReader. Ressources sind alle Klassen, die das Java-Interface Closeable implementieren - zu Interfaces kommen wir sp\u00e4ter.</p> </li> <li> <p>\u00c4ndern Sie 2. und 3. so, dass Sie die <code>try-with-resources</code>-Anweisung verwenden.</p> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 Uebung5.javaMyIndexOutOfBoundsException.javaMyNullPointerException.java <pre><code>package uebungen.uebung5;\n\nimport java.io.*;\nimport java.util.Scanner;\n\npublic class Uebung5\n{\n    public static void printCSVFileUsingFileReader()\n    {\n        String filePath = \"assets/staedte.csv\";\n        try {\n            FileReader fileReader = new FileReader(filePath);\n            BufferedReader bufferedReader = new BufferedReader(fileReader);\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                String[] data = line.split(\";\");\n                //System.out.println(data[0]);\n                System.out.printf(\"| %4s | %-20s | %10s | %10s | %10s | %10s | %10s | %10s | %10s | %-20s |%n\",\n                        data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9]);\n                //System.out.println(line);\n            }\n        }\n        catch (FileNotFoundException e)\n        {\n            System.out.println(e.getMessage());\n        }\n        catch(IOException e)\n        {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void printCSVFileUsingScanner()\n    {\n        try {\n            Scanner scanner = new Scanner(new File(\"assets/staedte.csv\"));\n            while (scanner.hasNextLine()) {\n                System.out.println(scanner.nextLine());\n            }\n            scanner.close();\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static Integer getInteger(Integer[] values, int index) throws MyIndexOutOfBoundsException\n    {\n        if (index &lt; 0 || index &gt;= values.length) {\n            throw new MyIndexOutOfBoundsException(index, values.length);\n        }\n        Integer value =  values[index];\n        if(value == null) {\n            throw new MyNullPointerException();\n        }\n        return value;\n    }\n\n    public static void main(String[] args)\n    {\n        printCSVFileUsingFileReader();\n        //printCSVFileUsingScanner();\n\n        Integer[] values = new Integer[3];\n        values[0] = Integer.valueOf(0);\n        values[2] = Integer.valueOf(2);\n        for(int index = 0; index &lt;= 3; index++) {\n            try {\n                System.out.println(getInteger(values, index));\n            }\n            catch (MyIndexOutOfBoundsException e) {\n                System.out.println(e.getMessage());\n            }\n            catch (MyNullPointerException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n        System.out.println(\"Ende\");\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung5;\n\npublic class MyIndexOutOfBoundsException extends RuntimeException\n{\n    public MyIndexOutOfBoundsException(String message)\n    {\n        super(message);\n    }\n\n    public MyIndexOutOfBoundsException()\n    {\n        super(\"index out of bounds\");\n    }\n\n    public MyIndexOutOfBoundsException(int index, int length)\n    {\n        super(\"index \" + index + \" ist out of bounds! length = \" + length);\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung5;\n\npublic class MyNullPointerException extends RuntimeException\n{\n    public MyNullPointerException(String message)\n    {\n        super(message);\n    }\n\n    public MyNullPointerException()\n    {\n        super(\"no object!\");\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-6-listen-und-mengen","title":"\u00dcbung 6 (Listen und Mengen)","text":"\u00dcbung 6 <ol> <li>Erstellen Sie eine Klasse <code>Uebung6</code> mit <code>main()</code>-Methode.</li> <li>Definieren Sie in der <code>main()</code>-Methode eine Variable <code>words</code> vom Typ <code>String[]</code> und weisen Sie dieser Variablen folgende Werte zu:     <pre><code>String[] words = {\"Linux\", \"Apple\", \"Facebook\", \"Amazon\", \"IBM\", \"Lenovo\", \"Google\", \"IBM\", \"Microsoft\", \"Apple\", \"Google\", \"Twitter\", \"Skype\", \"Chrome\", \"Linux\", \"Firefox\"};\n</code></pre></li> </ol> <p>A. Listen (<code>List</code>)</p> <ol> <li>Erstellen Sie eine Methode <code>public static List&lt;String&gt; createArrayList(String[] words)</code>. In dieser Methode soll eine <code>ArrayList</code> erstellt werden. Alle Elemente in dieser Liste sind vom Typ <code>String</code>. Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem <code>words</code>-Array. Die Methode gibt die bef\u00fcllte Liste (<code>List</code>) zur\u00fcck. </li> <li>Erstellen Sie eine Methode <code>public static void printList(List&lt;String&gt; list)</code>. Diese Methode gibt alle Elemente der Liste <code>list</code> auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Liste aus. </li> <li>Erstellen Sie in der <code>main()</code>-Methode mithilfe der Methode <code>createArrayList(words)</code> eine Liste und speichern Sie diese Liste in einer Variablen vom Typ <code>List&lt;String&gt;</code>. Geben Sie alle Elemente dieser Liste mithilfe der Methode <code>printList()</code> auf der Konsole aus. </li> <li> <p>Studieren Sie alle Methoden f\u00fcr <code>List</code> unter https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html.</p> <ul> <li> <p>Ermitteln Sie den Index in der Liste, in der <code>\"Apple\"</code> das erste Mal auftaucht. Erzeugen Sie folgende Ausgabe:      <pre><code>Index des ersten Auftretens von Apple  : 1\n</code></pre></p> </li> <li> <p>Ermitteln Sie den Index in der Liste, in der <code>\"Apple\"</code> das letzte Mal auftaucht. Erzeugen Sie folgende Ausgabe:      <pre><code>Index des letzten Auftretens von Apple : 9\n</code></pre></p> </li> <li> <p>Geben Sie den Wert des ersten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe:      <pre><code>erstes Element der Liste : Linux\n</code></pre></p> </li> <li> <p>Geben Sie den Wert des letzten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe:      <pre><code>letztes Element der Liste : Firefox\n</code></pre></p> </li> <li> <p>L\u00f6schen Sie die Werte <code>\"Apple\"</code>, <code>\"Google\"</code> und <code>\"Facebook\"</code>. Geben Sie die Liste erneut mithilfe der <code>printList(list)</code>-Methode aus.</p> </li> </ul> </li> </ol> <p>B. Mengen (<code>Set</code>)</p> <ol> <li>Erstellen Sie eine Methode <code>public static Set&lt;String&gt; createHashSet(String[] words)</code>. In dieser Methode soll eine <code>HashSet</code> erstellt werden. Alle Elemente in dieser Menge sind vom Typ <code>String</code>. Bef\u00fcllen Sie diese Menge mit allen W\u00f6rtern aus dem <code>words</code>-Array. Die Methode gibt die bef\u00fcllte Menge (<code>Set</code>) zur\u00fcck. </li> <li>Erstellen Sie eine Methode <code>public static void printSet(Set&lt;String&gt; set)</code>. Diese Methode gibt alle Elemente der Menge <code>set</code> auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Menge aus. </li> <li>Erstellen Sie in der <code>main()</code>-Methode mithilfe der Methode <code>createHashSet(words)</code> eine Menge und speichern Sie diese Menge in einer Variablen vom Typ <code>Set&lt;String&gt;</code>. Geben Sie alle Elemente dieser Menge mithilfe der Methode <code>printSet()</code> auf der Konsole aus. Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente in der Liste? Warum ist das so?</li> <li>Erstellen Sie eine Methode <code>public static Set&lt;String&gt; createTreeSet(String[] words)</code>. In dieser Methode soll eine <code>TreeSet</code> erstellt werden. Alle Elemente in dieser Menge sind vom Typ <code>String</code>. Bef\u00fcllen Sie diese Menge (<code>Set</code>) mit allen W\u00f6rtern aus dem <code>words</code>-Array. Die Methode gibt die bef\u00fcllte Menge (<code>Set</code>) zur\u00fcck. </li> <li>Erstellen Sie in der <code>main()</code>-Methode mithilfe der Methode <code>createTreeSet(words)</code> eine Menge und speichern Sie diese Menge in einer Variablen. Geben Sie alle Elemente dieser Menge mithilfe der Methode <code>printSet()</code> auf der Konsole aus. Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur <code>HashSet</code>?</li> </ol> <p>Zusatz</p> <ol> <li>Erstellen Sie f\u00fcr die Liste eine Methode <code>public static List&lt;String&gt; findDoublets(List&lt;String&gt; list)</code>. Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in <code>list</code> doppelt vorkommen. Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. Geben Sie diese Liste mithilfe der <code>printList()</code>-Methode in der <code>main()</code>-Methode aus.</li> </ol> M\u00f6gliche Ausgabe (je nach Reihenfolge des Aufrufs der Methoden) <pre><code>Liste mit 16 Elementen :\n--------------------------\nLinux\nApple\nFacebook\nAmazon\nIBM\nLenovo\nGoogle\nIBM\nMicrosoft\nApple\nGoogle\nTwitter\nSkype\nChrome\nLinux\nFirefox\nIndex des ersten Auftretens von Apple  : 1\nIndex des letzten Auftretens von Apple : 9\nerstes Element in der Liste  : Linux\nletztes Element in der Liste : Firefox\n\nListe mit 13 Elementen :\n--------------------------\nLinux\nAmazon\nIBM\nLenovo\nIBM\nMicrosoft\nApple\nGoogle\nTwitter\nSkype\nChrome\nLinux\nFirefox\n\nDoublets-\nListe mit 4 Elementen :\n--------------------------\nLinux\nIBM\nIBM\nLinux\n\nohne Doublets-\nListe mit 9 Elementen :\n--------------------------\nAmazon\nLenovo\nMicrosoft\nApple\nGoogle\nTwitter\nSkype\nChrome\nFirefox\n\nMenge mit 12 Elementen :\n--------------------------\nLenovo\nGoogle\nApple\nSkype\nLinux\nIBM\nTwitter\nChrome\nMicrosoft\nAmazon\nFacebook\nFirefox\n\nMenge mit 12 Elementen :\n--------------------------\nAmazon\nApple\nChrome\nFacebook\nFirefox\nGoogle\nIBM\nLenovo\nLinux\nMicrosoft\nSkype\nTwitter\n</code></pre> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 Uebung6.java <pre><code>package uebungen.uebung6;\n\nimport java.util.*;\n\npublic class Uebung6\n{\n    public static List&lt;String&gt; createArrayList(String[] words)\n    {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for(String word : words)\n        {\n            list.add(word);\n        }\n        return list;\n    }\n\n    public static void printList(List&lt;String&gt; list)\n    {\n        System.out.printf(\"Liste mit %d Elementen : %n\", list.size());\n        System.out.println(\"--------------------------\");\n        for(String s : list)\n        {\n            System.out.println(s);\n        }\n        System.out.println();\n    }\n\n    public static Set&lt;String&gt; createHashSet(String[] words)\n    {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;();\n        for(String word : words)\n        {\n            set.add(word);\n        }\n        return set;\n    }\n\n\n    public static Set&lt;String&gt; createTreeSet(String[] words)\n    {\n        Set&lt;String&gt; set = new TreeSet&lt;&gt;();\n        for(String word : words)\n        {\n            set.add(word);\n        }\n        return set;\n    }\n\n\n    public static Set&lt;Integer&gt; createIntegerSet(int from, int to)\n    {\n        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n        for(Integer i = from; i &lt;= to; i++)\n        {\n            set.add(i);\n        }\n        return set;\n    }\n\n    public static void printSet(Set&lt;String&gt; set)\n    {\n        System.out.printf(\"Menge mit %d Elementen : %n\", set.size());\n        System.out.println(\"--------------------------\");\n        for(String s : set)\n        {\n            System.out.println(s);\n        }\n        System.out.println();\n    }\n\n    public static void printIntegerSet(Set&lt;Integer&gt; set)\n    {\n        for(Integer i : set)\n        {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n    }\n\n    public static List&lt;String&gt; findDoubletsTwice(List&lt;String&gt; list)\n    {\n        List&lt;String&gt; doublets = new ArrayList&lt;&gt;();\n        for(String currentValue : list)\n        {\n            if(list.indexOf(currentValue) != list.lastIndexOf(currentValue))\n            {\n                doublets.add(currentValue);\n            }\n        }\n        return doublets;\n    }\n\n    public static List&lt;String&gt; findDoubletsOnce(List&lt;String&gt; list)\n    {\n        List&lt;String&gt; doublets = new ArrayList&lt;&gt;();\n        for(int index = 0; index &lt; list.size(); index++)\n        {\n            String currentValue = list.get(index);\n            if(contains(list, currentValue, index+1))\n            {\n                doublets.add(currentValue);\n            }\n        }\n        return doublets;\n    }\n\n    public static boolean contains(List&lt;String&gt; list, String currentValue, int index)\n    {\n        for(int i = index; i &lt; list.size(); i++)\n        {\n            if(list.get(i).equals(currentValue))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n------- Uebung6 -------%n%n\");\n        String[] words = {\"Linux\", \"Apple\", \"Facebook\", \"Amazon\",\n                \"IBM\", \"Lenovo\", \"Google\", \"IBM\", \"Microsoft\",\n                \"Apple\", \"Google\", \"Twitter\", \"Skype\", \"Chrome\",\n                \"Linux\", \"Firefox\"};\n\n        System.out.printf(\"%n%n------- List -------%n%n\");\n        List&lt;String&gt; wordsList = createArrayList(words);\n        printList(wordsList);\n        int indexFirst = wordsList.indexOf(\"Apple\");\n        int indexLast = wordsList.lastIndexOf(\"Apple\");\n        String firstWord = wordsList.get(0);\n        String lastWord = wordsList.get(wordsList.size() - 1);\n        System.out.println(\"Index des ersten Auftretens von Apple : \" + indexFirst);\n        System.out.println(\"Index des letzten Auftretens von Apple : \" + indexLast);\n        System.out.println(\"erstes Element der Liste : \" + firstWord);\n        System.out.println(\"letztes Element der Liste : \" + lastWord);\n        System.out.println(\"Loeschen von Apple : \" + wordsList.remove(\"Apple\"));\n        System.out.println(\"Loeschen von Google : \" + wordsList.remove(\"Google\"));\n        System.out.println(\"Loeschen von Facebook : \" + wordsList.remove(\"Facebook\"));\n        printList(wordsList);\n\n        System.out.printf(\"%n%n------- Set -------%n%n\");\n        Set&lt;String&gt; wordsHashSet = createHashSet(words);\n        printSet(wordsHashSet);\n        Set&lt;String&gt; wordsTreeSet = createTreeSet(words);\n        printSet(wordsTreeSet);\n\n        System.out.printf(\"%n%n------- Zusatz -------%n%n\");\n        printList(findDoubletsTwice(wordsList));\n        printList(findDoubletsOnce(wordsList));\n\n        System.out.printf(\"%n%n------- Operationen ueber Mengen -------%n%n\");\n\n        Set&lt;Integer&gt; s2 = Set.of(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);    // immutable set\n\n        Set&lt;Integer&gt; s1 = createIntegerSet(1, 10);  // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        s1.addAll(s2);          // Vereinigung\n        printIntegerSet(s1);       // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\n        Set&lt;Integer&gt; s3 = createIntegerSet(1, 10);  // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        s3.removeAll(s2);       // Differenz\n        printIntegerSet(s3);       // 1, 2, 3, 4\n\n        Set&lt;Integer&gt; s4 = createIntegerSet(1, 10);  // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        s4.retainAll(s2);       // Schnitt\n        printIntegerSet(s4);       // 5, 6, 7, 8, 9, 10\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-7-maps","title":"\u00dcbung 7 (Maps)","text":"\u00dcbung 7 <ol> <li> <p>Erstellen Sie eine Klasse <code>Stadt</code> mit folgenden Objektvariablen:</p> <ul> <li><code>String name;</code></li> <li><code>List&lt;Integer&gt; bevoelkerung;</code></li> <li><code>float flaeche;</code></li> </ul> </li> <li> <p>Erstellen Sie f\u00fcr die Klasse <code>Stadt</code> einen parametrisierten Konstruktor <code>public Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche)</code>, der die Objektvariablen initialisiert.</p> </li> <li>Erstellen Sie f\u00fcr die Klasse <code>Stadt</code> eine <code>print()</code>-Methode, so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.):     <pre><code>Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre></li> <li>Erstellen Sie eine Klasse <code>StadtTest</code> mit <code>main()</code>-Methode. Kopieren Sie in die Klasse die Methode <code>public static Stadt[] staedte()</code> hinein:     <pre><code>public static Stadt[] staedte()\n{\n    Stadt[] staedte = new Stadt[6];\n    List&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\n    berlinBevoelkerung.add(3382169);    \n    berlinBevoelkerung.add(3460725);    \n    berlinBevoelkerung.add(3574830);\n    staedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n    List&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\n    hamburgBevoelkerung.add(1715392);   \n    hamburgBevoelkerung.add(1786448);   \n    hamburgBevoelkerung.add(1810438);   \n    staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\n    List&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\n    muenchenBevoelkerung.add(1210223);  \n    muenchenBevoelkerung.add(1353186);  \n    muenchenBevoelkerung.add(1464301);\n    staedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\n    List&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\n    koelnBevoelkerung.add(962884);  \n    koelnBevoelkerung.add(1007119); \n    koelnBevoelkerung.add(1075935); \n    staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\n    List&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\n    frankfurtBevoelkerung.add(648550);  \n    frankfurtBevoelkerung.add(679664);  \n    frankfurtBevoelkerung.add(736414);\n    staedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\n    berlinBevoelkerung = new ArrayList&lt;&gt;();\n    berlinBevoelkerung.add(3382169);    \n    berlinBevoelkerung.add(3460725);    \n    berlinBevoelkerung.add(3574830);\n    staedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n    return staedte;\n}       \n</code></pre></li> </ol> <p>Liste</p> <ol> <li>Erstellen Sie in der <code>main()</code>-Methode eine <code>List&lt;Stadt&gt; staedteListe = new ArrayList&lt;&gt;();</code>. F\u00fcgen Sie der <code>staedteListe</code> alle St\u00e4dte aus dem durch Aufruf der <code>staedte()</code>-Methode erzeugtem Array zu.</li> <li>Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der <code>print()</code>-Methode aus der Klasse <code>Stadt</code> aus.</li> </ol> <p>Menge</p> <ol> <li>Erstellen Sie in der <code>main()</code>-Methode eine <code>Set&lt;Stadt&gt; staedteMenge = new HashSet&lt;&gt;();</code>. F\u00fcgen Sie der <code>staedteMenge</code> alle St\u00e4dte aus dem durch Aufruf der <code>staedte()</code>-Methode erzeugtem Array zu.</li> <li>Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Menge unter Verwendung der <code>print()</code>-Methode aus der Klasse <code>Stadt</code> aus.</li> <li>Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum?</li> </ol> <p>Stadt - Teil 2</p> <ol> <li>Implementieren Sie in der Klasse <code>Stadt</code> die <code>equals(Object)</code>- und die <code>hashCode()</code>-Methode.</li> <li>F\u00fchren Sie danach die <code>StadtTest</code>-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert?</li> </ol> <p>Maps</p> <ol> <li>Erstellen Sie in der <code>main()</code>-Methode eine <code>Map&lt;Integer, Stadt&gt; staedteMap = new HashMap&lt;&gt;();</code>. F\u00fcgen Sie der <code>staedteMap</code> einen fortlaufenden, eindeutigen <code>Integer</code>-Wert beginnend mit <code>1</code> als Key sowie alle St\u00e4dte aus dem durch Aufruf der <code>staedte()</code>-Methode erzeugtem Array als Value hinzu.</li> <li>Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der <code>print()</code>-Methode aus der Klasse <code>Stadt</code> aus. Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys.</li> </ol> <p>Ausgaben</p> <pre><code>------------ Liste --------------\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\n\n------------ Menge --------------\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n\n------------ Maps --------------\n1  Berlin            891,68 km2    3.382.169   3.460.725   3.574.830\n2  Hamburg           755,22 km2    1.715.392   1.786.448   1.810.438\n3  Muenchen          310,70 km2    1.210.223   1.353.186   1.464.301\n4  Koeln             405,02 km2      962.884   1.007.119   1.075.935\n5  Frankfurt/Main    248,31 km2      648.550     679.664     736.414\n6  Berlin            891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 7 Stadt.javaStadtTest.java <pre><code>package uebungen.uebung7;\n\nimport java.util.List;\n\npublic class Stadt\n{\n    private String name;\n    private List&lt;Integer&gt; bevoelkerung;\n    private float flaeche;\n\n    public Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche)\n    {\n        this.name = name;\n        this.bevoelkerung = bevoelkerung;\n        this.flaeche = flaeche;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"%-15s %8.2f km%c\", this.name, this.flaeche, '\\u00B2');\n        for(Integer bevoelkerung : bevoelkerung)\n        {\n            s+=String.format(\" %,10d\", bevoelkerung);\n        }\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Stadt stadt = (Stadt) o;\n        return this.name.equals(stadt.name) &amp;&amp; this.flaeche == stadt.flaeche;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.name.hashCode() + Float.valueOf(this.flaeche).hashCode();\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung7;\n\nimport java.util.*;\n\npublic class StadtTest\n{\n    public static Stadt[] staedte()\n    {\n        Stadt[] staedte = new Stadt[6];\n        List&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\n        berlinBevoelkerung.add(3382169);\n        berlinBevoelkerung.add(3460725);\n        berlinBevoelkerung.add(3574830);\n        staedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n        List&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\n        hamburgBevoelkerung.add(1715392);\n        hamburgBevoelkerung.add(1786448);\n        hamburgBevoelkerung.add(1810438);\n        staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\n        List&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\n        muenchenBevoelkerung.add(1210223);\n        muenchenBevoelkerung.add(1353186);\n        muenchenBevoelkerung.add(1464301);\n        staedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\n        List&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\n        koelnBevoelkerung.add(962884);\n        koelnBevoelkerung.add(1007119);\n        koelnBevoelkerung.add(1075935);\n        staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\n        List&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\n        frankfurtBevoelkerung.add(648550);\n        frankfurtBevoelkerung.add(679664);\n        frankfurtBevoelkerung.add(736414);\n        staedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\n        berlinBevoelkerung = new ArrayList&lt;&gt;();\n        berlinBevoelkerung.add(3382169);\n        berlinBevoelkerung.add(3460725);\n        berlinBevoelkerung.add(3574830);\n        staedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n        return staedte;\n    }\n\n    public static void print(Collection&lt;Stadt&gt; staedte)\n    {\n        for(Stadt staedt : staedte)\n        {\n            System.out.println(staedt);\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        Stadt[] staedte = staedte();\n        System.out.printf(\"%n%n-------------- List ---------------------%n%n\");\n        List&lt;Stadt&gt; staedteListe = Arrays.asList(staedte);\n        print(staedteListe);\n\n        System.out.printf(\"%n%n-------------- Set ---------------------%n%n\");\n        Set&lt;Stadt&gt; staedteSet = new HashSet&lt;&gt;(Arrays.asList(staedte));\n        print(staedteSet);\n\n        System.out.printf(\"%n%n-------------- Map ---------------------%n%n\");\n        Map&lt;Integer, Stadt&gt; staedteMap = new HashMap&lt;&gt;();\n        Integer key = 1;    // auto-boxing\n        for(Stadt stadt : staedte)\n        {\n            staedteMap.put(key, stadt);\n            key++;\n        }\n        for(Map.Entry&lt;Integer, Stadt&gt; entry : staedteMap.entrySet())        // all key-value-pairs\n        {\n            Integer entryKey = entry.getKey();          // the key of the pair\n            Stadt entryValue = entry.getValue();        // the value of the pair\n            System.out.println(entryKey + \" \" + entryValue);\n        }\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-8-interfaces","title":"\u00dcbung 8 (Interfaces)","text":"\u00dcbung 8 <ol> <li> <p>Wir besch\u00e4ftigen uns nochmal mit der \u00dcbung 7, d.h. mit <code>Stadt</code> und <code>StadtTest</code>. Dieses Mal geht es uns aber mehr um die Verwendung des Interfaces <code>Comparable</code>. Zun\u00e4chst sind die beiden Klassen <code>Stadt</code> und <code>StadtTest</code> wie folgt gegeben: (das haben wir so in \u00dcbung 7 erarbeitet - es gibt eine \u00c4nderung in <code>StadtTest</code>: dort benutzen wir jetzt in der <code>Map</code> <code>MyInteger</code> anstatt <code>Integer</code> - siehe 2.): </p> Stadt.javaStadtTest.java <pre><code>import java.util.*;\n\npublic class Stadt\n{\n    String name;\n    List&lt;Integer&gt; bevoelkerung;\n    float flaeche;\n\n    public Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche)\n    {\n        super();\n        this.name = name;\n        this.bevoelkerung = bevoelkerung;\n        this.flaeche = flaeche;\n    }\n\n    void print()\n    {\n        System.out.printf(\"%-18s %.2f km%c\", this.name, this.flaeche, '\\u00B2');\n        for(Integer anzahl : this.bevoelkerung)\n        {\n            System.out.printf(\"%,14d\", anzahl);\n        }\n        System.out.println();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o==null) return false;\n        if(o==this) return true;\n        if(this.getClass()!=o.getClass()) return false;\n\n        Stadt other = (Stadt)o;\n        return (this.name.equals(other.name));\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.name.hashCode();\n    }\n\n}\n</code></pre> <pre><code>import java.util.*;\n\npublic class StadtTest\n{\n    public static Stadt[] staedte()\n    {\n        Stadt[] staedte = new Stadt[6];\n        List&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\n        berlinBevoelkerung.add(3382169);    \n        berlinBevoelkerung.add(3460725);    \n        berlinBevoelkerung.add(3574830);\n        staedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n        List&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\n        hamburgBevoelkerung.add(1715392);   \n        hamburgBevoelkerung.add(1786448);   \n        hamburgBevoelkerung.add(1810438);   \n        staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\n        List&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\n        muenchenBevoelkerung.add(1210223);  \n        muenchenBevoelkerung.add(1353186);  \n        muenchenBevoelkerung.add(1464301);\n        staedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\n        List&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\n        koelnBevoelkerung.add(962884);  \n        koelnBevoelkerung.add(1007119); \n        koelnBevoelkerung.add(1075935); \n        staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\n        List&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\n        frankfurtBevoelkerung.add(648550);  \n        frankfurtBevoelkerung.add(679664);  \n        frankfurtBevoelkerung.add(736414);\n        staedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\n        berlinBevoelkerung = new ArrayList&lt;&gt;();\n        berlinBevoelkerung.add(3382169);    \n        berlinBevoelkerung.add(3460725);    \n        berlinBevoelkerung.add(3574830);\n        staedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n        return staedte;\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n------------ Menge --------------%n\");\n        Set&lt;Stadt&gt; staedteMenge = new HashSet&lt;&gt;();\n        for(Stadt s : staedte())\n        {\n            staedteMenge.add(s);\n        }\n        for(Stadt s : staedteMenge)\n        {\n            s.print();\n        }\n\n        System.out.printf(\"%n------------ Maps --------------%n\");\n        Map&lt;MyInteger, Stadt&gt; staedteMap = new HashMap&lt;&gt;();\n        int i = 1;\n        for(Stadt s : staedte())\n        {\n            staedteMap.put(new MyInteger(i++), s);\n        }\n        for(Map.Entry&lt;MyInteger, Stadt&gt; entry : staedteMap.entrySet())\n        {\n            MyInteger key = entry.getKey();\n            System.out.printf(\"%-3d\",key.intValue());\n            entry.getValue().print();\n        }\n    }\n}\n</code></pre> </li> <li> <p>F\u00fcr die Schl\u00fcssel in der <code>Map</code> benutzen wir die selbstgeschriebne Klasse <code>MyInteger</code>:</p> MyInteger.java <pre><code>public class MyInteger \n{\n    private int value;\n\n    public MyInteger(int value)\n    {\n        this.value = value;\n    }\n\n    public int intValue()\n    {\n        return this.value;\n    }\n\n    public static MyInteger valueOf(int value)\n    {\n        return new MyInteger(value);\n    }\n}\n</code></pre> </li> <li> <p>\u00c4ndern Sie in der <code>StadtTest.java</code> den Konstruktoraufruf der <code>Set</code> von <code>HashSet</code> nach <code>TreeSet</code> und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen (<code>Stadt cannot be cast to class java.lang.Comparable</code>). Implementieren Sie f\u00fcr <code>Stadt</code> das Interface <code>Comparable&lt;Stadt&gt;</code> so, dass nach den Namen der St\u00e4dte sortiert wird. F\u00fchren Sie dann erneut <code>StadtTest.java</code> aus. Es sollte folgende Ausgabe f\u00fcr die <code>Set</code> erzeugt werden:</p> <pre><code>------------ Menge --------------\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n</code></pre> </li> <li> <p>\u00c4ndern Sie <code>compareTo()</code> in <code>Stadt</code> so, dass die Namen der St\u00e4dte absteigend sortiert werden und f\u00fchren Sie dann <code>StadtTest.java</code> erneut aus. Es sollte folgende Ausgabe erzeugt werden:</p> <pre><code>------------ Menge --------------\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> <li> <p>\u00c4ndern Sie <code>compareTo()</code> in <code>Stadt</code> so, dass die St\u00e4dte absteigend nach ihrer Fl\u00e4che sortiert werden und f\u00fchren Sie dann <code>StadtTest.java</code> erneut aus. Es sollte folgende Ausgabe erzeugt werden:</p> <pre><code>------------ Menge --------------\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\n</code></pre> </li> <li> <p>\u00c4ndern Sie in der <code>StadtTest.java</code> den Konstruktoraufruf der <code>Map</code> von <code>HashMap</code> nach <code>TreeMap</code> und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen (<code>MyInteger cannot be cast to class java.lang.Comparable</code>). Implementieren Sie f\u00fcr <code>MyInteger</code> das Interface <code>Comparable&lt;MyInteger&gt;</code> so, dass nach den Gr\u00f6\u00dfen der Werte sortiert wird. F\u00fchren Sie dann erneut <code>StadtTest.java</code> aus. Es sollte folgende Ausgabe f\u00fcr die <code>Map</code> erzeugt werden:</p> <pre><code>------------ Maps --------------\n1  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n2  Hamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n3  Muenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n4  Koeln              405,02 km2      962.884   1.007.119   1.075.935\n5  Frankfurt/Main     248,31 km2      648.550     679.664     736.414\n6  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> <li> <p>\u00c4ndern Sie <code>compareTo()</code> in <code>MyInteger</code> so, dass die Werte der Schl\u00fcssel absteigend sortiert werden und f\u00fchren Sie dann <code>StadtTest.java</code> erneut aus. Es sollte folgende Ausgabe erzeugt werden:</p> <pre><code>------------ Maps --------------\n6  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n5  Frankfurt/Main     248,31 km2      648.550     679.664     736.414\n4  Koeln              405,02 km2      962.884   1.007.119   1.075.935\n3  Muenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n2  Hamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n1  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> <li> <p>Zusatz: Schreiben Sie in <code>StadtTest.java</code> eine Methode <code>public static boolean contains(Map&lt;MyInteger, Stadt&gt; staedteMap, Stadt stadt)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Stadt <code>stadt</code> bereits in der <code>staedteMap</code> als ein <code>value</code> existiert. Testen Sie die Methode, indem Sie zur Menge nur dann die <code>stadt</code> hinzuf\u00fcgen, wenn sie nicht bereits in der Menge aufgef\u00fchrt ist. Sie sollten folgende Ausgabe erhalten: </p> <pre><code>------------ Maps --------------\n5  Frankfurt/Main     248,31 km2      648.550     679.664     736.414\n4  Koeln              405,02 km2      962.884   1.007.119   1.075.935\n3  Muenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n2  Hamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n1  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 8 Stadt.javaMyInteger.javaStadtTest.java <pre><code>package uebungen.uebung8;\n\nimport java.util.*;\n\npublic class Stadt implements Comparable&lt;Stadt&gt;\n{\n    String name;\n    List&lt;Integer&gt; bevoelkerung;\n    float flaeche;\n\n    public Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche)\n    {\n        super();\n        this.name = name;\n        this.bevoelkerung = bevoelkerung;\n        this.flaeche = flaeche;\n    }\n\n    void print()\n    {\n        System.out.printf(\"%-18s %.2f km%c\", this.name, this.flaeche, '\\u00B2');\n        for(Integer anzahl : this.bevoelkerung)\n        {\n            System.out.printf(\"%,14d\", anzahl);\n        }\n        System.out.println();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o==null) return false;\n        if(o==this) return true;\n        if(this.getClass()!=o.getClass()) return false;\n\n        Stadt other = (Stadt)o;\n        return (this.name.equals(other.name));\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.name.hashCode();\n    }\n\n    @Override\n    public int compareTo(Stadt o) \n    {\n        //return o.name.compareTo(this.name);\n        if(this.flaeche &gt; o.flaeche) return 1;\n        else if(this.flaeche &lt; o.flaeche) return -1;\n        else return 0;\n    }\n\n}\n</code></pre> <pre><code>package uebungen.uebung8;\n\npublic class MyInteger implements Comparable&lt;MyInteger&gt;\n{\n    private int value;\n\n    public MyInteger(int value)\n    {\n        this.value = value;\n    }\n\n    public int intValue()\n    {\n        return this.value;\n    }\n\n    public static MyInteger valueOf(int value)\n    {\n        return new MyInteger(value);\n    }\n\n    @Override\n    public int compareTo(MyInteger o) \n    {\n        return (this.value - o.value);\n    }\n\n}\n</code></pre> <pre><code>package uebungen.uebung8;\n\nimport java.util.*;\n\npublic class StadtTest\n{\n    public static Stadt[] staedte()\n    {\n        Stadt[] staedte = new Stadt[6];\n        List&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\n        berlinBevoelkerung.add(3382169);    \n        berlinBevoelkerung.add(3460725);    \n        berlinBevoelkerung.add(3574830);\n        staedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n        List&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\n        hamburgBevoelkerung.add(1715392);   \n        hamburgBevoelkerung.add(1786448);   \n        hamburgBevoelkerung.add(1810438);   \n        staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\n        List&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\n        muenchenBevoelkerung.add(1210223);  \n        muenchenBevoelkerung.add(1353186);  \n        muenchenBevoelkerung.add(1464301);\n        staedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\n        List&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\n        koelnBevoelkerung.add(962884);  \n        koelnBevoelkerung.add(1007119); \n        koelnBevoelkerung.add(1075935); \n        staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\n        List&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\n        frankfurtBevoelkerung.add(648550);  \n        frankfurtBevoelkerung.add(679664);  \n        frankfurtBevoelkerung.add(736414);\n        staedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\n        berlinBevoelkerung = new ArrayList&lt;&gt;();\n        berlinBevoelkerung.add(3382169);    \n        berlinBevoelkerung.add(3460725);    \n        berlinBevoelkerung.add(3574830);\n        staedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\n        return staedte;\n    }\n\n    public static boolean contains(Map&lt;MyInteger, Stadt&gt; staedteMap, Stadt stadt)\n    {\n        /*\n        // ueber alle Values\n        Collection&lt;Stadt&gt; alleStaedte = staedteMap.values();\n        for(Stadt s : alleStaedte)\n        {\n            if(s.equals(stadt)) return true;\n        }\n        return false;\n        */\n\n        /*\n        // ueber alle Keys\n        Set&lt;MyInteger&gt; alleSchluessel = staedteMap.keySet();\n        for(MyInteger schluessel : alleSchluessel)\n        {\n            Stadt s = staedteMap.get(schluessel);\n            if(s.equals(stadt)) return true;\n        }\n        return false;\n        */\n\n        // uber alle Schluessel-Werte-Paare\n        Set&lt;Map.Entry&lt;MyInteger, Stadt&gt;&gt; alleEintraege = staedteMap.entrySet();\n        for(Map.Entry&lt;MyInteger, Stadt&gt; eintrag : alleEintraege)\n        {\n            Stadt s = eintrag.getValue();\n            if(s.equals(stadt)) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n------------ Menge --------------%n\");\n        Set&lt;Stadt&gt; staedteMenge = new TreeSet&lt;&gt;();\n        for(Stadt s : staedte())\n        {\n            staedteMenge.add(s);\n        }\n        for(Stadt s : staedteMenge)\n        {\n            s.print();\n        }\n\n        System.out.printf(\"%n------------ Maps --------------%n\");\n        Map&lt;MyInteger, Stadt&gt; staedteMap = new TreeMap&lt;&gt;();\n        int i = 1;\n        for(Stadt s : staedte())\n        {\n            if(!contains(staedteMap, s)) {\n                staedteMap.put(new MyInteger(i++), s);\n            }\n        }\n        for(Map.Entry&lt;MyInteger, Stadt&gt; entry : staedteMap.entrySet())\n        {\n            MyInteger key = entry.getKey();\n            System.out.printf(\"%-3d\",key.intValue());\n            entry.getValue().print();\n        }\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-9-lambdas-functional-interface-comparator","title":"\u00dcbung 9 (Lambdas + Functional Interface Comparator)","text":"\u00dcbung 9 <p>Vorbereitung</p> <ol> <li> <p>Kopieren Sie folgende Klassen in Ihr Package <code>uebungen.uebung9</code> (oder <code>package</code> anpassen):</p> Student.javaUebung9.java <pre><code>package uebungen.uebung9;\n\npublic record Student(String name, String registrationNumber, int age, double gradePointAverage, int semester)\n{\n    // record besitzt automatisch alle Getter (aber ohne get im Namen :-( )\n    // record besitzt automatisch equals(), hashCode() und toString()\n    // toString() ueberschreiben wir aber lieber selbst:\n    @Override\n    public String toString()\n    {\n        return String.format(\"(%-8s, %s, %2d Jahre, %d. Semester, %c%.1f)\",\n                this.name, this.registrationNumber, this.age, this.semester, '\\u2300', this.gradePointAverage);\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung9;\n\nimport java.util.*;\n\npublic class Uebung9\n{\n    private static List&lt;Student&gt; generateMockupData(int length) {\n        List&lt;Student&gt; studentsList = new ArrayList&lt;&gt;();\n        String[] names = {\"Alex\", \"Jamie\", \"Jordan\", \"Taylor\", \"Morgan\",\n                \"Riley\", \"Casey\", \"Drew\", \"Reese\", \"Quinn\",\n                \"Sydney\", \"Dakota\", \"Avery\", \"Blake\", \"Cameron\",\n                \"Harper\", \"Hayden\", \"Charlie\", \"Bailey\", \"Peyton\",\n                \"Skyler\", \"Jesse\", \"Kendall\", \"Logan\", \"Parker\",\n                \"Rowan\", \"Sawyer\", \"Finley\", \"Skylar\", \"Emerson\"};  // hat ChatGPT gemacht\n        Random random = new Random();\n\n        for (int i = 0; i &lt; length; i++) {\n            String name = names[random.nextInt(names.length)];\n            int number = 10000 + random.nextInt(90000);\n            String registrationNumber = \"s05\" + number;\n            int age = 18 + random.nextInt(20);                    // Alter zwischen 18 und 37\n            double gradePointAverage = 1.0 + random.nextDouble() * 3.0; // GPA zwischen 1.0 und 4.0\n            int semester = 1 + random.nextInt(9);                 // Semester zwischen 1 and 9\n\n            studentsList.add(new Student(name, registrationNumber, age, gradePointAverage, semester));\n        }\n        return studentsList;\n    }\n\n    public static void printStudents(List&lt;Student&gt; students)\n    {\n        for(Student student : students)\n        {\n            student.print();\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        List&lt;Student&gt; students = generateMockupData(15);\n        printStudents(students);\n\n        System.out.printf(\"%n%n----------- Namen aufsteigend --------------%n%n\");\n\n    }\n}\n</code></pre> </li> </ol> <p>Vorbetrachtungen</p> <ol> <li>In dem Interface List gibt es die Sortiermethode <code>sort(Comparator&lt;T&gt; c)</code>. Diese erwartet ein Comparator-Objekt.</li> <li>Comparator ist ein Functional Interface mit der single abstract method (SAM) <code>compare(T o1, T o2)</code>. \u00dcberall, wo ein <code>Comparator</code> erwartet wird (siehe hier), kann also z.B. ein Lambda mit 2 Parametern, z.B. <code>(o1, o2) -&gt; o1.compareTo(o2)</code> \u00fcbergeben werden. </li> <li>Comparator besitzt au\u00dferdem eine statische erzeugende <code>default</code>-Methode <code>comparing(Function keyExtractor, Comparator keyComparator)</code>. Diese gibt ein <code>Comparator</code>-Objekt zur\u00fcck. Eine Function wendet eine Funktion (Methode) auf ein Argument an, z.B. <code>o1 -&gt; o1.name()</code> wendet den getter <code>name()</code> auf das <code>o1</code>-Objekt an. Hier bietet sich jedoch Methodenreferenz an, z.B. <code>Student::name</code>. Mit der <code>Function</code> kann definiert (extrahiert) werden, welche Schl\u00fcssel zum Vergleich verwendet werden. </li> </ol> <p>Aufgabe</p> <ol> <li>\u00c4ndern Sie die <code>printStudents()</code> so, dass die <code>forEach(Consumer action)</code>-Methode f\u00fcr Listen angewendet wird (kommt aus Iterable - einem Interface, das Listen implementiert haben). Ein Consumer ist \u00e4hnlich einer <code>Function</code> (erwartet ein Argument), gibt aber nichts zur\u00fcck. Es bieten sich also die <code>System.out.println()</code>-Methode oder die <code>print()</code>-Methode aus <code>Student</code> an. </li> <li>Sortieren Sie die <code>studentsList</code> nach jeweils Matrikelnummer und Namen, jeweils auf- und absteigend (4 Sortierungen). </li> <li>Schauen Sie sich die <code>comparingDouble(ToDoubleFunction keyExtractor)</code>-Methode in Comparator an. Wie kann sie verwendet werden, um nach den Noten zu sortieren? Finden Sie in Comparator eine M\u00f6glichkeit, um nach Noten absteigend zu sortieren? </li> <li>Die statische erzeugende Methode <code>naturalOrder()</code> erzeugt ein <code>Comparator</code>-Objekt, das verwendet werden kann, um Objekte in ihrer \"nat\u00fcrlichen Ordnung\" zu sortieren. Wenn wir jedoch <code>Comparator&lt;Student&gt; naturalOrder = Comparator.naturalOrder();</code> eingeben, erhalten wir einen Fehler. Warum und wie l\u00e4sst er sich beheben? </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 9 Uebung9.java <pre><code>package uebungen.uebung9;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Random;\n\npublic class Uebung9\n{\n    private static List&lt;Student&gt; generateMockupData(int length) {\n        List&lt;Student&gt; studentsList = new ArrayList&lt;&gt;();\n\n        String[] names = {\"Alex\", \"Jamie\", \"Jordan\", \"Taylor\", \"Morgan\",\n                \"Riley\", \"Casey\", \"Drew\", \"Reese\", \"Quinn\",\n                \"Sydney\", \"Dakota\", \"Avery\", \"Blake\", \"Cameron\",\n                \"Harper\", \"Hayden\", \"Charlie\", \"Bailey\", \"Peyton\",\n                \"Skyler\", \"Jesse\", \"Kendall\", \"Logan\", \"Parker\",\n                \"Rowan\", \"Sawyer\", \"Finley\", \"Skylar\", \"Emerson\"};  // hat ChatGPT gemacht\n\n        Random random = new Random();\n\n        for (int i = 0; i &lt; length; i++) {\n            String name = names[random.nextInt(names.length)];\n            int number = 10000 + random.nextInt(90000);\n            String registrationNumber = \"s05\" + number;\n            int age = 18 + random.nextInt(20);                    // Alter zwischen 18 und 37\n            double gradePointAverage = 1.0 + random.nextDouble() * 3.0; // GPA zwischen 1.0 und 4.0\n            int semester = 1 + random.nextInt(9);                 // Semester zwischen 1 and 9\n\n            // Liste befuellen\n            studentsList.add(new Student(name, registrationNumber, age, gradePointAverage, semester));\n        }\n        return studentsList;\n    }\n\n    public static void printStudents(List&lt;Student&gt; students)\n    {\n        /*\n        for(Student student : students)\n        {\n            student.print();\n        }\n        */\n         students.forEach( s -&gt; s.print() );\n    }\n\n    public static void main(String[] args)\n    {\n        List&lt;Student&gt; students = generateMockupData(15);\n        printStudents(students);\n\n        // das geht\n        Comparator&lt;Student&gt; nachNamenAufsteigend = (s1, s2) -&gt; s1.name().compareTo(s2.name());\n\n        // oder das\n        nachNamenAufsteigend = new Comparator&lt;Student&gt;() {\n            @Override\n            public int compare(Student o1, Student o2)\n            {\n                return o1.name().compareTo(o2.name());\n            }\n        };\n\n        // oder das\n        nachNamenAufsteigend = Comparator.comparing( s -&gt; s.name() );\n\n\n        System.out.printf(\"%n%n----------- Namen aufsteigend --------------%n%n\");\n        students.sort( nachNamenAufsteigend );\n        printStudents(students);\n\n        System.out.printf(\"%n%n----------- Namen absteigend --------------%n%n\");\n        //students.sort( (s1, s2) -&gt; -s1.name().compareTo(s2.name()) );\n        students.sort( nachNamenAufsteigend.reversed() );\n        printStudents(students);\n\n        System.out.printf(\"%n%n----------- Noten aufsteigend --------------%n%n\");\n        students.sort( (s1, s2) -&gt; {\n            if (s1.gradePointAverage() &gt; s2.gradePointAverage()) return 1;\n            else if (s1.gradePointAverage() &lt; s2.gradePointAverage()) return -1;\n            else return 0;\n        } );\n\n        Comparator&lt;Student&gt; nachNotenAufsteigend = Comparator.comparingDouble( s -&gt; s.gradePointAverage() );\n\n        System.out.printf(\"%n%n----------- Natural order --------------%n%n\");\n        Comparator&lt;Student&gt; naturalOrder = Comparator.naturalOrder();\n        students.sort( naturalOrder );      // dazu muss Comparable&gt;Student&gt; in Student implementiert werden!!!\n        printStudents(students);\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-10-streams","title":"\u00dcbung 10 (Streams)","text":"\u00dcbung 10 <p>Vorbereitung</p> <ol> <li> <p>Wir nehmen wieder exakt die gleichen Klassen, wie in \u00dcbung 9. Entweder Sie machen einfach in \u00dcbung 9 weiter oder Sie kopieren folgende Klassen in Ihr Package <code>uebungen.uebung10</code> (oder <code>package</code> anpassen):</p> Student.javaUebung10.java <pre><code>package uebungen.uebung10;\n\npublic record Student(String name, String registrationNumber, int age, double gradePointAverage, int semester)\n{\n    // record besitzt automatisch alle Getter (aber ohne get im Namen :-( )\n    // record besitzt automatisch equals(), hashCode() und toString()\n    // toString() ueberschreiben wir aber lieber selbst:\n    @Override\n    public String toString()\n    {\n        return String.format(\"(%-8s, %s, %2d Jahre, %d. Semester, %c%.1f)\",\n                this.name, this.registrationNumber, this.age, this.semester, '\\u2300', this.gradePointAverage);\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung10;\n\nimport java.util.*;\n\npublic class Uebung10\n{\n    private static List&lt;Student&gt; generateMockupData(int length) {\n        List&lt;Student&gt; studentsList = new ArrayList&lt;&gt;();\n        String[] names = {\"Alex\", \"Jamie\", \"Jordan\", \"Taylor\", \"Morgan\",\n                \"Riley\", \"Casey\", \"Drew\", \"Reese\", \"Quinn\",\n                \"Sydney\", \"Dakota\", \"Avery\", \"Blake\", \"Cameron\",\n                \"Harper\", \"Hayden\", \"Charlie\", \"Bailey\", \"Peyton\",\n                \"Skyler\", \"Jesse\", \"Kendall\", \"Logan\", \"Parker\",\n                \"Rowan\", \"Sawyer\", \"Finley\", \"Skylar\", \"Emerson\"};  // hat ChatGPT gemacht\n        Random random = new Random();\n\n        for (int i = 0; i &lt; length; i++) {\n            String name = names[random.nextInt(names.length)];\n            int number = 10000 + random.nextInt(90000);\n            String registrationNumber = \"s05\" + number;\n            int age = 18 + random.nextInt(20);                    // Alter zwischen 18 und 37\n            double gradePointAverage = 1.0 + random.nextDouble() * 3.0; // GPA zwischen 1.0 und 4.0\n            int semester = 1 + random.nextInt(9);                 // Semester zwischen 1 and 9\n\n            studentsList.add(new Student(name, registrationNumber, age, gradePointAverage, semester));\n        }\n        return studentsList;\n    }\n\n    public static void printStudents(List&lt;Student&gt; students)\n    {\n        for(Student student : students)\n        {\n            student.print();\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        List&lt;Student&gt; students = generateMockupData(15);\n        printStudents(students);\n\n        System.out.printf(\"%n%n----------- Liste von Namen erzeugen --------------%n%n\");\n\n    }\n}\n</code></pre> </li> </ol> <p>Aufgabe</p> <ol> <li> <p>Erzeugen Sie eine Liste aller Namen aus <code>students</code>. Achten Sie darauf, dass kein Name doppelt vorkommt. </p> </li> <li> <p>Erzeugen Sie eine Liste aller Studierenden aus <code>students</code>, die \u00e4lter als 23 Jahre alt sind. </p> </li> <li> <p>Ermitteln Sie die Studierende mit dem besten Notendurchschnitt. </p> </li> <li> <p>Ermitteln Sie die Studierende mit dem besten Notendurchschnitt, die mindestens im 6. Semester ist. </p> </li> <li> <p>Berechnen Sie den Altersdurchschnitt aller Studierenden aus <code>students</code>. </p> </li> <li> <p>Erzeugen Sie eine <code>Map</code>, die alle Studierende aus <code>students</code> nach Semestern gruppiert.</p> </li> <li> <p>Wir denken uns noch weitere solcher Aufgaben aus, falls noch Zeit ist ...</p> </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 10 Uebung10.java <pre><code>package uebungen.uebung10b;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Uebung10\n{\n    private static List&lt;Student&gt; generateMockupData(int length) {\n        List&lt;Student&gt; studentsList = new ArrayList&lt;&gt;();\n        String[] names = {\"Alex\", \"Jamie\", \"Jordan\", \"Taylor\", \"Morgan\",\n                \"Riley\", \"Casey\", \"Drew\", \"Reese\", \"Quinn\",\n                \"Sydney\", \"Dakota\", \"Avery\", \"Blake\", \"Cameron\",\n                \"Harper\", \"Hayden\", \"Charlie\", \"Bailey\", \"Peyton\",\n                \"Skyler\", \"Jesse\", \"Kendall\", \"Logan\", \"Parker\",\n                \"Rowan\", \"Sawyer\", \"Finley\", \"Skylar\", \"Emerson\"};  // hat ChatGPT gemacht\n        Random random = new Random();\n\n        for (int i = 0; i &lt; length; i++) {\n            String name = names[random.nextInt(names.length)];\n            int number = 10000 + random.nextInt(90000);\n            String registrationNumber = \"s05\" + number;\n            int age = 18 + random.nextInt(20);                    // Alter zwischen 18 und 37\n            double gradePointAverage = 1.0 + random.nextDouble() * 3.0; // GPA zwischen 1.0 und 4.0\n            int semester = 1 + random.nextInt(9);                 // Semester zwischen 1 and 9\n\n            studentsList.add(new Student(name, registrationNumber, age, gradePointAverage, semester));\n        }\n        return studentsList;\n    }\n\n    public static void printStudents(List&lt;Student&gt; students) {\n        for(Student student : students)\n        {\n            student.print();\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        List&lt;Student&gt; students = generateMockupData(15);\n        printStudents(students);\n\n        System.out.printf(\"%n%n----------- Liste von Namen erzeugen --------------%n%n\");\n        List&lt;String&gt; namensListe = students.stream()\n                .map( s -&gt; s.name() )  // Student-Stream nach String-Stream\n                .distinct()                     // doppelte Namen entfernen\n                .collect(Collectors.toList());\n        namensListe.forEach( s -&gt; System.out.println(s) );\n\n        System.out.printf(\"%n%n----------- Liste von Namen erzeugen mit Doppelungen--------------%n%n\");\n        students.stream()\n                .map( s -&gt; s.name() )  // Student-Stream nach String-Stream\n                //.distinct()\n                .forEach( s -&gt; System.out.println(s) );\n\n\n        System.out.printf(\"%n%n----------- Liste von Students \u00e4lter als 23 --------------%n%n\");\n        List&lt;Student&gt; studentsAelter23 = students.stream()\n                .filter( s -&gt; s.age() &gt; 23 )\n                .collect(Collectors.toList());\n        studentsAelter23.forEach( s -&gt; System.out.println(s) );\n\n        System.out.printf(\"%n%n----------- Beste Studentin --------------%n%n\");\n        Student beste = students.stream()\n                .min( Comparator.comparingDouble( s -&gt; s.gradePointAverage() ) )\n                .get();\n        System.out.println(beste.toString());\n\n\n        System.out.printf(\"%n%n----------- Beste Studentin mind. 6 Semester--------------%n%n\");\n        Student besteMind6Sem = students.stream()\n                .filter( s -&gt; s.semester() &gt;= 6 )\n                .min( Comparator.comparingDouble( s -&gt; s.gradePointAverage() ) )\n                .get();\n        System.out.println(besteMind6Sem.toString());\n\n        System.out.printf(\"%n%n----------- Notendurchschnitt --------------%n%n\");\n        double notendurchschnitt = students.stream()\n                .mapToDouble( s -&gt; s.gradePointAverage() )\n                .average()\n                .getAsDouble();\n        System.out.println(notendurchschnitt);\n\n        System.out.printf(\"%n%n----------- Altersdurchschnitt --------------%n%n\");\n        double altersdurchschnitt = students.stream()\n                .mapToInt( s -&gt; s.age() )\n                .average()\n                .getAsDouble();\n        System.out.println(altersdurchschnitt);\n\n        System.out.printf(\"%n%n----------- gruppiert nach Semestern --------------%n%n\");\n        Map&lt;Integer, List&lt;Student&gt;&gt; gruppiertNachSemester = students.stream()\n                .collect(Collectors.groupingBy(s -&gt; s.semester()));\n\n        gruppiertNachSemester.entrySet()\n                .forEach( gruppiert -&gt; System.out.println(\n                                gruppiert.getKey()\n                                + \" : \"\n                                + gruppiert.getValue()));\n\n        System.out.printf(\"%n%n----------- andere Ausgabe --------------%n%n\");\n        for(Map.Entry&lt;Integer, List&lt;Student&gt;&gt; entry : gruppiertNachSemester.entrySet())\n        {\n            Integer key = entry.getKey();\n            List&lt;Student&gt; value = entry.getValue();\n            System.out.println(\"------- \" + key + \". Semester -------------\");\n            value.forEach( student -&gt; System.out.println(student));\n            System.out.println();\n        }\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-11-streams","title":"\u00dcbung 11 (Streams)","text":"\u00dcbung 11 (Streams) <ul> <li>Wir betrachten die Klasse Random aus dem <code>java.util</code>-Paket. </li> <li>Wie w\u00fcrden Sie vorgehen, um mithilfe dieser Klasse einen Stream mit <code>20</code> Zufallszahlen aus dem Bereich <code>[1 ... 99]</code> (beides inklusive) zu erzeugen? <ul> <li>Geht es mit allen Varianten der <code>ints()</code>-Methode?</li> <li>F\u00fcr <code>IntStream</code> gibt es kein <code>collect(Collector c)</code>. Was tun?</li> </ul> </li> <li>Wenn wir mithilfe von <code>Random r = new Random();</code> ein <code>Random</code>-Objekt erzeugen, k\u00f6nnen wir die Methode <code>r.nextInt(int lowerBound, int upperBound)</code> anwenden. Diese Methode kommt aber in der Beschreibung von Random gar nicht vor. Woher kommt sie?</li> <li>W\u00e4hrend <code>groupingBy()</code> in Collectors eine <code>Function</code> erwartet, kann <code>partitioningBy()</code> ein <code>Predicate</code> \u00fcbergeben werden. Erzeugen Sie mithilfe einer der <code>ints()</code>-Methoden einen <code>IntStream</code> von <code>20</code> Zufallszahlen aus dem Bereich <code>[1 ... 99]</code> (beides inklusive) und partitionieren Sie diesen in gerade und ungerade Zahlen mithilfe von <code>collect(Collectors.partitioningBy(Predicate p))</code>. Wie ist die entstehende <code>Map</code> typisiert? </li> <li>F\u00fcr <code>Map</code> gibt es keine <code>stream()</code>-Methode, f\u00fcr <code>Set</code> aber schon. Erzeugen Sie aus der obigen <code>Map</code> wieder einen <code>Stream</code>! </li> <li>Wir erhalten einen Stream aus Listen. Mithilfe der Methode <code>flatMap(Function mapper)</code> kann ein solcher Stream wieder zu einem Stream aus Elementen \"flachgedr\u00fcckt\" werden. Wie w\u00fcrde das aussehen? <ul> <li>Speichern Sie den so erhaltenen Stream in eine <code>List&lt;Integer&gt;</code>.</li> <li>Sorgen Sie daf\u00fcr, dass in der Liste sowohl die ungeraden als auch die geraden Zahlen jeweils sortiert sind.</li> <li>Sorgen Sie daf\u00fcr, dass in der Liste erst alle geraden und dann erst alle ungeraden Zahlen aufgef\u00fchrt sind. </li> </ul> </li> </ul> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 11 Uebung11.java <pre><code>package uebungen.uebung11;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Uebung11\n{\n    public static void main(String[] args)\n    {\n        Random r = new Random();\n        IntStream s1 = r.ints(20, 1, 100);\n        s1.forEach(s -&gt; System.out.print(s + \" \"));\n        System.out.println();\n\n        IntStream s2 = r.ints(1, 100).limit(20);\n        //s2.forEach(s -&gt; System.out.print(s + \" \"));\n        List&lt;Integer&gt; listS2 = s2.boxed().collect(Collectors.toList());\n        listS2.forEach(s -&gt; System.out.print(s + \" \"));\n        System.out.println();\n\n        IntStream s3 = r.ints().filter(i -&gt; i &gt; 0 &amp;&amp; i &lt; 100).limit(20);\n        Map&lt;Boolean, List&lt;Integer&gt;&gt; mapS3 = s3.boxed().collect(Collectors.partitioningBy(n -&gt; n % 2 == 0 ));\n\n        mapS3.forEach( (k, v) -&gt; System.out.print(k + \" \" + v));\n        System.out.println();\n        List&lt;Integer&gt; listMapS3 = mapS3.entrySet().stream()\n                .sorted( (e1, e2) -&gt; e2.getKey().compareTo(e1.getKey()))\n                .flatMap( e -&gt; e.getValue().stream().sorted() )\n                //.forEach( i -&gt; System.out.print(i + \" \"));\n                .collect(Collectors.toList());\n        listMapS3.forEach( s -&gt; System.out.print(s + \" \"));\n        System.out.println();\n        //s3.forEach(s -&gt; System.out.print(s + \" \"));\n        System.out.println();\n\n        //r.nextInt(1,100);\n    }\n}\n</code></pre>"},{"location":"uebungen/#ubung-12-junit","title":"\u00dcbung 12 (JUnit)","text":"\u00dcbung 12 (JUnit) <ul> <li>Probieren Sie sich mit <code>JUnit</code> aus! Schreiben Sie Unit-Tests f\u00fcr Ihre <code>MyInteger</code>-Klasse aus Aufgabe 2.  </li> <li>Testen Sie z.B. f\u00fcr <code>parseInt()</code>:     <pre><code>    \"1234\"          -&gt; 1234\n    \"+1234\"         -&gt; 1234\n    \"01234\"         -&gt; 1234\n    \"-1234\"         -&gt; -1234\n    \"-01234\"        -&gt; -1234\n    null            -&gt; Exception (IAE) kein String\n    \"\"              -&gt; Exception (IAE) leerer String\n    \"+\"             -&gt; Exception (IAE) nur '+' bzw. '-' --&gt; keine Zahl\n    \"-\"             -&gt; Exception (IAE) nur '+' bzw. '-' --&gt; keine Zahl\n    \"-00000000\"     -&gt; 0\n    \"+00000000\"     -&gt; 0\n    \"-00000001\"     -&gt; -1\n    \"+00000001\"     -&gt;  1\n    \"123456a\"       -&gt; Exception (IAE) keine Zahl!\n    \"-123456a\"      -&gt; Exception (IAE) keine Zahl!\n    \"+123456a\"      -&gt; Exception (IAE) keine Zahl!\n    \"2147483648\"    -&gt; Exception (IAE) Zahl zu gross!\n    \"-2147483649\"   -&gt; Exception (IAE) Zahl zu klein!\n</code></pre></li> </ul> MyInteger.java MyInteger.java <pre><code>package testen;\n\npublic class MyInteger\n{\n    public static final int MAX_VALUE = 2147483647;\n    public static final int MIN_VALUE = -2147483648;\n\n    private int value;\n\n    public MyInteger(int value)\n    {\n        this.value=value;\n    }\n\n    public MyInteger(String s) throws IllegalArgumentException\n    {\n        this.value = parseInt(s);\n    }\n\n    private static boolean isDigit(char c)\n    {\n        return (c=='0' || c=='1' || c=='2' || c=='3' || c=='4' || c=='5' ||\n                c=='6' || c=='7' || c=='8' || c=='9');\n    }\n\n    private static int charToInt(char c)\n    {\n        int asciivalue = c;\n        int intvalue = asciivalue-48; // 0 ist 48 bis 9 ist 57\n        return intvalue;\n    }\n\n    public static int parseInt(String s) throws IllegalArgumentException\n    {\n        if(s == null) throw new IllegalArgumentException(\"kein String\");\n        if(s.length()==0) throw new IllegalArgumentException(\"leerer String\");\n        // pruefe, ob erstes Zeichen + oder -\n        // merken und weiter mit Rest\n        boolean negativ = false;\n        if(s.charAt(0)=='+') s = s.substring(1);\n        else if(s.charAt(0)=='-')\n        {\n            s = s.substring(1);\n            negativ = true;\n        }\n        if(s.length()==0) throw new IllegalArgumentException(\"nur '+' bzw. '-' --&gt; keine Zahl\");\n        // entferne fuehrende Nullen\n        while(s.length() &gt; 0 &amp;&amp; s.charAt(0)=='0')\n        {\n            s = s.substring(1);\n        }\n        if(s.length()==0) return 0;     // String bestand nur aus Nullen --&gt; 0\n        for(int i=0; i&lt;s.length(); i++)\n        {\n            if(!isDigit(s.charAt(i))) throw new IllegalArgumentException(\"keine Zahl!\");\n        }\n\n        int zahl = 0;\n        for(int i = 0; i &lt; s.length(); i++)\n        {\n            int ziffer = charToInt(s.charAt(i));\n            if((!negativ &amp;&amp; (MyInteger.MAX_VALUE - ziffer) / 10 &lt; zahl) || (negativ &amp;&amp; (MyInteger.MAX_VALUE+1 - ziffer) / 10 &lt; zahl))\n            {\n                if(negativ) throw new IllegalArgumentException(\"Zahl zu klein!\");\n                else throw new IllegalArgumentException(\"Zahl zu gross!\");\n            }\n            zahl = zahl * 10 + ziffer;\n        }\n        if(negativ) return -zahl;\n        else return zahl;\n    }\n\n    public int intValue()\n    {\n        return this.value;\n    }\n\n    public double doubleValue()\n    {\n        return this.value;\n    }\n\n    public static MyInteger valueOf(String s) throws IllegalArgumentException\n    {\n        return new MyInteger(s);\n    }\n\n    public static MyInteger valueOf(int value)\n    {\n        return new MyInteger(value);\n    }\n\n    @Override\n    public boolean equals(Object other)\n    {\n        if(other == null) return false;\n        if(this == other) return true; \n        if(this.getClass() != other.getClass()) return false;   \n\n        MyInteger otherInt = (MyInteger)other;  \n        return (this.value == otherInt.value); \n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return value+\"\";\n    }\n\n    public static int compare(int x, int y)\n    {\n        return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);\n    }\n\n    public int compareTo(MyInteger otherMyInteger)\n    {\n        return compare(this.value, otherMyInteger.value);\n    }\n}\n</code></pre> eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 12 (JUnit) MyIntegerTest.java <pre><code>package uebungen.uebung10.loesung;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nclass MyIntegerTest {\n\n    static MyInteger mi1, mi2, mi3, mi4, mi5, mi6, mi7;\n\n    @BeforeAll\n    public static void setUpBeforeClass() throws Exception \n    {\n        mi1 = new MyInteger(\"-2147483648\");\n        mi2 = new MyInteger(\"+2147483647\");\n        mi3 = new MyInteger(-1);\n        mi4 = new MyInteger(1);\n        mi5 = new MyInteger(0);\n        mi6 = new MyInteger(\"-1\");\n        mi7 = new MyInteger(2147483647);\n\n    }\n\n    /*\n     * parseInt-Testfaelle:\n     *  null        -&gt; Exception (IAE) kein String\n     *  \"\"          -&gt; Exception (IAE) leerer String\n     *  \"+\"         -&gt; Exception (IAE) nur '+' bzw. '-' --&gt; keine Zahl\n     *  \"-\"         -&gt; Exception (IAE) nur '+' bzw. '-' --&gt; keine Zahl\n     *  \"-00000000\" -&gt; 0\n     *  \"+00000000\" -&gt; 0\n     *  \"-00000001\" -&gt; -1\n     *  \"+00000001\" -&gt;  1\n     *  \"123456a\"   -&gt; Exception (IAE) keine Zahl!\n     *  \"-123456a\"  -&gt; Exception (IAE) keine Zahl!\n     *  \"+123456a\"  -&gt; Exception (IAE) keine Zahl!\n     *  \"2147483648\"    -&gt; Exception (IAE) Zahl zu gross!\n     *  \"-2147483649\"   -&gt; Exception (IAE) Zahl zu klein!\n     * \n     */\n    @Test\n    void testParseIntPositiveInt() {\n\n        assertEquals(1234, MyInteger.parseInt(\"1234\"), \"\\\"1234\\\" should be 1234\");\n        assertEquals(1234, MyInteger.parseInt(\"+1234\"), \"\\\"+1234\\\" should be 1234\");\n        assertEquals(1234, MyInteger.parseInt(\"01234\"), \"\\\"01234\\\" should be 1234\");\n    }\n\n    @Test\n    void testParseIntNegativeInt() {\n\n        assertEquals(-1234, MyInteger.parseInt(\"-1234\"), \"\\\"-1234\\\" should be -1234\");\n        assertEquals(-1234, MyInteger.parseInt(\"-01234\"), \"\\\"-01234\\\" should be -1234\");\n    }\n\n    @Test\n    void testValueOfPositiveInt() {\n        MyInteger m = MyInteger.valueOf(1234);\n\n        assertNotNull(m, \"shoul be an object\");\n        assertEquals(1234, m.intValue(), \"1234 should be 1234\");\n    }\n\n    @Test\n    @DisplayName(\"Input-String is null\")\n    void testParseIntNull() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; MyInteger.parseInt(null));\n\n        assertEquals(\"kein String\", exception.getMessage());\n    }\n\n    @Test\n    @DisplayName(\"Input-String is leer\")\n    void testParseIntLeer() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; MyInteger.parseInt(\"\"));\n\n        assertEquals(\"leerer String\", exception.getMessage());\n    }\n\n\n    @Test\n    @DisplayName(\"Nur Plus oder Minus\")\n    void testParseIntNurPlusOderMinus() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; MyInteger.parseInt(\"+\"));\n\n        assertEquals(\"nur '+' bzw. '-' --&gt; keine Zahl\", exception.getMessage());\n\n        exception = assertThrows(IllegalArgumentException.class, () -&gt; MyInteger.parseInt(\"-\"));\n\n        assertEquals(\"nur '+' bzw. '-' --&gt; keine Zahl\", exception.getMessage());\n    }\n\n    @Test\n    @DisplayName(\"Keine Zahl\")\n    void testParseIntKeineZahl() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; MyInteger.parseInt(\"+1234a\"));\n\n        assertEquals(\"keine Zahl!\", exception.getMessage());\n\n    }\n\n    @Test\n    @DisplayName(\"Zahl zu gross\")\n    void testParseIntZahlZuGross() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; MyInteger.parseInt(\"2147483648\"));\n\n        assertEquals(\"Zahl zu gross!\", exception.getMessage());\n    }\n\n    @Test\n    @DisplayName(\"Zahl zu klein\")\n    void testParseIntZahlZuKlein() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; MyInteger.parseInt(\"-2147483649\"));\n\n        assertEquals(\"Zahl zu klein!\", exception.getMessage());\n    }\n\n    @Test\n    void testParseIntNurNullen() {\n        assertEquals(0, MyInteger.parseInt(\"-000000000000\"), \"\\\"-000000000000\\\" should be 0\");\n        assertEquals(0, MyInteger.parseInt(\"+000000000000\"), \"\\\"+000000000000\\\" should be 0\");\n        assertEquals(0, MyInteger.parseInt(\"0000000000000\"), \"\\\"0000000000000\\\" should be 0\");\n    }\n\n    @Test\n    void testHashCode()\n    {\n        assertTrue(mi2.hashCode()==mi7.hashCode(), \"hashCode of mi2 and mi7 should be equal\");\n        assertEquals(-2147483648, mi1.hashCode(), \"hashCode of mi1 should be -2147483648\");\n        assertEquals(0, mi5.hashCode(), \"hashCode of mi5 should be 0\");\n    }\n\n    @Test\n    void testMyIntegerInt()\n    {\n        assertNotNull(mi4, \"mi4 should be not null\");\n        assertTrue(mi3.equals(mi6), \"mi3 and mi6 should be equal\");\n        assertTrue(mi7.equals(mi2), \"mi7 and mi2 should be equal\");\n    }\n\n    @Test\n    void testMyIntegerString()\n    {\n        assertNotNull(mi1, \"mi1 should be not null\");\n        assertNotNull(mi2, \"mi2 should be not null\");\n        assertNotNull(mi6, \"mi6 should be not null\");\n        assertTrue(mi3.equals(mi6), \"mi3 and mi6 should be equal\");\n        assertTrue(mi7.equals(mi2), \"mi7 and mi2 should be equal\");\n    }\n\n    @Test\n    void testParseInt()\n    {\n        assertEquals(-2147483648, MyInteger.parseInt(\"-2147483648\"), \"should be -2147483648\");\n        assertEquals(+2147483647, MyInteger.parseInt(\"+00002147483647\"), \"should be +2147483647\");\n        assertEquals(-1, MyInteger.parseInt(\"-0000001\"), \"should be -1\");   \n    }\n\n\n    @Test\n    void testIntValue()\n    {\n        assertEquals(-2147483648, mi1.intValue(), \"should be -2147483648\");\n        assertEquals(+2147483647, mi2.intValue(), \"should be +2147483647\");\n        assertEquals(+2147483647, mi7.intValue(), \"should be +2147483647\");\n    }\n\n    @Test\n    void testDoubleValue()\n    {\n        assertEquals(-2147483648.0, mi1.doubleValue(), \"should be -2147483648.0\");\n        assertEquals(+2147483647.0, mi2.doubleValue(), \"should be +2147483647.0\");\n        assertEquals(+2147483647.0, mi7.doubleValue(), \"should be +2147483647.0\");\n    }\n\n    @Test\n    void testValueOfString()\n    {\n        assertTrue(mi1.equals(MyInteger.valueOf(\"-2147483648\")), \"should be equal to mi1\");\n        assertTrue(mi2.equals(MyInteger.valueOf(\"2147483647\")), \"should be equal to mi2\");\n        assertTrue(mi7.equals(MyInteger.valueOf(\"2147483647\")), \"should be equal to mi7\");\n    }\n\n    @Test\n    void testValueOfInt()\n    {\n        assertTrue(mi1.equals(MyInteger.valueOf(-2147483648)), \"should be equal to mi1\");\n        assertTrue(mi2.equals(MyInteger.valueOf(2147483647)), \"should be equal to mi2\");\n        assertTrue(mi7.equals(MyInteger.valueOf(2147483647)), \"should be equal to mi7\");\n    }\n\n    @Test\n    void testEqualsObject()\n    {\n        assertTrue(mi3.equals(mi6), \"mi3 and mi6 should be equal\");\n        assertTrue(mi7.equals(mi2), \"mi7 and mi2 should be equal\");\n        assertFalse(mi3.equals(mi4), \"mi3 and mi4 should not be equal\");\n        assertFalse(mi3.equals(mi5), \"mi3 and mi5 should not be equal\");\n    }\n\n    @Test\n    void testToString()\n    {\n        assertEquals(\"-2147483648\", mi1.toString(), \"should be '-2147483648'\");\n        assertEquals(\"2147483647\", mi2.toString(), \"should be '2147483647' mi2\");\n        assertEquals(\"2147483647\", mi7.toString(), \"should be '2147483647' mi7\");\n    }\n\n    @Test\n    void testCompare()\n    {\n        assertTrue(MyInteger.compare(5, 4)&gt;0, \"5,4 should be &gt; 0\");\n        assertTrue(MyInteger.compare(4, 4)==0, \"4,4 should be == 0\");\n        assertTrue(MyInteger.compare(4, 5)&lt;0, \"4,5 should be &lt; 0\");\n        assertTrue(MyInteger.compare(MyInteger.MAX_VALUE, MyInteger.MIN_VALUE)&gt;0, \"MAX,MIN should be &gt; 0\");\n        assertTrue(MyInteger.compare(MyInteger.MAX_VALUE, MyInteger.MAX_VALUE)==0, \"MAX,MAX should be == 0\");\n        assertTrue(MyInteger.compare(MyInteger.MIN_VALUE, MyInteger.MAX_VALUE)&lt;0, \"MIN,MAX should be &gt; 0\");\n    }\n\n    @Test\n    void testCompareTo()\n    {\n        assertTrue(mi1.compareTo(mi2)&lt;0, \"mi1, mi2 should be &lt; 0\");\n        assertTrue(mi2.compareTo(mi1)&gt;0, \"mi2, mi1 should be &gt; 0\");\n        assertTrue(mi2.compareTo(mi7)==0, \"mi2, mi7 should be == 0\");\n        assertTrue(mi3.compareTo(mi6)==0, \"mi3, mi6 should be == 0\");\n    }\n\n\n}\n</code></pre>"},{"location":"uebungen/#ubung-13-collections-wiederholung","title":"\u00dcbung 13 (Collections Wiederholung)","text":"\u00dcbung 13 (Collections Wiederholung) <ul> <li> <p>Gegeben sind folgende Klassen:</p> Klassen f\u00fcr Uebung13 Uebung13.javaUebung13Test.javaCircle.java <pre><code>package uebungen.uebung13;\n\nimport java.util.*;\n\npublic class Uebung13\n{\n    static Random r =  new Random();\n\n    public static Circle createCircle(int bound)\n    {\n        int randNr = r.nextInt(bound);\n        if(randNr &lt; 2)\n        {\n            return new Circle();\n        }\n        else\n        {\n            return new Circle(randNr);\n        }\n    }\n\n    public static List&lt;Circle&gt; setUpCircleList(int listLength, int bound)\n    {\n        List&lt;Circle&gt; list = new ArrayList&lt;Circle&gt;();\n        for(int i = 0; i &lt; listLength; i++)\n        {\n            list.add(createCircle(bound));\n        }\n        return list;\n    }\n\n    /*\n     *   gibt eine Liste mit allen Elementen aus c1 UND c2 zurueck\n     *   in der Liste darf jedoch kein Element doppelt vorkommen, d.h.\n     *   wenn e1 in Liste und e2 in Liste, dann gilt !e1.equals(e2)\n     */\n    public static List&lt;Circle&gt; union(List&lt;Circle&gt; c1, List&lt;Circle&gt; c2)\n    {\n        return null;    //TODO\n    }\n\n\n    /*\n     *   gibt eine Map zurueck\n     *   Schluessel sind die Flaecheninhalte (area) der Circles\n     *   Werte sind eine Liste aller Circle-Objekte mit diesem Flaecheninhalt\n     */\n    public static Map&lt;Double, List&lt;Circle&gt;&gt; createMap(List&lt;Circle&gt; circles)\n    {\n        return null; //TODO\n    }\n\n\n    /*\n     *   fuegt der map alle circles passend hinzu\n     */\n    public static void addListToMap(Map&lt;Double, List&lt;Circle&gt;&gt; map, List&lt;Circle&gt; circles)\n    {\n        //TODO\n    }\n\n    /*\n     *   - uebergeben wird eine map, deren keys vom Typ Double sind\n     *   - der Schluessel key ist vom Typ int\n     *   - in der map wird nach einem Schluessel gesucht, dessen ganzzahliger \n     *      Wert dem int key entspricht, d.h. \n     *          78,654... passt zu 78\n     *          79,012... passt nicht zu 78\n     *   - falls ein solcher Schluessel nicht in der map existiert, wird eine\n     *      IllegalArgumentException geworfen. Die Nachricht enthaelt den Wert des \n     *      Schlussels, nach dem gesucht wurde, z.B. 'key 79 not found' \n     *   - falls ein solcher Schluessel existiert, wird der erste Circle aus der \n     *      Liste zu dem Schluessel zurueckgegeben\n     */\n    public static Circle getFirstCircleOfKey(Map&lt;Double, List&lt;Circle&gt;&gt; map, int key)\n    {\n        //TODO\n        return null;\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n ---------------------- list1 und list2 ----------------------%n%n\");\n        List&lt;Circle&gt; list1 = setUpCircleList(10, 6);\n        List&lt;Circle&gt; list2 = setUpCircleList(10, 6);\n        System.out.println(\"list1: \");\n        list1.forEach(System.out::println);\n        System.out.println();\n        System.out.println(\"list2: \");\n        list2.forEach(System.out::println);\n\n        System.out.printf(\"%n%n -------------------- union(list1, list2) --------------------%n%n\");\n        /* TODO: print List of union(list1, list2)\n        * z.B.:\n            Circle [radius=1.0] area=  3,14 circumference= 6,28\n            Circle [radius=3.0] area= 28,27 circumference=18,85\n            Circle [radius=4.0] area= 50,27 circumference=25,13\n            Circle [radius=5.0] area= 78,54 circumference=31,42\n        */\n\n        System.out.printf(\"%n%n -------------------- createMap(list1) --------------------%n%n\");\n        /* TODO: print Map of createMap(list1)\n        * z.B.:\n            -- area =  28,27 --\n            Circle [radius=3.0]\n            Circle [radius=3.0]\n\n            -- area =  78,54 --\n            Circle [radius=5.0]\n\n            -- area =   3,14 --\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n\n            -- area =  50,27 --\n            Circle [radius=4.0]\n\n            -- area =  12,57 --\n            Circle [radius=2.0]\n        */\n\n        System.out.printf(\"%n%n -------------------- addListToMap(map,list2) --------------------%n%n\");\n        /* TODO: print Map of addListToMap(map,list2)\n        * z.B.:\n            -- area =  28,27 --\n            Circle [radius=3.0]\n            Circle [radius=3.0]\n\n            -- area =  78,54 --\n            Circle [radius=5.0]\n\n            -- area =   3,14 --\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n\n            -- area =  50,27 --\n            Circle [radius=4.0]\n\n            -- area =  12,57 --\n            Circle [radius=2.0]\n        */\n\n        System.out.printf(\"%n%n -------------------- getFirstCircleOfKey(map,int) --------------------%n%n\");\n        /* TODO: search in map for key=78 and print Circle\n        /* TODO: search in map for key=79 and print Exception-Message\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung13;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Uebung13Test\n{\n    static Circle c0, c1, c2, c3, c4, c5, c6;\n    @BeforeAll\n    public static void setup()\n    {\n        c0 = new Circle();\n        c1 = new Circle(1);     // c0.equals(c1) == true\n        c2 = new Circle(2);\n        c3 = new Circle(3);\n        c4 = new Circle(4);\n        c5 = new Circle(5);\n\n    }\n\n    @Test\n    @DisplayName(\"test union(list1, list2)\")\n    public void testUnion()\n    {\n        System.out.printf(\"%n%n--------------- tests union(list1, list2) ------------------%n%n\");\n        // given\n        List&lt;Circle&gt; l1 = List.of(c0, c1, c2);\n        List&lt;Circle&gt; l2 = List.of(c3, c4, c5);\n        List&lt;Circle&gt; l3 = List.of(c0, c1, c2);\n        List&lt;Circle&gt; l4 = List.of(c0, c1, c3);\n        List&lt;Circle&gt; l5 = List.of();\n\n        // when\n        List&lt;Circle&gt; list1 = Uebung13.union(l1, l2); list1.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list2 = Uebung13.union(l3, l4); list2.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list3 = Uebung13.union(l1, l3); list3.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list4 = Uebung13.union(l2, l4); list4.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list5 = Uebung13.union(l4, l5); list5.sort(Comparator.comparing(Circle::getRadius));\n\n        // then\n        List&lt;Circle&gt; expected1 = List.of(c0, c2, c3,  c4, c5);\n        List&lt;Circle&gt; expected2 = List.of(c0, c2, c3);\n        List&lt;Circle&gt; expected3 = List.of(c0, c2);\n        List&lt;Circle&gt; expected4 = List.of(c0, c3,  c4, c5);\n        List&lt;Circle&gt; expected5 = List.of(c0, c3);\n        assertEquals(expected1, list1, \"list should contain circles with radius 1.0, 2.0, 3.0, 4.0 and 5.0, only\");\n        assertEquals(expected2, list2, \"list should contain circles with radius 1.0, 2.0 and 3.0, only\");\n        assertEquals(expected3, list3, \"list should contain circles with radius 1.0 and 2.0, only\");\n        assertEquals(expected4, list4, \"list should contain circles with radius 1.0, 3.0, 4.0 and 5.0, only\");\n        assertEquals(expected5, list5, \"list should contain circles with radius 1.0 and 3.0, only\");\n    }\n\n    @Test\n    @DisplayName(\"test createMap(list)\")\n    public void testCreateMap()\n    {\n        System.out.printf(\"%n%n------------------ tests createMap(list) ---------------------%n%n\");\n        // given\n        List&lt;Circle&gt; l1 = List.of(c0, c1, c2, c3, c4, c5, c0, c1, c2, c3, c4, c5, c4, c5, c0);\n        List&lt;Circle&gt; l2 = List.of(c0, c1);\n\n        // when\n        Map&lt;Double, List&lt;Circle&gt;&gt; map1 = Uebung13.createMap(l1);\n        Map&lt;Double, List&lt;Circle&gt;&gt; map2 = Uebung13.createMap(l2);\n\n        // then\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected1 = new HashMap&lt;&gt;();\n        expected1.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1, c0, c1, c0));\n        expected1.put(Math.PI * Math.pow(2.0, 2), List.of(c2, c2));\n        expected1.put(Math.PI * Math.pow(3.0, 2), List.of(c3, c3));\n        expected1.put(Math.PI * Math.pow(4.0, 2), List.of(c4, c4, c4));\n        expected1.put(Math.PI * Math.pow(5.0, 2), List.of(c5, c5, c5));\n        assertEquals(expected1, map1, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected2 = new HashMap&lt;&gt;();\n        expected2.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1));\n        assertEquals(expected2, map2, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n    }\n\n    @Test\n    @DisplayName(\"test addListToMap(list)\")\n    public void testAddListToMap()\n    {\n        System.out.printf(\"%n%n------------------ tests addListToMap(list) ---------------------%n%n\");\n        // given\n        Map&lt;Double, List&lt;Circle&gt;&gt; map1 = new HashMap&lt;&gt;();\n        List&lt;Circle&gt; l1 = new ArrayList&lt;&gt;();\n        l1.add(c0);\n        l1.add(c1);\n        map1.put(Math.PI * Math.pow(1.0, 2), l1);\n        List&lt;Circle&gt; l2 = new ArrayList&lt;&gt;();\n        l2.add(c2);\n        map1.put(Math.PI * Math.pow(2.0, 2), l2);\n        List&lt;Circle&gt; l3 = new ArrayList&lt;&gt;();\n        l3.add(c3);\n        map1.put(Math.PI * Math.pow(3.0, 2), l3);\n        List&lt;Circle&gt; l4 = new ArrayList&lt;&gt;();\n        l4.add(c4);\n        l4.add(c4);\n        map1.put(Math.PI * Math.pow(4.0, 2), l4);\n        List&lt;Circle&gt; list1 = List.of(c0, c1, c2, c3, c4, c5);\n\n        Map&lt;Double, List&lt;Circle&gt;&gt; map2 = new HashMap&lt;&gt;();\n        List&lt;Circle&gt; l5 = new ArrayList&lt;&gt;();\n        l5.add(c0);\n        l5.add(c1);\n        map2.put(Math.PI * Math.pow(1.0, 2), l5);\n        List&lt;Circle&gt; list2 = List.of(c0, c1, c2);\n\n        // when\n        Uebung13.addListToMap(map1, list1);\n        Uebung13.addListToMap(map2, list2);\n\n        // then\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected1 = new HashMap&lt;&gt;();\n        expected1.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1, c0, c1));\n        expected1.put(Math.PI * Math.pow(2.0, 2), List.of(c2, c2));\n        expected1.put(Math.PI * Math.pow(3.0, 2), List.of(c3, c3));\n        expected1.put(Math.PI * Math.pow(4.0, 2), List.of(c4, c4, c4));\n        expected1.put(Math.PI * Math.pow(5.0, 2), List.of(c5));\n        assertEquals(expected1, map1, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected2 = new HashMap&lt;&gt;();\n        expected2.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1, c0, c1));\n        expected2.put(Math.PI * Math.pow(2.0, 2), List.of(c2));\n        assertEquals(expected2, map2, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n    }\n\n    @Test\n    @DisplayName(\"test getFirstCircleOfKey(map, key)\")\n    public void testGetFirstCircleOfKey()\n    {\n        System.out.printf(\"%n%n------------------ tests getFirstCircleOfKey(map, key) ---------------------%n%n\");\n        // given\n        Map&lt;Double, List&lt;Circle&gt;&gt; map = new HashMap&lt;&gt;();\n        map.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1));\n        map.put(Math.PI * Math.pow(2.0, 2), List.of(c2));\n        map.put(Math.PI * Math.pow(3.0, 2), List.of(c3));\n        map.put(Math.PI * Math.pow(4.0, 2), List.of(c4));\n        map.put(Math.PI * Math.pow(5.0, 2), List.of(c5));\n\n        //when\n        int key1 = 78;\n        int key2 = 79;\n        Circle c = Uebung13.getFirstCircleOfKey(map, key1);\n        Exception e = assertThrows(IllegalArgumentException.class, () -&gt; Uebung13.getFirstCircleOfKey(map, key2));\n\n        // then\n        assertNotNull(c, \"Circle should not be null\");\n        assertEquals(c5, c, \"Circle should have radius=5.0\");\n        assertEquals(\"key 79 not found\", e.getMessage());\n    }\n}\n</code></pre> <pre><code>package uebungen.uebung13;\n\npublic class Circle\n{\n    double radius;\n\n    Circle()\n    {\n        this.radius = 1.0;\n    }\n\n    Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    public double getRadius()\n    {\n        return this.radius;\n    }\n\n    public double area()\n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    public double circumference()\n    {\n        return 2 * Math.PI * this.radius;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"Circle [radius=\" + this.radius + \"]\";\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Circle circle = (Circle) o;\n        return circle.radius == this.radius;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int) this.radius;\n    }\n}\n</code></pre> </li> <li> <p>siehe <code>TODO</code> in <code>Uebung13.java</code></p> </li> <li>am Ende sollten alle Tests bestanden sein</li> </ul> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 13 Uebung13.java <pre><code>package uebungen.uebung13;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Uebung13\n{\n    static Random r =  new Random();\n\n    private static Circle createCircle(int bound)\n    {\n        int randNr = r.nextInt(bound);\n        if(randNr &lt; 2)\n        {\n            return new Circle();\n        }\n        else\n        {\n            return new Circle(randNr);\n        }\n    }\n\n    private static List&lt;Circle&gt; setUpCircleList(int listLength, int bound)\n    {\n        List&lt;Circle&gt; list = new ArrayList&lt;Circle&gt;();\n        for(int i = 0; i &lt; listLength; i++)\n        {\n            list.add(createCircle(bound));\n        }\n        return list;\n    }\n\n    /*\n     *   gibt eine Liste mit allen Elementen aus c1 UND c2 zurueck\n     *   in der Liste darf jedoch kein Element doppelt vorkommen, d.h.\n     *   wenn e1 in Liste und e2 in Liste, dann gilt !e1.equals(e2)\n     */\n    public static List&lt;Circle&gt; union(final List&lt;Circle&gt; c1, final List&lt;Circle&gt; c2)\n    {\n        /*\n        Set&lt;Circle&gt; set1 = new HashSet&lt;&gt;(c1);\n        set1.addAll(c2);\n        List&lt;Circle&gt; unionList = new ArrayList&lt;&gt;(set1);\n         */\n\n        List&lt;Circle&gt; unionList = Stream.concat(c1.stream(), c2.stream())\n                .distinct().collect(Collectors.toList());\n        return unionList;\n    }\n\n\n    /*\n     *   gibt eine Map zurueck\n     *   Schluessel sind die Flaecheninhalte (area) der Circles\n     *   Werte sind eine Liste aller Circle-Objekte mit diesem Flaecheninhalt\n     */\n    public static Map&lt;Double, List&lt;Circle&gt;&gt; createMap(List&lt;Circle&gt; circles)\n    {\n        Map&lt;Double, List&lt;Circle&gt;&gt; map = circles.stream().collect(Collectors.groupingBy(c -&gt; c.area()));\n        return map;\n    }\n\n\n    /*\n     *   fuegt der map alle circles passend hinzu\n     */\n    public static void addListToMap(Map&lt;Double, List&lt;Circle&gt;&gt; map, List&lt;Circle&gt; circles)\n    {\n        for(Circle circle : circles)\n        {\n            double area = circle.area();\n            if(map.containsKey(area)) {\n                List&lt;Circle&gt; list = map.get(area);\n                list.add(circle);\n            } else {\n                List&lt;Circle&gt; list = new ArrayList&lt;&gt;();\n                list.add(circle);\n                map.put(area, list);\n            }\n        }\n    }\n\n    /*\n     *   - uebergeben wird eine map, deren keys vom Typ Double sind\n     *   - der Schluessel key ist vom Typ int\n     *   - in der map wird nach einem Schluessel gesucht, dessen ganzzahliger\n     *      Wert dem int key entspricht, d.h.\n     *          78,654... passt zu 78\n     *          79,012... passt nicht zu 78\n     *   - falls ein solcher Schluessel nicht in der map existiert, wird eine\n     *      IllegalArgumentException geworfen. Die Nachricht enthaelt den Wert des\n     *      Schlussels, nach dem gesucht wurde, z.B. 'key 79 not found'\n     *   - falls ein solcher Schluessel existiert, wird der erste Circle aus der\n     *      Liste zu dem Schluessel zurueckgegeben\n     */\n    public static Circle getFirstCircleOfKey(Map&lt;Double, List&lt;Circle&gt;&gt; map, int key) throws IllegalArgumentException\n    {\n        for(Double originalKey : map.keySet())\n        {\n            //int intKey = (int) originalKey;\n            if(originalKey.intValue() == key)\n            {\n                return map.get(originalKey).getFirst();\n            }\n        }\n        throw new IllegalArgumentException(\"key \" + key + \" not found\");\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n ---------------------- list1 und list2 ----------------------%n%n\");\n        List&lt;Circle&gt; list1 = setUpCircleList(10, 6);\n        List&lt;Circle&gt; list2 = setUpCircleList(10, 6);\n        System.out.println(\"list1: \");\n        list1.forEach(System.out::println);\n        System.out.println();\n        System.out.println(\"list2: \");\n        list2.forEach(System.out::println);\n\n        System.out.printf(\"%n%n -------------------- union(list1, list2) --------------------%n%n\");\n        /* TODO: print List of union(list1, list2)\n        * z.B.:\n            Circle [radius=1.0] area=  3,14 circumference= 6,28\n            Circle [radius=3.0] area= 28,27 circumference=18,85\n            Circle [radius=4.0] area= 50,27 circumference=25,13\n            Circle [radius=5.0] area= 78,54 circumference=31,42\n        */\n        List&lt;Circle&gt; unionList = union(list1, list2);\n        for(Circle circle : unionList)\n        {\n            System.out.printf(\"%s area=%6.2f circumference=%5.2f %n\",\n                    circle.toString(), circle.area(), circle.circumference());\n        }\n\n\n        System.out.printf(\"%n%n -------------------- createMap(list1) --------------------%n%n\");\n        /* TODO: print Map of createMap(list1)\n        * z.B.:\n            -- area =  28,27 --\n            Circle [radius=3.0]\n            Circle [radius=3.0]\n\n            -- area =  78,54 --\n            Circle [radius=5.0]\n\n            -- area =   3,14 --\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n\n            -- area =  50,27 --\n            Circle [radius=4.0]\n\n            -- area =  12,57 --\n            Circle [radius=2.0]\n        */\n        Map&lt;Double, List&lt;Circle&gt;&gt; map1 = createMap(list1);\n        map1.forEach( (k,v) -&gt; {\n            System.out.printf(\"-- area = %.2f %n\", k);\n            v.forEach(c -&gt; System.out.println(c.toString()));\n            System.out.println();\n        });\n\n        System.out.printf(\"%n%n -------------------- addListToMap(map,list2) --------------------%n%n\");\n        /* TODO: print Map of addListToMap(map,list2)\n        * z.B.:\n            -- area =  28,27 --\n            Circle [radius=3.0]\n            Circle [radius=3.0]\n\n            -- area =  78,54 --\n            Circle [radius=5.0]\n\n            -- area =   3,14 --\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n\n            -- area =  50,27 --\n            Circle [radius=4.0]\n\n            -- area =  12,57 --\n            Circle [radius=2.0]\n        */\n        addListToMap(map1, list1);\n        for(Map.Entry&lt;Double, List&lt;Circle&gt;&gt; entry : map1.entrySet())\n        {\n            System.out.printf(\"-- area = %.2f %n\", entry.getKey());\n            for(Circle circle : entry.getValue())\n            {\n                System.out.println(circle.toString());\n            }\n            System.out.println();\n        }\n\n        System.out.printf(\"%n%n -------------------- getFirstCircleOfKey(map,int) --------------------%n%n\");\n        /* TODO: search in map for key=78 and print Circle */\n        /* TODO: search in map for key=79 and print Exception-Message */\n        for(int key = 78; key &lt; 80; key++)\n        {\n            try {\n                Circle circle = getFirstCircleOfKey(map1, key);\n                System.out.println(circle.toString());\n            }\n            catch(IllegalArgumentException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n\n    }\n}\n</code></pre>"},{"location":"uebungen/#probeklausur-1","title":"Probeklausur 1","text":"Probeklausur 1 <p>Vorbereitung</p> Gegeben sind folgende Klassen (auch als download verf\u00fcgbar): Probeklausur1.javaCircle.javaProbeklausur1Test.java <pre><code>package probeklausuren.probeklausur1;\n\nimport java.util.*;\n\npublic class Probeklausur1\n{\n    static Random r =  new Random();\n\n    public static Circle createCircle(int bound)\n    {\n        int randNr = r.nextInt(bound);\n        if(randNr &lt; 2)\n        {\n            return new Circle();\n        }\n        else\n        {\n            return new Circle(randNr);\n        }\n    }\n\n    public static List&lt;Circle&gt; setUpCircleList(int listLength, int bound)\n    {\n        List&lt;Circle&gt; list = new ArrayList&lt;Circle&gt;();\n        for(int i = 0; i &lt; listLength; i++)\n        {\n            list.add(createCircle(bound));\n        }\n        return list;\n    }\n\n    /*\n     *   gibt eine Liste mit allen Elementen aus c1 UND c2 zurueck\n     *   in der Liste darf jedoch kein Element doppelt vorkommen, d.h.\n     *   wenn e1 in Liste und e2 in Liste, dann gilt !e1.equals(e2)\n     */\n    public static List&lt;Circle&gt; union(List&lt;Circle&gt; c1, List&lt;Circle&gt; c2)\n    {\n        return null; //TODO\n    }\n\n\n    /*\n     *   gibt eine Map zurueck\n     *   Schluessel sind die Flaecheninhalte (area) der Circles\n     *   Werte sind eine Liste aller Circle-Objekte mit diesem Flaecheninhalt\n     */\n    public static Map&lt;Double, List&lt;Circle&gt;&gt; createMap(List&lt;Circle&gt; circles)\n    {\n        return null; //TODO\n    }\n\n    /*\n     *   fuegt der map alle circles passend hinzu\n     */\n    public static void addListToMap(Map&lt;Double, List&lt;Circle&gt;&gt; map, List&lt;Circle&gt; circles)\n    {\n        //TODO\n    }\n\n    /*\n     *   - uebergeben wird eine map, deren keys vom Typ Double sind\n     *   - der Schluessel key ist vom Typ int\n     *   - in der map wird nach einem Schluessel gesucht, dessen ganzzahliger\n     *      Wert dem int key entspricht, d.h.\n     *          78,654 passt zu 78\n     *          79,01 passt nicht zu 78\n     *   - falls ein solcher Schluessel nicht in der map existiert, wird eine\n     *      IllegalArgumentException geworfen. Die Nachricht enthaelt den Wert des\n     *      Schlussels, nach dem gesucht wurde, z.B. 'key 79 not found'\n     *   - falls ein solcher Schluessel existiert, wird der erste Circle aus der\n     *      Liste zu dem Schluessel zurueckgegeben\n     */\n    public static Circle getFirstCircleOfKey(Map&lt;Double, List&lt;Circle&gt;&gt; map, int key)\n    {\n        return null; //TODO\n    }\n\n    /*\n     *   - uebergeben wird eine map, deren keys vom Typ Double sind (area())\n     *   - die Werte sind vom Typ List&lt;Circle&gt;\n     *   - in der map (in den values) wird nach einem Circle gesucht, dessen\n     *     Radius dem Parameterwert von double radius entspricht\n     *   - falls ein solcher Circle existiert, wird er dem Optional hinzugefuegt\n     *     und zur\u00fcckgegeben\n     *   - falls ein solcher Circle nicht existiert, wird ein leeres Optional\n     *     zurueckgegeben\n     */\n    public static Optional&lt;Circle&gt; getFirstCircleOfRadius(Map&lt;Double, List&lt;Circle&gt;&gt; map, double radius)\n    {\n        return null; //TODO\n    }\n\n    /*\n     * uebergeben wird eine unsortierte Liste von Circle-Objekten\n     * zurueckgegeben wird eine sortierte Liste von Circle-Objekte\n     * sortiert nach \"natural order\" (compareTo)\n     */\n    public static List&lt;Circle&gt; createSortedListOfCircles(List&lt;Circle&gt; circles)\n    {\n        return null; //TODO\n    }\n\n    /*\n     * uebergeben wird eine unsortierte Liste von Circle-Objekten\n     * zurueckgegeben wird eine sortierte Liste von Circle-Objekte\n     * - sortiert nach \"natural order\" (compareTo)\n     * - gerade Radien zuerst!!!\n     */\n    public static List&lt;Circle&gt; createSortedListOfCirclesEvenRadiiFirst(List&lt;Circle&gt; circles)\n    {\n        return null; //TODO\n    }\n\n    /*\n     * Hilfsmethode zur Ausgabe einer Map&lt;Double, List&lt;Circle&gt;&gt;\n     */\n    private static void printMapOfCircles(Map&lt;Double, List&lt;Circle&gt;&gt; map)\n    {\n        // MUSS NICHT, KANN DIREKT IN MAIN, HILFT ABER\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n ---------------------- list1 und list2 ----------------------%n%n\");\n        List&lt;Circle&gt; list1 = setUpCircleList(10, 6);\n        List&lt;Circle&gt; list2 = setUpCircleList(10, 6);\n        System.out.println(\"list1: \");\n        list1.forEach(System.out::println);\n        System.out.println();\n        System.out.println(\"list2: \");\n        list2.forEach(System.out::println);\n\n        System.out.printf(\"%n%n -------------------- union(list1, list2) --------------------%n%n\");\n        /* print List of union(list1, list2)\n        * z.B.:\n            Circle [radius=1.0] area=  3,14 circumference= 6,28\n            Circle [radius=3.0] area= 28,27 circumference=18,85\n            Circle [radius=4.0] area= 50,27 circumference=25,13\n            Circle [radius=5.0] area= 78,54 circumference=31,42\n        */\n        //TODO\n\n        System.out.printf(\"%n%n -------------------- createMap(list1) --------------------%n%n\");\n        /* print Map of createMap(list1)\n        * z.B.:\n            -- area =  28,27 --\n            Circle [radius=3.0]\n            Circle [radius=3.0]\n\n            -- area =  78,54 --\n            Circle [radius=5.0]\n\n            -- area =   3,14 --\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n\n            -- area =  50,27 --\n            Circle [radius=4.0]\n\n            -- area =  12,57 --\n            Circle [radius=2.0]\n        */\n        //TODO\n\n        System.out.printf(\"%n%n -------------------- addListToMap(map,list2) --------------------%n%n\");\n        /* print Map of addListToMap(map,list2)\n        * z.B.:\n            -- area =  28,27 --\n            Circle [radius=3.0]\n            Circle [radius=3.0]\n\n            -- area =  78,54 --\n            Circle [radius=5.0]\n\n            -- area =   3,14 --\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n            Circle [radius=1.0]\n\n            -- area =  50,27 --\n            Circle [radius=4.0]\n\n            -- area =  12,57 --\n            Circle [radius=2.0]\n        */\n       //TODO\n\n        System.out.printf(\"%n%n -------------------- getFirstCircleOfKey(map,int) --------------------%n%n\");\n        for(int key = 78; key &lt; 80; key++) {\n\n            //TODO\n\n        }\n\n        System.out.printf(\"%n%n -------------------- getFirstCircleOfRadius(map,double) --------------------%n%n\");\n        for(double radius = 5.0; radius &lt; 7.0; radius++) {\n\n            //TODO\n\n        }\n\n        System.out.printf(\"%n%n -------------------- Circle is Comparable  --------------------%n%n\");\n        Circle c1 = createCircle(3);\n        Circle c2 = createCircle(3);\n        System.out.println(\"c1: \" + c1);\n        System.out.println(\"c2: \" + c2);\n\n        //TODO\n\n        System.out.printf(\"%n%n -------------------- createSortedListOfCircles(list) --------------------%n%n\");\n\n        //TODO\n\n\n        System.out.printf(\"%n%n -------------------- createSortedListOfCirclesEvenRadiiFirst(list) --------------------%n%n\");\n\n        //TODO\n    }\n}\n</code></pre> <pre><code>package probeklausuren.probeklausur1;\n\npublic class Circle\n{\n    double radius;\n\n    Circle()\n    {\n        this.radius = 1.0;\n    }\n\n    Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    public double getRadius()\n    {\n        return this.radius;\n    }\n\n    public double area()\n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    public double circumference()\n    {\n        return 2 * Math.PI * this.radius;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"Circle [radius=\" + this.radius + \"]\";\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Circle circle = (Circle) o;\n        return circle.radius == this.radius;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int) this.radius;\n    }\n}\n</code></pre> <pre><code>package probeklausuren.probeklausur1;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Probeklausur1Test\n{\n    static Circle c0, c1, c2, c3, c4, c5, c6;\n    @BeforeAll\n    public static void setup()\n    {\n        c0 = new Circle();\n        c1 = new Circle(1);     // c0.equals(c1) == true\n        c2 = new Circle(2);\n        c3 = new Circle(3);\n        c4 = new Circle(4);\n        c5 = new Circle(5);\n\n    }\n\n    @Test\n    @DisplayName(\"test union(list1, list2)\")\n    public void testUnion()\n    {\n        System.out.printf(\"%n------------------ tests union(list1, list2) ------------------%n\");\n        // given\n        List&lt;Circle&gt; l1 = List.of(c0, c1, c2);\n        List&lt;Circle&gt; l2 = List.of(c3, c4, c5);\n        List&lt;Circle&gt; l3 = List.of(c0, c1, c2);\n        List&lt;Circle&gt; l4 = List.of(c0, c1, c3);\n        List&lt;Circle&gt; l5 = List.of();\n\n        // when\n        List&lt;Circle&gt; list1 = Probeklausur1.union(l1, l2); list1.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list2 = Probeklausur1.union(l3, l4); list2.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list3 = Probeklausur1.union(l1, l3); list3.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list4 = Probeklausur1.union(l2, l4); list4.sort(Comparator.comparing(Circle::getRadius));\n        List&lt;Circle&gt; list5 = Probeklausur1.union(l4, l5); list5.sort(Comparator.comparing(Circle::getRadius));\n\n        // then\n        List&lt;Circle&gt; expected1 = List.of(c0, c2, c3,  c4, c5);\n        List&lt;Circle&gt; expected2 = List.of(c0, c2, c3);\n        List&lt;Circle&gt; expected3 = List.of(c0, c2);\n        List&lt;Circle&gt; expected4 = List.of(c0, c3,  c4, c5);\n        List&lt;Circle&gt; expected5 = List.of(c0, c3);\n        assertEquals(expected1, list1, \"list should contain circles with radius 1.0, 2.0, 3.0, 4.0 and 5.0, only\");\n        assertEquals(expected2, list2, \"list should contain circles with radius 1.0, 2.0 and 3.0, only\");\n        assertEquals(expected3, list3, \"list should contain circles with radius 1.0 and 2.0, only\");\n        assertEquals(expected4, list4, \"list should contain circles with radius 1.0, 3.0, 4.0 and 5.0, only\");\n        assertEquals(expected5, list5, \"list should contain circles with radius 1.0 and 3.0, only\");\n    }\n\n    @Test\n    @DisplayName(\"test createMap(list)\")\n    public void testCreateMap()\n    {\n        System.out.printf(\"%n------------------ tests createMap(list) ---------------------%n\");\n        // given\n        List&lt;Circle&gt; l1 = List.of(c0, c1, c2, c3, c4, c5, c0, c1, c2, c3, c4, c5, c4, c5, c0);\n        List&lt;Circle&gt; l2 = List.of(c0, c1);\n\n        // when\n        Map&lt;Double, List&lt;Circle&gt;&gt; map1 = Probeklausur1.createMap(l1);\n        Map&lt;Double, List&lt;Circle&gt;&gt; map2 = Probeklausur1.createMap(l2);\n\n        // then\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected1 = new HashMap&lt;&gt;();\n        expected1.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1, c0, c1, c0));\n        expected1.put(Math.PI * Math.pow(2.0, 2), List.of(c2, c2));\n        expected1.put(Math.PI * Math.pow(3.0, 2), List.of(c3, c3));\n        expected1.put(Math.PI * Math.pow(4.0, 2), List.of(c4, c4, c4));\n        expected1.put(Math.PI * Math.pow(5.0, 2), List.of(c5, c5, c5));\n        assertEquals(expected1, map1, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected2 = new HashMap&lt;&gt;();\n        expected2.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1));\n        assertEquals(expected2, map2, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n    }\n\n    @Test\n    @DisplayName(\"test addListToMap(list)\")\n    public void testAddListToMap()\n    {\n        System.out.printf(\"%n------------------ tests addListToMap(list) ---------------------%n\");\n        // given\n        Map&lt;Double, List&lt;Circle&gt;&gt; map1 = new HashMap&lt;&gt;();\n        List&lt;Circle&gt; l1 = new ArrayList&lt;&gt;();\n        l1.add(c0);\n        l1.add(c1);\n        map1.put(Math.PI * Math.pow(1.0, 2), l1);\n        List&lt;Circle&gt; l2 = new ArrayList&lt;&gt;();\n        l2.add(c2);\n        map1.put(Math.PI * Math.pow(2.0, 2), l2);\n        List&lt;Circle&gt; l3 = new ArrayList&lt;&gt;();\n        l3.add(c3);\n        map1.put(Math.PI * Math.pow(3.0, 2), l3);\n        List&lt;Circle&gt; l4 = new ArrayList&lt;&gt;();\n        l4.add(c4);\n        l4.add(c4);\n        map1.put(Math.PI * Math.pow(4.0, 2), l4);\n        List&lt;Circle&gt; list1 = List.of(c0, c1, c2, c3, c4, c5);\n\n        Map&lt;Double, List&lt;Circle&gt;&gt; map2 = new HashMap&lt;&gt;();\n        List&lt;Circle&gt; l5 = new ArrayList&lt;&gt;();\n        l5.add(c0);\n        l5.add(c1);\n        map2.put(Math.PI * Math.pow(1.0, 2), l5);\n        List&lt;Circle&gt; list2 = List.of(c0, c1, c2);\n\n        // when\n        Probeklausur1.addListToMap(map1, list1);\n        Probeklausur1.addListToMap(map2, list2);\n\n        // then\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected1 = new HashMap&lt;&gt;();\n        expected1.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1, c0, c1));\n        expected1.put(Math.PI * Math.pow(2.0, 2), List.of(c2, c2));\n        expected1.put(Math.PI * Math.pow(3.0, 2), List.of(c3, c3));\n        expected1.put(Math.PI * Math.pow(4.0, 2), List.of(c4, c4, c4));\n        expected1.put(Math.PI * Math.pow(5.0, 2), List.of(c5));\n        assertEquals(expected1, map1, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n\n        Map&lt;Double, List&lt;Circle&gt;&gt; expected2 = new HashMap&lt;&gt;();\n        expected2.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1, c0, c1));\n        expected2.put(Math.PI * Math.pow(2.0, 2), List.of(c2));\n        assertEquals(expected2, map2, \"click on \\\"Click to see difference\\\" in IntelliJ\");\n    }\n\n    @Test\n    @DisplayName(\"test getFirstCircleOfKey(map, key)\")\n    public void testGetFirstCircleOfKey()\n    {\n        System.out.printf(\"%n------------------ tests getFirstCircleOfKey(map, key) ---------------------%n\");\n        // given\n        Map&lt;Double, List&lt;Circle&gt;&gt; map = new HashMap&lt;&gt;();\n        map.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1));\n        map.put(Math.PI * Math.pow(2.0, 2), List.of(c2));\n        map.put(Math.PI * Math.pow(3.0, 2), List.of(c3));\n        map.put(Math.PI * Math.pow(4.0, 2), List.of(c4));\n        map.put(Math.PI * Math.pow(5.0, 2), List.of(c5));\n\n        //when\n        int key1 = 78;\n        int key2 = 79;\n        Circle c = Probeklausur1.getFirstCircleOfKey(map, key1);\n        Exception e = assertThrows(IllegalArgumentException.class, () -&gt; Probeklausur1.getFirstCircleOfKey(map, key2));\n\n        // then\n        assertNotNull(c, \"Circle should not be null\");\n        assertEquals(c5, c, \"Circle should have radius=5.0\");\n        assertEquals(\"key 79 not found\", e.getMessage());\n    }\n\n    @Test\n    @DisplayName(\"test getFirstCircleOfRadius(map, radius)\")\n    public void testGetFirstCircleOfRadius()\n    {\n        System.out.printf(\"%n------------------ tests getFirstCircleOfRadius(map, radius) ---------------------%n\");\n        // given\n        Map&lt;Double, List&lt;Circle&gt;&gt; map = new HashMap&lt;&gt;();\n        map.put(Math.PI * Math.pow(1.0, 2), List.of(c0, c1));\n        map.put(Math.PI * Math.pow(2.0, 2), List.of(c2));\n        map.put(Math.PI * Math.pow(3.0, 2), List.of(c3));\n        map.put(Math.PI * Math.pow(4.0, 2), List.of(c4));\n        map.put(Math.PI * Math.pow(5.0, 2), List.of(c5));\n\n        //when\n        double radius1 = 5.0;\n        double radius2 = 6.0;\n        Optional&lt;Circle&gt; o1 = Probeklausur1.getFirstCircleOfRadius(map, radius1);\n        Optional&lt;Circle&gt; o2 = Probeklausur1.getFirstCircleOfRadius(map, radius2);\n\n        // then\n        assertTrue(o1.isPresent(), \"Optional should not be empty\");\n        assertTrue(o2.isEmpty(), \"Optional should be empty\");\n        assertEquals(c5, o1.get(), \"Circle should have radius=5.0\");\n    }\n\n    @Test\n    @DisplayName(\"test Circle is Comparable\")\n    public void testCircleIsComparable()\n    {\n        System.out.printf(\"%n------------------ test Circle is Comparable ---------------------%n\");\n        // given\n        Circle c1 = new Circle(1.0);\n        Circle c2 = new Circle(2.0);\n        Circle c3 = new Circle(1.0);\n\n        if(c1 instanceof Comparable co1 &amp;&amp; c2 instanceof Comparable co2 &amp;&amp; c3 instanceof Comparable co3) {\n            //when\n            int result1 = co1.compareTo(co2);\n            int result2 = co2.compareTo(co1);\n            int result3 = co3.compareTo(co1);\n\n            // then\n            assertTrue(c1 instanceof Comparable, \"Circle should be Comparable\");\n            assertTrue(result1 &lt; 0, \"if smaller then compareTo &lt; 0\");\n            assertTrue(result2 &gt; 0, \"if bigger then compareTo &gt; 0\");\n            assertTrue(result3 == 0, \"if equals then compareTo == 0\");\n        } else {\n            fail(\"Circle is not comparable\");\n        }\n    }\n\n    @Test\n    @DisplayName(\"test createSortedListOfCircles(list)\")\n    public void testCreateSortedListOfCircles()\n    {\n        System.out.printf(\"%n------------------ tests createSortedListOfCircles(list) ---------------------%n\");\n        // given\n        List&lt;Circle&gt; l1 = List.of(c0, c1, c2, c3, c4, c5, c0, c1, c2, c3, c4, c5, c4, c5, c0);\n\n        // when\n        List&lt;Circle&gt; sorted1 = Probeklausur1.createSortedListOfCircles(l1);\n\n        // then\n        for(int i = 0; i &lt; sorted1.size() -1; i++) {\n            if(sorted1.get(i) instanceof Comparable co1 &amp;&amp; sorted1.get(i+1) instanceof Comparable co2) {\n                assertTrue(co1.compareTo(co2) &lt;= 0, \"list should be sorted\");\n            } else {\n                fail(\"Circle is not comparable\");\n            }\n        }\n    }\n\n    @Test\n    @DisplayName(\"test createSortedListOfCirclesEvenRadiiFirst(list)\")\n    public void testCreateSortedListOfCirclesEvenRadiiFirst()\n    {\n        System.out.printf(\"%n------------------ tests createSortedListOfCirclesEvenRadiiFirst(list) ---------------------%n\");\n        // given\n        List&lt;Circle&gt; l1 = List.of(c0, c1, c2, c3, c4, c5, c0, c1, c2, c3, c4, c5, c4, c5, c0);\n        List&lt;Circle&gt; sorted = List.of(c2, c2, c4, c4, c4, c0, c1, c0, c1, c0, c3, c3, c5, c5, c5);\n        // when\n        List&lt;Circle&gt; sorted1 = Probeklausur1.createSortedListOfCirclesEvenRadiiFirst(l1);\n\n        // then\n        for(int i = 0; i &lt; sorted1.size(); i++) {\n            assertTrue(sorted1.get(i).equals(sorted.get(i)), \"list should be sorted, even radii first\");\n        }\n    }\n}\n</code></pre> <p>Aufgabe</p> <ol> <li> <p>Implementieren Sie in der Klasse <code>Probeklausur1.java</code> die Methode <code>union(List&lt;Circle&gt; li1, List&lt;Circle&gt; li2)</code>. Diese Methode gibt eine <code>List&lt;Circle&gt;</code> zur\u00fcck. Die zur\u00fcckgegebene Liste enth\u00e4lt alle Circle-Objekte aus der als Parameter \u00fcbergebenen Listen <code>li1</code> und <code>li2</code>. Aber Achtung!: es soll kein Circle doppelt vorkommen, d.h. f\u00fcr alle <code>c1</code> und <code>c2</code>, die in der zur\u00fcckgegebenen Liste vorkommen, gilt <code>!c1.equals(c2)</code>.  \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testUnion()</code>.</p> </li> <li> <p>Rufen Sie die <code>union()</code>-Methode in der <code>main</code>-Methode auf. \u00dcbergeben Sie die Listen <code>list1</code> und <code>list2</code>. Geben Sie die zur\u00fcckgegebene Liste in der folgenden Form auf der Konsole aus:</p> <pre><code>Circle [radius=1.0] area=  3,14 circumference= 6,28 \nCircle [radius=2.0] area= 12,57 circumference=12,57 \nCircle [radius=3.0] area= 28,27 circumference=18,85 \nCircle [radius=4.0] area= 50,27 circumference=25,13 \nCircle [radius=5.0] area= 78,54 circumference=31,42 \n</code></pre> </li> <li> <p>Implementieren Sie in der Klasse <code>Probeklausur1.java</code> die Methode <code>createMap(List&lt;Circle&gt; circles)</code>. Diese Methode gibt eine <code>Map&lt;Double, List&lt;Circle&gt;&gt;</code> zur\u00fcck. Die Schl\u00fcssel in der <code>Map</code> sind die Fl\u00e4cheninhalte (<code>area</code>) der Circles aus der Liste <code>circles</code>. Die Werte in der <code>Map</code> sind jeweils eine Liste aller Circle-Objekte aus der Liste <code>circles</code> mit diesem Fl\u00e4cheninhalt.  \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testCreateMap()</code>.</p> </li> <li> <p>Rufen Sie die <code>createMap()</code>-Methode in der <code>main</code>-Methode auf. \u00dcbergeben Sie die Liste <code>list1</code>. Geben Sie die zur\u00fcckgegebene Map in der folgenden Form auf der Konsole aus (Reihenfolge egal und Zusatzwerte):</p> <pre><code>-- area =  78,54 --\nCircle [radius=5.0]\nCircle [radius=5.0]\n\n-- area =  28,27 --\nCircle [radius=3.0]\nCircle [radius=3.0]\n\n-- area =  50,27 --\nCircle [radius=4.0]\nCircle [radius=4.0]\nCircle [radius=4.0]\n\n-- area =  12,57 --\nCircle [radius=2.0]\nCircle [radius=2.0]\n\n-- area =   3,14 --\nCircle [radius=1.0]\n</code></pre> </li> <li> <p>Implementieren Sie in der Klasse <code>Probeklausur1.java</code> die Methode <code>addListToMap(Map&lt;Double, List&lt;Circle&gt;&gt; map, List&lt;Circle&gt; circles)</code>. Diese Methode f\u00fcgt der <code>Map&lt;Double, List&lt;Circle&gt;&gt;</code> alle Circle-Objekte aus der Liste <code>circles</code> hinzu. Die Schl\u00fcssel in der <code>Map</code> sind die Fl\u00e4cheninhalte (<code>area</code>) der Circles. Die entsprechenden Werte in <code>map</code> sind jeweils eine Liste von Circle-Objekten mit diesem Fl\u00e4cheninhalt. Diesen Listen m\u00fcssen passend die Circle-Objekte aus <code>circles</code> hinzugef\u00fcgt werden.  \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testAddListToMap()</code>.</p> </li> <li> <p>Rufen Sie die <code>addListToMap()</code>-Methode in der <code>main</code>-Methode auf. \u00dcbergeben Sie die Liste <code>list2</code>. Geben Sie die zur\u00fcckgegebene Map in der folgenden Form auf der Konsole aus (Reihenfolge egal und Zusatzwerte):</p> <pre><code>-- area =  78,54 --\nCircle [radius=5.0]\nCircle [radius=5.0]\nCircle [radius=5.0]\n\n-- area =  28,27 --\nCircle [radius=3.0]\nCircle [radius=3.0]\nCircle [radius=3.0]\n\n-- area =  50,27 --\nCircle [radius=4.0]\nCircle [radius=4.0]\nCircle [radius=4.0]\nCircle [radius=4.0]\nCircle [radius=4.0]\n\n-- area =  12,57 --\nCircle [radius=2.0]\nCircle [radius=2.0]\nCircle [radius=2.0]\nCircle [radius=2.0]\nCircle [radius=2.0]\nCircle [radius=2.0]\n\n-- area =   3,14 --\nCircle [radius=1.0]\nCircle [radius=1.0]\nCircle [radius=1.0]\n</code></pre> </li> <li> <p>Implementieren Sie in der Klasse <code>Probeklausur1.java</code> die Methode <code>getFirstCircleOfKey(Map&lt;Double, List&lt;Circle&gt;&gt; map, int key)</code>. Diese Methode gibt ein <code>Circle</code>-Objekt zur\u00fcck oder wirft eine <code>IllegalArgumentException</code>. In der <code>map</code> wird nach einem Schl\u00fcssel gesucht, dessen ganzzahliger Wert dem <code>int key</code> entspricht, d.h.</p> <ul> <li>der Schl\u00fcssel <code>78,654...</code> in der <code>map</code> passt zu <code>key=78</code></li> <li>der Schl\u00fcssel <code>79,01...</code> in der <code>map</code> passt nicht zu 78</li> </ul> <p>Falls ein solcher Schl\u00fcssel nicht in der <code>map</code> existiert, wird eine <code>IllegalArgumentException</code> geworfen. Die Nachricht enth\u00e4lt den Wert des Schl\u00fcssels, nach dem gesucht wurde, z.B. 'key 79 not found'.  Falls ein solcher Schl\u00fcssel existiert, wird der erste <code>Circle</code> aus der <code>value</code>-Liste des Schl\u00fcssels zur\u00fcckgegeben  \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testGetFirstCircleOfKey()</code>.</p> </li> <li> <p>Rufen Sie die <code>getFirstCircleOfKey()</code>-Methode in der <code>main</code>-Methode innerhalb der <code>for(int key = 78; key &lt; 80; key++) {}</code> auf und verwenden Sie den <code>key</code>. \u00dcbergeben Sie die aktuelle <code>map</code>. Wird ein <code>Circle</code> zur\u00fcckgegeben, geben Sie ihn auf der Konsole aus. Wird eine <code>IllegalArgumentException</code> geworfen, geben Sie die Exception-Message aus:</p> <pre><code>found : Circle [radius=5.0]\nkey 79 not found\n</code></pre> </li> <li> <p>Implementieren Sie in der Klasse <code>Probeklausur1.java</code> die Methode <code>getFirstCircleOfRadius(Map&lt;Double, List&lt;Circle&gt;&gt; map, double radius)</code>. Diese Methode gibt ein <code>Optional&lt;Circle&gt;</code>-Objekt zur\u00fcck. In der <code>map</code> wird in den <code>value</code>-Listen nach einem <code>Circle</code> mit dem Radius <code>radius</code> gesucht. Falls ein solcher <code>Circle</code> nicht in der <code>map</code> existiert, wird ein leeres <code>Optional</code> zur\u00fcckgegeben. Falls ein solcher <code>Circle</code> existiert, wird er als Wert des <code>Optional</code>-Objektes zur\u00fcckgegeben.  \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testGetFirstCircleOfRadius()</code>.</p> </li> <li> <p>Rufen Sie die <code>getFirstCircleOfRadius()</code>-Methode in der <code>main</code>-Methode innerhalb der <code>for(double radius = 5.0; radius &lt; 7.0; radius++) {}</code> auf und verwenden Sie den <code>radius</code>. \u00dcbergeben Sie die aktuelle <code>map</code>. Enth\u00e4lt das zur\u00fcckgegebene <code>Optional</code>-Objekt ein <code>Circle</code>-Objekt, geben Sie es auf der Konsole aus. Wird ein leeres <code>Optional</code> zur\u00fcckgegeben, geben Sie <code>no circle with radius=7.0 found</code> (Wert von <code>radius</code> einsetzen) aus:</p> <pre><code>found for radius=5.0 : Circle [radius=5.0]\nno circle with radius=6.0 found\n</code></pre> </li> <li> <p>Implementieren Sie in der Klasse <code>Circle.java</code> das Interface Comparable, so dass ein <code>Circle</code> gr\u00f6\u00dfer ist als ein anderer, wenn sein <code>radius</code> gr\u00f6\u00dfer ist. \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testCircleIsComparable()</code>.</p> </li> <li> <p>Rufen Sie in der <code>main</code>-Methode unterhalb von </p> <pre><code>Circle c1 = createCircle(3);\nCircle c2 = createCircle(3);\nSystem.out.println(\"c1: \" + c1);\nSystem.out.println(\"c2: \" + c2);\n</code></pre> <p>die <code>compareTo()</code>-Methode auf und erzeugen Sie je nach Resultat eine der drei Ausgaben:</p> <pre><code>c1 is equal to c2\nc1 is less than c2\nc1 is greater than c2\n</code></pre> </li> <li> <p>Implementieren Sie in der Klasse <code>Probeklausur1.java</code> die Methode <code>createSortedListOfCircles(List&lt;Circle&gt; circles)</code>. Diese Methode gibt eine <code>List&lt;Circle&gt;</code> zur\u00fcck. Die \u00fcbergebene Liste ist unsortiert. In der zur\u00fcckgegebenen Liste sollen die <code>Circle</code>-Objekte unter Verwendung der natural order (<code>compareTo()</code>) aufsteigend sortiert sein (kleinster zuerst)  \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testCreateSortedListOfCircles()</code>.</p> </li> <li> <p>Rufen Sie die <code>createSortedListOfCircles()</code>-Methode in der <code>main</code>-Methode auf und verwenden Sie <code>list1</code> als Parameter. Geben Sie <code>list1</code> in der folgenden Form aus (die Radien der <code>Circle</code>-Objekte aus <code>list1</code> - Zufallswerte):</p> <pre><code>[ 3,0 3,0 1,0 5,0 1,0 1,0 1,0 1,0 1,0 5,0 ]\n</code></pre> <p>Geben Sie durch <code>createSortedListOfCircles()</code> erzeugte Liste ebenso aus:</p> <pre><code>[ 1,0 1,0 1,0 1,0 1,0 1,0 3,0 3,0 5,0 5,0 ]\n</code></pre> </li> <li> <p>Implementieren Sie in der Klasse <code>Probeklausur1.java</code> die Methode <code>createSortedListOfCirclesEvenRadiiFirst(List&lt;Circle&gt; circles)</code>. Diese Methode gibt eine <code>List&lt;Circle&gt;</code> zur\u00fcck. Die \u00fcbergebene Liste ist unsortiert. In der zur\u00fcckgegebenen Liste sollen die <code>Circle</code>-Objekte unter Verwendung der natural order (<code>compareTo()</code>) aufsteigend sortiert sein (kleinster zuerst). Aber Achtung!. es sollen zuerst die <code>Circle</code>-Objekte mit geraden Radien und dann die <code>Circle</code>-Objekte mit ungeraden Radien kommen  \u2192 In <code>Probeklausur1Test</code> siehe Testmethode <code>testCreateSortedListOfCirclesEvenRadiiFirst()</code>.</p> </li> <li> <p>Rufen Sie die <code>createSortedListOfCirclesEvenRadiiFirst()</code>-Methode in der <code>main</code>-Methode auf und verwenden Sie <code>list1</code> als Parameter. Erzeugen Sie folgende Ausgaben (Zufallswerte):</p> <pre><code>[ 3,0 2,0 5,0 2,0 3,0 1,0 5,0 2,0 3,0 1,0 ]\n[ 2,0 2,0 2,0 1,0 1,0 3,0 3,0 3,0 5,0 5,0 ]\n</code></pre> </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr Probeklausur1 Probeklausur1.javaCircle.java <pre><code>package probeklausuren.probeklausur1;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Probeklausur1\n{\n    static Random r =  new Random();\n\n    public static Circle createCircle(int bound)\n    {\n        int randNr = r.nextInt(bound);\n        if(randNr &lt; 2)\n        {\n            return new Circle();\n        }\n        else\n        {\n            return new Circle(randNr);\n        }\n    }\n\n    public static List&lt;Circle&gt; setUpCircleList(int listLength, int bound)\n    {\n        List&lt;Circle&gt; list = new ArrayList&lt;Circle&gt;();\n        for(int i = 0; i &lt; listLength; i++)\n        {\n            list.add(createCircle(bound));\n        }\n        return list;\n    }\n\n    /*\n     *   gibt eine Liste mit allen Elementen aus c1 UND c2 zurueck\n     *   in der Liste darf jedoch kein Element doppelt vorkommen, d.h.\n     *   wenn e1 in Liste und e2 in Liste, dann gilt !e1.equals(e2)\n     */\n    public static List&lt;Circle&gt; union(List&lt;Circle&gt; c1, List&lt;Circle&gt; c2)\n    {\n        Set&lt;Circle&gt; unionSet = new HashSet&lt;&gt;(c1);\n        unionSet.addAll(c2);\n        List&lt;Circle&gt; union = new ArrayList&lt;&gt;();\n        union.addAll(unionSet);\n        return union;\n    }\n\n\n    /*\n     *   gibt eine Map zurueck\n     *   Schluessel sind die Flaecheninhalte (area) der Circles\n     *   Werte sind eine Liste aller Circle-Objekte mit diesem Flaecheninhalt\n     */\n    public static Map&lt;Double, List&lt;Circle&gt;&gt; createMap(List&lt;Circle&gt; circles)\n    {\n        Map&lt;Double, List&lt;Circle&gt;&gt; map = new HashMap&lt;&gt;();\n        for(Circle c : circles)\n        {\n            double area = c.area();\n            if(!map.containsKey(area))\n            {\n                List&lt;Circle&gt; list = new ArrayList&lt;&gt;();\n                list.add(c);\n                map.put(area, list);\n            }\n            else\n            {\n                List&lt;Circle&gt; list = map.get(area);\n                list.add(c);\n            }\n        }\n        return map;\n    }\n\n    /*\n     *   fuegt der map alle circles passend hinzu\n     */\n    public static void addListToMap(Map&lt;Double, List&lt;Circle&gt;&gt; map, List&lt;Circle&gt; circles)\n    {\n        for(Circle c : circles)\n        {\n            double area = c.area();\n            if(!map.containsKey(area))\n            {\n                List&lt;Circle&gt; list = new ArrayList&lt;&gt;();\n                list.add(c);\n                map.put(area, list);\n            }\n            else\n            {\n                List&lt;Circle&gt; list = map.get(area);\n                list.add(c);\n            }\n        }\n    }\n\n    /*\n     *   - uebergeben wird eine map, deren keys vom Typ Double sind\n     *   - der Schluessel key ist vom Typ int\n     *   - in der map wird nach einem Schluessel gesucht, dessen ganzzahliger\n     *      Wert dem int key entspricht, d.h.\n     *          78,654 passt zu 78\n     *          79,01 passt nicht zu 78\n     *   - falls ein solcher Schluessel nicht in der map existiert, wird eine\n     *      IllegalArgumentException geworfen. Die Nachricht enthaelt den Wert des\n     *      Schlussels, nach dem gesucht wurde, z.B. 'key 79 not found'\n     *   - falls ein solcher Schluessel existiert, wird der erste Circle aus der\n     *      Liste zu dem Schluessel zurueckgegeben\n     */\n    public static Circle getFirstCircleOfKey(Map&lt;Double, List&lt;Circle&gt;&gt; map, int key)\n    {\n        Double doubleKey = 0.0;\n        for(Double key2 : map.keySet())\n        {\n            if(key2-key &lt; 1 &amp;&amp; key2-key &gt; 0)\n            {\n                doubleKey = key2;\n            }\n        }\n        if(doubleKey &gt; 0.0) {\n            return map.get(doubleKey).getFirst();\n        } else {\n            throw new IllegalArgumentException(\"key \" + key + \" not found\");\n        }\n    }\n\n    /*\n     *   - uebergeben wird eine map, deren keys vom Typ Double sind (area())\n     *   - die Werte sind vom Typ List&lt;Circle&gt;\n     *   - in der map (in den values) wird nach einem Circle gesucht, dessen\n     *     Radius dem Parameterwert von double radius entspricht\n     *   - falls ein solcher Circle existiert, wird er dem Optional hinzugefuegt\n     *     und zur\u00fcckgegeben\n     *   - falls ein solcher Circle nicht existiert, wird ein leeres Optional\n     *     zurueckgegeben\n     */\n    public static Optional&lt;Circle&gt; getFirstCircleOfRadius(Map&lt;Double, List&lt;Circle&gt;&gt; map, double radius)\n    {\n        Collection&lt;List&lt;Circle&gt;&gt; circles = map.values();\n        for(List&lt;Circle&gt; circleList : circles)\n        {\n            for(Circle circle : circleList)\n            {\n                if(Double.compare(circle.getRadius(), radius) == 0)\n                {\n                    return Optional.of(circle);\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    /*\n     * uebergeben wird eine unsortierte Liste von Circle-Objekten\n     * zurueckgegeben wird eine sortierte Liste von Circle-Objekte\n     * sortiert nach \"natural order\" (compareTo)\n     */\n    public static List&lt;Circle&gt; createSortedListOfCircles(List&lt;Circle&gt; circles)\n    {\n        return circles.stream().sorted().collect(Collectors.toList());\n    }\n\n    /*\n     * uebergeben wird eine unsortierte Liste von Circle-Objekten\n     * zurueckgegeben wird eine sortierte Liste von Circle-Objekte\n     * - sortiert nach \"natural order\" (compareTo)\n     * - gerade Radien zuerst!!!\n     */\n    public static List&lt;Circle&gt; createSortedListOfCirclesEvenRadiiFirst(List&lt;Circle&gt; circles)\n    {\n        Map&lt;Boolean, List&lt;Circle&gt;&gt; map = circles.stream().collect(Collectors.partitioningBy(c -&gt; c.getRadius() % 2 == 1));\n        List&lt;Circle&gt; circleList = map.values().stream().flatMap(v -&gt; v.stream().sorted()).collect(Collectors.toList());\n        return circleList;\n    }\n\n    /*\n     * Hilfsmethode zur Ausgabe einer Map&lt;Double, List&lt;Circle&gt;&gt;\n     */\n    private static void printMapOfCircles(Map&lt;Double, List&lt;Circle&gt;&gt; map)\n    {\n        for(Map.Entry&lt;Double, List&lt;Circle&gt;&gt; entry : map.entrySet())\n        {\n            double area = entry.getKey();\n            System.out.printf(\"%n-- area = %6.2f --%n\",area);\n            List&lt;Circle&gt; list = entry.getValue();\n            for(Circle c : list)\n            {\n                System.out.println(c);\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n ---------------------- list1 und list2 ----------------------%n%n\");\n        List&lt;Circle&gt; list1 = setUpCircleList(10, 6);\n        List&lt;Circle&gt; list2 = setUpCircleList(10, 6);\n        System.out.println(\"list1: \");\n        list1.forEach(System.out::println);\n        System.out.println();\n        System.out.println(\"list2: \");\n        list2.forEach(System.out::println);\n\n        System.out.printf(\"%n%n -------------------- union(list1, list2) --------------------%n%n\");\n                    /* print List of union(list1, list2)\n                    * z.B.:\n                        Circle [radius=1.0] area=  3,14 circumference= 6,28\n                        Circle [radius=3.0] area= 28,27 circumference=18,85\n                        Circle [radius=4.0] area= 50,27 circumference=25,13\n                        Circle [radius=5.0] area= 78,54 circumference=31,42\n                    */\n        List&lt;Circle&gt; union = union(list1, list2);\n        for(Circle c : union)\n        {\n            System.out.printf(\"%s area=%6.2f circumference=%5.2f %n\", c, c.area(), c.circumference());\n        }\n\n        System.out.printf(\"%n%n -------------------- createMap(list1) --------------------%n%n\");\n                    /* print Map of createMap(list1)\n                    * z.B.:\n                        -- area =  28,27 --\n                        Circle [radius=3.0]\n                        Circle [radius=3.0]\n\n                        -- area =  78,54 --\n                        Circle [radius=5.0]\n\n                        -- area =   3,14 --\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n\n                        -- area =  50,27 --\n                        Circle [radius=4.0]\n\n                        -- area =  12,57 --\n                        Circle [radius=2.0]\n                    */\n        Map&lt;Double, List&lt;Circle&gt;&gt; map = createMap(list1);\n        printMapOfCircles(map);\n\n        System.out.printf(\"%n%n -------------------- addListToMap(map,list2) --------------------%n%n\");\n                    /* print Map of addListToMap(map,list2)\n                    * z.B.:\n                        -- area =  28,27 --\n                        Circle [radius=3.0]\n                        Circle [radius=3.0]\n\n                        -- area =  78,54 --\n                        Circle [radius=5.0]\n\n                        -- area =   3,14 --\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n                        Circle [radius=1.0]\n\n                        -- area =  50,27 --\n                        Circle [radius=4.0]\n\n                        -- area =  12,57 --\n                        Circle [radius=2.0]\n                    */\n        addListToMap(map, list2);\n        printMapOfCircles(map);\n\n        System.out.printf(\"%n%n -------------------- getFirstCircleOfKey(map,int) --------------------%n%n\");\n        for(int key = 78; key &lt; 80; key++) {\n            try {\n                Circle first = getFirstCircleOfKey(map, key);\n                System.out.println(\"found : \" + first);\n            } catch (IllegalArgumentException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n\n        System.out.printf(\"%n%n -------------------- getFirstCircleOfRadius(map,double) --------------------%n%n\");\n        for(double radius = 5.0; radius &lt; 7.0; radius++) {\n            Optional&lt;Circle&gt; first = getFirstCircleOfRadius(map, radius);\n            if(first.isPresent()) {\n                System.out.println(\"found for radius=\" + radius +\" : \" + first.get());\n            } else {\n                System.out.println(\"no circle with radius=\" + radius +\" found\");\n            }\n        }\n\n        System.out.printf(\"%n%n -------------------- Circle is Comparable  --------------------%n%n\");\n        Circle c1 = createCircle(3);\n        Circle c2 = createCircle(3);\n        System.out.println(\"c1: \" + c1);\n        System.out.println(\"c2: \" + c2);\n\n        if(c1.compareTo(c2) == 0) System.out.println(\"c1 is equal to c2\");\n        else if(c1.compareTo(c2) &gt; 0) System.out.println(\"c1 is greater than c2\");\n        else System.out.println(\"c1 is smaller than c2\");\n\n        System.out.printf(\"%n%n -------------------- createSortedListOfCircles(list) --------------------%n%n\");\n\n        List&lt;Circle&gt; sortedList = createSortedListOfCircles(list1);\n        sortedList.forEach(System.out::println);\n\n        System.out.printf(\"%n%n -------------------- createSortedListOfCirclesEvenRadiiFirst(list) --------------------%n%n\");\n        List&lt;Circle&gt; circles = createSortedListOfCirclesEvenRadiiFirst(list1);\n        circles.forEach(System.out::println);\n    }\n}\n</code></pre> <pre><code>package probeklausuren.probeklausur1;\n\npublic class Circle implements Comparable&lt;Circle&gt;\n{\n    double radius;\n\n    Circle()\n    {\n        this.radius = 1.0;\n    }\n\n    Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    public double getRadius()\n    {\n        return this.radius;\n    }\n\n    public double area()\n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    public double circumference()\n    {\n        return 2 * Math.PI * this.radius;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"Circle [radius=\" + this.radius + \"]\";\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Circle circle = (Circle) o;\n        return circle.radius == this.radius;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int) this.radius;\n    }\n\n    @Override\n    public int compareTo(Circle o)\n    {\n        if (this.radius &gt; o.radius) return 1;\n        else if (this.radius &lt; o.radius) return -1;\n        else return 0;\n    }\n}\n</code></pre>"},{"location":"uebungen/#probeklausur-2","title":"Probeklausur 2","text":"Probeklausur 2 <ol> <li> <p>Gegeben ist der <code>record Person</code> wie folgt: </p> <pre><code>public record Person(String vorname, String nachname, int alter, String ort)\n{\n    @Override\n    public String toString()\n    {\n        return String.format(\"%-8s %-9s aus %-9s ist %2d Jahre alt.\",\n                this.vorname, this.nachname, this.ort, this.alter);\n    }\n}\n</code></pre> </li> <li> <p>Gegeben sind die Klassen <code>Probeklausur2</code> und <code>Probeklausur2Test</code> wie folgt:</p> Probeklausur2.javaProbeklausur2Test.java <pre><code>probeklausuren.probeklausur2;\n\nimport java.util.*;\nimport java.util.stream.Stream;\n\npublic class Probeklausur2\n{\n    static Random r = new Random();\n\n    // Hilfsmethode - bleibt unveraendert (koenen Sie zuklappen)\n    private static Person createPerson()\n    {\n        String[] vornamen = { \"Sophie\", \"Hannah\", \"Emma\", \"Mia\", \"Anna\", \"Elif\",\n                \"Zeynep\", \"Fatma\", \"Aylin\", \"Derya\", \"Layla\", \"Aisha\", \"Noor\",\n                \"Salma\", \"Mariam\" };\n        String[] nachnamen = { \"Schmidt\", \"Schneider\", \"Fischer\", \"Weber\",\n                \"Wagner\", \"Becker\", \"Yilmaz\", \"Kaya\", \"Demir\", \"Polat\",\n                \"Ayd\u0131n\", \"Arslan\", \"Al-Haddad\", \"Al-Mufti\", \"Ibrahim\", \"Khalil\",\n                \"Mansour\" };\n        String[] orte = { \"Berlin\", \"Hamburg\", \"Potsdam\", \"Dresden\", \"Magdeburg\",\n                \"Stuttgart\", \"Leipzig\", \"Dortmund\", \"Essen\", \"Bremen\"\n        };\n        String vorname = vornamen[r.nextInt(vornamen.length)];\n        String nachname = nachnamen[r.nextInt(nachnamen.length)];\n        String ort = orte[r.nextInt(orte.length)];\n        int alter = r.nextInt(10, 100);\n        return new Person(vorname, nachname, alter, ort);\n    }\n\n    // Hilfsmethode - bleibt unveraendert (koenen Sie zuklappen)\n    private static Set&lt;Person&gt; createSetOfPersonen(int numberOfPersonen)\n    {\n        Set&lt;Person&gt; personen = new HashSet&lt;&gt;();\n        for(int i = 0; i &lt; numberOfPersonen; i++)\n        {\n            personen.add(createPerson());\n        }\n        return personen;\n    }\n\n    // TODO siehe 3.\n    public static Set&lt;Person&gt; createSetAelterAls(int alter, Set&lt;Person&gt; personen1, Set&lt;Person&gt; personen2)\n    {\n        return null; // TODO siehe 3.\n    }\n\n    // TODO siehe 5.\n    public static Map&lt;String, Set&lt;Person&gt;&gt; createMapOrtPersonen(Set&lt;Person&gt; personen1, Set&lt;Person&gt; personen2)\n    {\n        return null; // TODO siehe 5.\n    }\n\n    // TODO siehe 10.\n    public static Person getPersonAusOrt(Set&lt;Person&gt; personen, String ort)\n    {\n        return null; // TODO siehe 10.\n    }\n\n    // TODO siehe 13.\n    public static Optional&lt;Person&gt; getPersonMitAlter(Set&lt;Person&gt; personen, int alter)\n    {\n        return null; // TODO siehe 13.\n    }\n\n    public static void main(String[] args)\n    {\n        // --------------- Vorbereitung - bleibt so ----------\n        Set&lt;Person&gt; personen1 = createSetOfPersonen(10);\n        Set&lt;Person&gt; personen2 = createSetOfPersonen(10);\n        System.out.printf(\"%n%n--------------- personen1 set---------------------%n%n\");\n        personen1.forEach(System.out::println);\n        System.out.printf(\"%n%n--------------- personen2 set---------------------%n%n\");\n        personen2.forEach(System.out::println);\n\n        // --------------- ab hier geht's los ----------------\n\n        System.out.printf(\"%n%n--------------- createSetAelterAls(alter, personen1, personen2) ---------------------%n%n\");\n        int alter = r.nextInt(10, 100);\n        System.out.println(\"alle Personen aelter als \" + alter + \": \");\n        // TODO siehe 4.\n\n        System.out.printf(\"%n%n--------------- createMapOrtPersonen(personen1, personen2) ---------------------%n%n\");\n        // TODO siehe 6.\n\n        System.out.printf(\"%n%n--------------- sortieren von personen1 - compareTo ---------------------%n%n\");\n        // TODO siehe 8.\n\n        System.out.printf(\"%n%n--------------- sortieren von personen2 - nach Alter ---------------------%n%n\");\n        // TODO siehe 9.\n\n        System.out.printf(\"%n%n--------------- getPersonAusOrt(Set&lt;Person&gt; personen, String ort) ---------------------%n%n\");\n        // TODO siehe 11.\n\n        System.out.printf(\"%n%n--------------- getPersonMitAlter(Set&lt;Person&gt; personen, int alter) ---------------------%n%n\");\n        for(int alter1 = 20; alter1 &lt; 30; alter1++) {\n            // TODO siehe 14.\n        }\n\n        System.out.printf(\"%n%n--------------- stream Map Anfangsbuchstabe ---------------------%n%n\");\n        Stream&lt;Person&gt; stream1 = Stream.generate(() -&gt; createPerson()).limit(20);\n        // TODO siehe 15.\n\n        // TODO siehe 16.\n\n        // TODO siehe 17.\n\n    }\n\n}\n</code></pre> <pre><code>probeklausuren.probeklausur2;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Probeklausur2Test\n{\n    static Person p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,\n            p11, p12, p13, p14, p15, p16, p17, p18, p19, p20;\n    static Set&lt;Person&gt; persons1,  persons2;\n\n    @BeforeAll\n    public static void setUp()\n    {\n        p1 = new Person(\"Zeynep\", \"Al-Haddad\", 75, \"Stuttgart\");\n        p2 = new Person(\"Mia\", \"Wagner\", 93, \"Berlin\");\n        p3 = new Person(\"Mariam\", \"Yilmaz\", 33, \"Berlin\");\n        p4 = new Person(\"Zeynep\", \"Becker\", 12, \"Bremen\");\n        p5 = new Person(\"Fatma\", \"Becker\", 27, \"Magdeburg\");\n        p6 = new Person(\"Layla\", \"Ayd\u0131n\", 10, \"Essen\");\n        p7 = new Person(\"Emma\", \"Al-Haddad\", 83, \"Hamburg\");\n        p8 = new Person(\"Mia\", \"Al-Mufti\", 27, \"Hamburg\");\n        p9 = new Person(\"Anna\", \"Schmidt\", 45, \"Potsdam\");\n        p10 = new Person(\"Elif\", \"Al-Mufti\", 92, \"Magdeburg\");\n        p11 = new Person(\"Anna\", \"Ibrahim\", 61, \"Bremen\");\n        p12 = new Person(\"Aisha\", \"Wagner\", 78, \"Potsdam\");\n        p13 = new Person(\"Elif\", \"Fischer\", 42, \"Dortmund\");\n        p14 = new Person(\"Emma\", \"Becker\", 15, \"Potsdam\");\n        p15 = new Person(\"Aylin\", \"Khalil\", 72, \"Bremen\");\n        p16 = new Person(\"Elif\", \"Ibrahim\", 82, \"Berlin\");\n        p17 = new Person(\"Elif\", \"Fischer\", 12, \"Leipzig\");\n        p18 = new Person(\"Noor\", \"Al-Mufti\", 62, \"Berlin\");\n        p19 = new Person(\"Mariam\", \"Becker\", 48, \"Dresden\");\n        p20 = new Person(\"Noor\", \"Schneider\", 98, \"Leipzig\");\n\n        persons1 = Set.of(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);\n        persons2 = Set.of(p11, p12, p13, p14, p15, p16, p17, p18, p19, p20);\n    }\n\n    private Comparator&lt;Person&gt; helpSort()\n    {\n        return (o1, o2) -&gt; (o1.nachname().compareTo(o2.nachname()) == 0) ?\n                o1.vorname().compareTo(o2.vorname()) :\n                o1.nachname().compareTo(o2.nachname());\n    }\n\n    @Test\n    @DisplayName(\"createSetAelterAls()\")\n    public void testCreateSetAelterAls()\n    {\n        // given persons1 and persons2\n        int alter = 50;\n\n        // when\n        Set&lt;Person&gt; aelterAls50 = Probeklausur2.createSetAelterAls(alter, persons1, persons2);\n        List&lt;Person&gt; aelterAls50Sorted = aelterAls50.stream().sorted().collect(Collectors.toList());\n        Set&lt;Person&gt; expected = Set.of(p1, p2, p7, p10, p11, p12, p15, p16, p18, p20);\n        List&lt;Person&gt; expectedSorted = expected.stream().sorted().collect(Collectors.toList());\n\n        // then\n        assertEquals(expectedSorted, aelterAls50Sorted, \"createSetAelterAls() doesn't seem to work properly yet\");\n    }\n\n    @Test\n    @DisplayName(\"createMapOrtPersonen()\")\n    public void testCreateMapOrtPersonen()\n    {\n        // given persons1 and persons2\n\n        // when\n        Map&lt;String, Set&lt;Person&gt;&gt; mapOrte = Probeklausur2.createMapOrtPersonen(persons1, persons2);\n        Set&lt;String&gt; orteSet = mapOrte.keySet();\n        List&lt;String&gt; orteSetSorted = orteSet.stream().sorted().collect(Collectors.toList());\n\n        Collection&lt;Set&lt;Person&gt;&gt; valuesColl = mapOrte.values();\n        List&lt;List&lt;Person&gt;&gt; valuesLists = new ArrayList&lt;&gt;();\n        for(Set&lt;Person&gt; set : valuesColl)\n        {\n            valuesLists.add(set.stream().collect(Collectors.toList()));\n        }\n        List&lt;Person&gt; valuesListSorted = valuesLists.stream()\n                .flatMap( l -&gt; l.stream().sorted( helpSort()) )\n                .sorted( (o1, o2) -&gt; o1.ort().compareTo(o2.ort()) )\n                .collect(Collectors.toList());\n\n        Set&lt;String&gt; orteExpected = Set.of(\"Stuttgart\", \"Berlin\", \"Bremen\", \"Magdeburg\",\n                        \"Essen\", \"Hamburg\", \"Potsdam\", \"Dortmund\", \"Leipzig\", \"Dresden\");\n        List&lt;String&gt; orteExpectedSorted = orteSetSorted.stream().sorted().collect(Collectors.toList());\n        List&lt;Person&gt; stuttgart = List.of(p1);\n        List&lt;Person&gt; berlin = List.of(p2, p3, p16, p18);\n        List&lt;Person&gt; bremen = List.of(p4, p11, p15);\n        List&lt;Person&gt; magdeburg = List.of(p5, p10);\n        List&lt;Person&gt; essen = List.of(p6);\n        List&lt;Person&gt; hamburg = List.of(p7, p8);\n        List&lt;Person&gt; potsdam = List.of(p9, p12, p14);\n        List&lt;Person&gt; dortmund = List.of(p13);\n        List&lt;Person&gt; dresden = List.of(p19);\n        List&lt;Person&gt; leipzig = List.of(p17, p20);\n        List&lt;List&lt;Person&gt;&gt; expectedSets = List.of(stuttgart, berlin, bremen, magdeburg, essen, hamburg, potsdam,\n                dortmund, dresden, leipzig);\n        List&lt;Person&gt; expectedSetsSorted = expectedSets.stream()\n                .flatMap( l -&gt; l.stream().sorted( helpSort()) )\n                .sorted( (o1, o2) -&gt; o1.ort().compareTo(o2.ort()) )\n                .collect(Collectors.toList());\n\n        // then\n        assertTrue(mapOrte instanceof Map&lt;String, Set&lt;Person&gt;&gt;, \"createMapOrtPersonen() doesn't seem to work properly yet (wrong return type)\");\n        assertEquals(orteExpectedSorted, orteSetSorted, \"createMapOrtPersonen() doesn't seem to work properly yet (wrong key set)\");\n        assertEquals(expectedSetsSorted, valuesListSorted, \"createMapOrtPersonen() doesn't seem to work properly yet (wrong value collection)\");\n    }\n\n    @Test\n    @DisplayName(\"Person is Comparable\")\n    public void testPersonIsComparable() {\n        // given\n        Set&lt;Person&gt; unsorted = Set.of(p1, p4, p5, p14, p19);\n        List&lt;Person&gt; expected = List.of(p1, p14, p5, p19, p4);\n\n        Object o = p1;\n        if(o instanceof Comparable) {\n            // when\n            List&lt;Person&gt; sorted = unsorted.stream().sorted().collect(Collectors.toList());\n\n            // then\n            assertEquals(expected, sorted, \"compareTo of Person not working properly yet \");\n        }\n        else {\n            fail(\"Person is not Comparable yet\");\n        }\n    }\n\n    @Test\n    @DisplayName(\"getPersonMitAlter()\")\n    public void testGetPersonMitAlter()\n    {\n        int alter = 42;\n        Optional&lt;Person&gt; result1 = Probeklausur2.getPersonMitAlter(persons1, alter);\n        Optional&lt;Person&gt; result2 = Probeklausur2.getPersonMitAlter(persons2, alter);\n        assertTrue(result1.isEmpty(),\"getPersonMitAlter() doesn't seem to work properly yet\");\n        assertEquals(result2.get(), p13, \"getPersonMitAlter() doesn't seem to work properly yet\");\n    }\n\n    /*\n     * Schreiben Sie hinter diesem Kommentar Ihre beiden Testfaelle fuer 12.\n     */\n}\n</code></pre> </li> <li> <p>Implementieren Sie die Methode <code>createSetAelterAls(int alter, Set&lt;Person&gt; personen1, Set&lt;Person&gt; personen2)</code>. Diese Methode gibt eine <code>Set&lt;Person&gt;</code> zur\u00fcck. Die zur\u00fcckgegebene <code>Set</code> anth\u00e4lt alle <code>Person</code>-Objekte aus <code>personen1</code> und <code>personen2</code>, die \u00e4lter als <code>alter</code> sind. </p> <p>\u2192 siehe <code>testCreateSetAelterAls()</code> in <code>Probeklausur2Test</code> (Anzeige <code>createSetAelterAls()</code>)</p> </li> <li> <p>Rufen Sie die <code>createSetAelterAls()</code>-Methode in der <code>main</code>-Methode auf und geben Sie die zur\u00fcckgegebene <code>Set</code> wie folgt auf der Konsole aus (Zufallswerte!):</p> <pre><code>alle Personen aelter als 73: \nZeynep   Mansour   aus Stuttgart ist 93 Jahre alt.\nElif     Arslan    aus Leipzig   ist 95 Jahre alt.\nAnna     Al-Mufti  aus Hamburg   ist 95 Jahre alt.\nZeynep   Fischer   aus Leipzig   ist 76 Jahre alt.\nSophie   Demir     aus Berlin    ist 95 Jahre alt.\nSalma    Schneider aus Magdeburg ist 96 Jahre alt.\n</code></pre> </li> <li> <p>Implementieren Sie die Methode <code>createMapOrtPersonen(Set&lt;Person&gt; personen1, Set&lt;Person&gt; personen2)</code>. Diese Methode gibt eine <code>Map&lt;String, Set&lt;Person&gt;</code> zur\u00fcck. Beachten Sie, dass der <code>value</code> in der <code>Map</code> eine <code>Set</code> und keine <code>List</code> ist! Die zur\u00fcckgegebene <code>Set</code> anth\u00e4lt einmalig alle <code>Person</code>-Objekte aus <code>personen1</code> und <code>personen2</code>. Schl\u00fcssel der Map sind die <code>ort</code>-Eigenschaften der <code>Person</code>-Objekte. </p> <p>\u2192 siehe <code>testCreateMapOrtPersonen()</code> in <code>Probeklausur2Test</code> (Anzeige <code>createMapOrtPersonen()</code>)</p> </li> <li> <p>Rufen Sie die <code>createMapOrtPersonen()</code>-Methode in der <code>main</code>-Methode auf und geben Sie die zur\u00fcckgegebene <code>Map</code> wie folgt auf der Konsole aus (Zufallswerte!):</p> <pre><code>aus Bremen kommen : \n Hannah Ayd\u0131n\n\naus Stuttgart kommen : \n Zeynep Mansour\n Mia Al-Mufti\n Aylin Schneider\n Layla Demir\n\naus Berlin kommen : \n Mia Fischer\n Sophie Demir\n\naus Potsdam kommen : \n Elif Fischer\n\naus Leipzig kommen : \n Elif Arslan\n Zeynep Fischer\n Anna Schneider\n\naus Magdeburg kommen : \n Salma Schneider\n Fatma Wagner\n\naus Dortmund kommen : \n Zeynep Demir\n Mariam Wagner\n\naus Hamburg kommen : \n Emma Al-Haddad\n Anna Al-Mufti\n Layla Weber\n Fatma Ibrahim\n\naus Essen kommen : \n Fatma Ayd\u0131n\n</code></pre> </li> <li> <p>Implementieren Sie f\u00fcr die Klasse <code>Student</code> das <code>Comparable</code>-Interface so, dass eine Ordnung \u00fcber die Nachnamen (<code>nachname</code>) entsteht. Bei gleichem Nachnamen, wird die Ordnung \u00fcber den Vornamen (<code>vorname</code>) erweitert. </p> <p>\u2192 siehe <code>testPersonIsComparable()</code> in <code>Probeklausur2Test</code> (Anzeige <code>Person is Comparable</code>)</p> </li> <li> <p>Erzeugen Sie in der <code>main</code>-Methode aus der Menge <code>personen1</code> eine sortierte Liste unter Verwendung von <code>compareTo()</code>. Geben Sie die sortierte Liste wie folgt aus (Zufallswerte!):</p> <pre><code>Aylin    Ayd\u0131n     aus Leipzig   ist 48 Jahre alt.\nHannah   Ayd\u0131n     aus Magdeburg ist 37 Jahre alt.\nAisha    Becker    aus Berlin    ist 64 Jahre alt.\nFatma    Demir     aus Potsdam   ist 27 Jahre alt.\nSalma    Kaya      aus Leipzig   ist 85 Jahre alt.\nSophie   Kaya      aus Berlin    ist 53 Jahre alt.\nDerya    Polat     aus Dortmund  ist 41 Jahre alt.\nMariam   Schmidt   aus Stuttgart ist 61 Jahre alt.\nEmma     Schneider aus Dortmund  ist 70 Jahre alt.\nLayla    Yilmaz    aus Magdeburg ist 51 Jahre alt.\n</code></pre> </li> <li> <p>Erzeugen Sie in der <code>main</code>-Methode aus der Menge <code>personen2</code> eine nach Alter sortierte Liste. Geben Sie die sortierte Liste wie folgt aus (Zufallswerte!):</p> <pre><code>Noor     Ibrahim   aus Hamburg   ist 30 Jahre alt.\nElif     Wagner    aus Leipzig   ist 35 Jahre alt.\nFatma    Weber     aus Dresden   ist 41 Jahre alt.\nAylin    Weber     aus Leipzig   ist 52 Jahre alt.\nLayla    Khalil    aus Berlin    ist 58 Jahre alt.\nZeynep   Demir     aus Bremen    ist 60 Jahre alt.\nSophie   Arslan    aus Potsdam   ist 62 Jahre alt.\nHannah   Schneider aus Essen     ist 71 Jahre alt.\nNoor     Yilmaz    aus Essen     ist 97 Jahre alt.\nEmma     Wagner    aus Bremen    ist 98 Jahre alt.\n</code></pre> </li> <li> <p>Implementieren Sie die Methode <code>getPersonAusOrt(Set&lt;Person&gt; personen, String ort)</code>. Diese Methode gibt die (erste) <code>Person</code> aus der Menge <code>personen</code> zur\u00fcck, die im Ort <code>ort</code> wohnt. Existiert eine solche <code>Person</code> in <code>personen</code> nicht, wird eine <code>IllegalArgumentException</code> mit der Nachricht <code>Keine Person aus &lt;ort&gt; gefunden.</code> geworfen, wobei <code>&lt;ort&gt;</code> durch den Ort ersetzt wird, nach dem gesucht wurde. </p> <p>\u2192 Tests schreiben Sie (siehe 12.)</p> </li> <li> <p>Rufen Sie die <code>getPersonAusOrt(Set&lt;Person&gt; personen, String ort)</code> in der <code>main</code>-Methode auf. Es wird entweder die zur\u00fcckgegebene Person ausgegeben (Zufallswert):</p> <pre><code>Elif     Kaya      aus Dresden   ist 16 Jahre alt.\n</code></pre> <p>oder die Nachricht aus der <code>IllegalArgumentException</code> (Zufallswert):</p> <pre><code>Keine Person aus Aachen gefunden.\n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>Probeklausur2Test</code> zwei Tests f\u00fcr die Methode <code>getPersonAusOrt(Set&lt;Person&gt; personen, String ort)</code>. </p> <ul> <li>Der erste Test soll pr\u00fcfen, ob ein <code>Student</code>-Objekt korrekt aus einer gegebenen Menge f\u00fcr einen Ort ausgelesen wird, wenn ein passendes <code>Student</code>-Objekt existiert. </li> <li>Der zweite Test soll pr\u00fcfen, ob eine Exception geworfen wird, wenn ein solches Objekt nicht existiert. Au\u00dferdem soll f\u00fcr diesen Fall auch die Korrektheit der Exception-Message gepr\u00fcft werden. </li> </ul> </li> <li> <p>Implementieren Sie die Methode <code>getPersonMitAlter(Set&lt;Person&gt; personen, int alter)</code>. Diese Methode gibt ein <code>Optional</code> zur\u00fcck. Dieses Optional enth\u00e4lt die (erste) <code>Person</code> aus der Menge <code>personen</code> mit dem Alter <code>alter</code>. Existiert eine solche <code>Person</code> in <code>personen</code> nicht, wird ein leeres <code>Optional</code> zur\u00fcckgegeben. </p> <p>\u2192 siehe <code>testGetPersonMitAlter()</code> in <code>Probeklausur2Test</code> (Anzeige <code>getPersonMitAlter()</code>)</p> </li> <li> <p>Rufen Sie die <code>getPersonMitAlter(Set&lt;Person&gt; personen, int alter)</code> in der <code>main</code>-Methode auf. Es wird entweder die im <code>Optional</code> enthaltene Person ausgegeben (Zufallswert):</p> <pre><code>Elif     Kaya      aus Dresden   ist 16 Jahre alt.\n</code></pre> <p>oder eine Nachricht der Form <code>Keine Person mit Alter &lt;alter&gt; gefunden.</code>, wobei <code>&lt;alter&gt;</code> durch das Alter ersetzt wird, nach dem gesucht wurde.</p> </li> <li> <p>Gegeben ist folgender Stream aus 20 <code>Person</code>-Objekten:</p> <pre><code>Stream&lt;Person&gt; stream1 = Stream.generate(() -&gt; createPerson()).limit(20);\n</code></pre> <p>Speichern Sie diesen Stream in eine <code>Map</code>. Die Schl\u00fcssel der <code>Map</code> sind die Anfangsbuchstaben (als <code>Character</code>) der Nachnamen der jeweiligen <code>Person</code>-Objekte. Die Werte der <code>Map</code> sind Listen der Personen, deren Nachname mit dem jeweiligen Buchstaben beginnt. </p> </li> <li> <p>Geben Sie die oben erzeugte <code>Map</code> wie folgt aus (Zufallswerte!):</p> <pre><code>Anfangsbuchstabe A\nFatma    Al-Haddad aus Dortmund  ist 61 Jahre alt.\nSalma    Arslan    aus Potsdam   ist 88 Jahre alt.\nLayla    Al-Haddad aus Berlin    ist 16 Jahre alt.\nMia      Ayd\u0131n     aus Dresden   ist 29 Jahre alt.\nAnna     Ayd\u0131n     aus Potsdam   ist 41 Jahre alt.\nMia      Al-Haddad aus Leipzig   ist 28 Jahre alt.\n\nAnfangsbuchstabe F\nFatma    Fischer   aus Essen     ist 74 Jahre alt.\nEmma     Fischer   aus Dresden   ist 67 Jahre alt.\n\nAnfangsbuchstabe I\nEmma     Ibrahim   aus Berlin    ist 41 Jahre alt.\n\nAnfangsbuchstabe K\nNoor     Kaya      aus Stuttgart ist 19 Jahre alt.\nAnna     Khalil    aus Dresden   ist 63 Jahre alt.\n\nAnfangsbuchstabe M\nFatma    Mansour   aus Magdeburg ist 63 Jahre alt.\nMariam   Mansour   aus Hamburg   ist 69 Jahre alt.\n\nAnfangsbuchstabe P\nZeynep   Polat     aus Magdeburg ist 76 Jahre alt.\n\nAnfangsbuchstabe S\nAnna     Schneider aus Essen     ist 83 Jahre alt.\nSophie   Schmidt   aus Hamburg   ist 15 Jahre alt.\nFatma    Schneider aus Bremen    ist 13 Jahre alt.\n\nAnfangsbuchstabe W\nHannah   Weber     aus Magdeburg ist 69 Jahre alt.\nSophie   Wagner    aus Dortmund  ist 11 Jahre alt.\nAnna     Weber     aus Magdeburg ist 17 Jahre alt.\n</code></pre> <ul> <li>Achtung: Achten Sie darauf, dass die Ausgabe in sortierter Reihenfolge der Anfangsbuchstaben erfolgt.</li> <li>Tip: Speichern Sie die Menge der Schl\u00fcssel der Map in einer sortierten Liste und durchlaufen Sie dann die Liste.</li> </ul> </li> <li> <p>Passen Sie die Ausgabe der Map so an, dass die jeweiligen Wertelisten in \"nat\u00fcrlicher Ordnung\" (Nachname + Vorname) sortiert sind:</p> <pre><code>Anfangsbuchstabe A\nAnna     Al-Haddad aus Magdeburg ist 69 Jahre alt.\nDerya    Al-Haddad aus Leipzig   ist 37 Jahre alt.\nMia      Al-Mufti  aus Hamburg   ist 45 Jahre alt.\nSalma    Al-Mufti  aus Hamburg   ist 30 Jahre alt.\nSalma    Al-Mufti  aus Leipzig   ist 90 Jahre alt.\nDerya    Arslan    aus Potsdam   ist 83 Jahre alt.\nZeynep   Ayd\u0131n     aus Dresden   ist 54 Jahre alt.\n\nAnfangsbuchstabe B\nHannah   Becker    aus Dortmund  ist 96 Jahre alt.\n\nAnfangsbuchstabe D\nAisha    Demir     aus Stuttgart ist 19 Jahre alt.\nElif     Demir     aus Bremen    ist 30 Jahre alt.\n\nAnfangsbuchstabe F\nHannah   Fischer   aus Dortmund  ist 36 Jahre alt.\nSalma    Fischer   aus Bremen    ist 44 Jahre alt.\n\nAnfangsbuchstabe I\nAylin    Ibrahim   aus Berlin    ist 53 Jahre alt.\n\nAnfangsbuchstabe K\nAnna     Kaya      aus Potsdam   ist 82 Jahre alt.\n\nAnfangsbuchstabe M\nNoor     Mansour   aus Essen     ist 22 Jahre alt.\n\nAnfangsbuchstabe P\nElif     Polat     aus Dresden   ist 51 Jahre alt.\n\nAnfangsbuchstabe W\nAisha    Wagner    aus Hamburg   ist 25 Jahre alt.\nAisha    Weber     aus Stuttgart ist 10 Jahre alt.\nMia      Weber     aus Dortmund  ist 36 Jahre alt.\n\nAnfangsbuchstabe Y\nSophie   Yilmaz    aus Potsdam   ist 53 Jahre alt.\n</code></pre> <p>Punkte</p> Aufgabe Punkte \u00a03. <code>createSetAelterAls()</code> \u00a03 Punkte \u00a04. Ausgabe \u00a02 Punkte \u00a05. <code>createMapOrtPersonen()</code> \u00a06 Punkte \u00a06. Ausgabe \u00a04 Punkte \u00a07. <code>Comparable</code> \u00a03 Punkte \u00a08. Sortieren und Ausgabe \u00a02 Punkte \u00a09. Sortieren und Ausgabe \u00a02 Punkte \u00a010. <code>getPersonAusOrt()</code> \u00a04 Punkte \u00a011. Aufruf und Ausgabe \u00a03 Punkte \u00a012. 2 JUnit-Tests \u00a06 Punkte \u00a013. <code>getPersonMitAlter()</code> \u00a03 Punkte \u00a014. Aufruf und Ausgabe \u00a03 Punkte \u00a015. Map Anfangsbuchstabe \u00a02 Punkte \u00a016. Ausgabe sortiert \u00a04 Punkte \u00a017. Werte sortiert \u00a02 Punkte \u00a0korrektes Programm \u00a04 Punkte gesamt 53 Punkte </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr Probeklausur2 Probeklausur2.javaProbeklausur2Test.javaPerson.java <pre><code>package probeklausuren.probeklausur2;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Probeklausur2\n{\n    static Random r = new Random();\n\n    private static Person createPerson()\n    {\n        String[] vornamen = { \"Sophie\", \"Hannah\", \"Emma\", \"Mia\", \"Anna\", \"Elif\",\n                \"Zeynep\", \"Fatma\", \"Aylin\", \"Derya\", \"Layla\", \"Aisha\", \"Noor\",\n                \"Salma\", \"Mariam\" };\n        String[] nachnamen = { \"Schmidt\", \"Schneider\", \"Fischer\", \"Weber\",\n                \"Wagner\", \"Becker\", \"Yilmaz\", \"Kaya\", \"Demir\", \"Polat\",\n                \"Ayd\u0131n\", \"Arslan\", \"Al-Haddad\", \"Al-Mufti\", \"Ibrahim\", \"Khalil\",\n                \"Mansour\" };\n        String[] orte = { \"Berlin\", \"Hamburg\", \"Potsdam\", \"Dresden\", \"Magdeburg\",\n                \"Stuttgart\", \"Leipzig\", \"Dortmund\", \"Essen\", \"Bremen\"\n        };\n        String vorname = vornamen[r.nextInt(vornamen.length)];\n        String nachname = nachnamen[r.nextInt(nachnamen.length)];\n        String ort = orte[r.nextInt(orte.length)];\n        int alter = r.nextInt(10, 100);\n        return new Person(vorname, nachname, alter, ort);\n    }\n\n    private static Set&lt;Person&gt; createSetOfPersonen(int numberOfPersonen)\n    {\n        Set&lt;Person&gt; personen = new HashSet&lt;&gt;();\n        for(int i = 0; i &lt; numberOfPersonen; i++)\n        {\n            personen.add(createPerson());\n        }\n        return personen;\n    }\n\n    public static Set&lt;Person&gt; createSetAelterAls(int alter, Set&lt;Person&gt; personen1, Set&lt;Person&gt; personen2)\n    {\n        Set&lt;Person&gt; personen = new HashSet&lt;&gt;();\n        for(Person person : personen1)\n        {\n            if(person.alter() &gt; alter) personen.add(person);\n        }\n        for(Person person : personen2)\n        {\n            if(person.alter() &gt; alter) personen.add(person);\n        }\n        return personen;\n    }\n\n    public static Map&lt;String, Set&lt;Person&gt;&gt; createMapOrtPersonen(Set&lt;Person&gt; personen1, Set&lt;Person&gt; personen2)\n    {\n        Map&lt;String, Set&lt;Person&gt;&gt; mapOrtPersonen = new HashMap&lt;&gt;();\n        Set&lt;Person&gt; personen = new HashSet&lt;&gt;(personen1);\n        personen.addAll(personen2);\n        for(Person person : personen)\n        {\n            String key = person.ort();\n            if(mapOrtPersonen.containsKey(key))\n            {\n                mapOrtPersonen.get(key).add(person);\n            }\n            else\n            {\n                Set&lt;Person&gt; personenSet = new HashSet&lt;&gt;();\n                personenSet.add(person);\n                mapOrtPersonen.put(key, personenSet);\n            }\n        }\n        return mapOrtPersonen;\n    }\n\n    public static Person getPersonAusOrt(Set&lt;Person&gt; personen, String ort) throws IllegalArgumentException\n    {\n        for(Person person : personen)\n        {\n            if(person.ort().equals(ort)) return person;\n        }\n        throw new IllegalArgumentException(\"Keine Person aus \" + ort + \" gefunden.\");\n    }\n\n    public static Optional&lt;Person&gt; getPersonMitAlter(Set&lt;Person&gt; personen, int alter)\n    {\n        for(Person person : personen)\n        {\n            if(person.alter() == alter) return Optional.of(person);\n        }\n        return Optional.empty();\n    }\n\n    public static void main(String[] args)\n    {\n        Set&lt;Person&gt; personen1 = createSetOfPersonen(10);\n        Set&lt;Person&gt; personen2 = createSetOfPersonen(10);\n        System.out.printf(\"%n%n--------------- personen1 set---------------------%n%n\");\n        personen1.forEach(System.out::println);\n        System.out.printf(\"%n%n--------------- personen2 set---------------------%n%n\");\n        personen2.forEach(System.out::println);\n\n        System.out.printf(\"%n%n--------------- createSetAelterAls(alter, personen1, personen2) ---------------------%n%n\");\n        int alter = r.nextInt(10, 100);\n        System.out.println(\"alle Personen aelter als \" + alter + \": \");\n        //TODO\n        // Aufruf von createSetAelterAls(alter, personen1, personen2);\n        // Ausgabe der zurueckgegebenen Set\n        Set&lt;Person&gt; aelterAls = createSetAelterAls(alter, personen1, personen2);\n        aelterAls.forEach(System.out::println);\n\n        System.out.printf(\"%n%n--------------- createMapOrtPersonen(personen1, personen2) ---------------------%n%n\");\n        //TODO\n        // Aufruf von createMapOrtPersonen(personen1, personen2);\n        // Ausgabe der zurueckgegebenen Map\n        Map&lt;String, Set&lt;Person&gt;&gt; mapOrtPersonen = createMapOrtPersonen(personen1, personen2);\n        mapOrtPersonen.forEach((k,v) -&gt; {\n            System.out.println(\"aus \" + k + \" kommen : \");\n            v.forEach(p -&gt; System.out.println(\" \" + p.vorname() + \" \" + p.nachname()));\n            System.out.println();\n        });\n\n        System.out.printf(\"%n%n--------------- sortieren von personen1 - compareTo ---------------------%n%n\");\n        List&lt;Person&gt; sortiert1 = personen1.stream().sorted().collect(Collectors.toList());\n        sortiert1.forEach(System.out::println);\n\n        System.out.printf(\"%n%n--------------- sortieren von personen2 - nach Alter ---------------------%n%n\");\n        List&lt;Person&gt; sortiert2 = personen2.stream().sorted(Comparator.comparingInt(p -&gt; p.alter())).collect(Collectors.toList());\n        sortiert2.forEach(System.out::println);\n\n        System.out.printf(\"%n%n--------------- getPersonAusOrt(Set&lt;Person&gt; personen, String ort) ---------------------%n%n\");\n        try {\n            Person personAusOrt = getPersonAusOrt(personen1, \"Aachen\");\n            System.out.println(personAusOrt.toString());\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n\n        System.out.printf(\"%n%n--------------- getPersonMitAlter(Set&lt;Person&gt; personen, int alter) ---------------------%n%n\");\n        for(int alter1 = 20; alter1 &lt; 30; alter1++) {\n            Optional&lt;Person&gt; personMitAlter = getPersonMitAlter(personen2, alter1);\n            if (personMitAlter.isPresent()) {\n                System.out.println(personMitAlter.get().toString());\n            }\n            else {\n                System.out.println(\"Keine Person mit Alter \" + alter1 + \" gefunden.\");\n            }\n        }\n\n        System.out.printf(\"%n%n--------------- stream ---------------------%n%n\");\n        Stream&lt;Person&gt; stream1 = Stream.generate(() -&gt; createPerson()).limit(20);\n        Map&lt;Character, List&lt;Person&gt;&gt; startsWithCharMap = stream1\n                .collect(Collectors.groupingBy(p -&gt; p.nachname().charAt(0)));\n        List&lt;Character&gt; sortedKeyList = startsWithCharMap.keySet().stream()\n                .sorted().collect(Collectors.toList());\n        for(Character key : sortedKeyList)\n        {\n            System.out.println(\"Anfangsbuchstabe \" + key);\n            List&lt;Person&gt; sortedValue = startsWithCharMap.get(key);\n            sortedValue.sort(Comparator.naturalOrder()); // Aufgabe 17\n            for(Person person : sortedValue)\n            {\n                System.out.println(person.toString());\n            }\n            System.out.println();\n        }\n\n    }\n\n}\n</code></pre> <pre><code>package probeklausuren.probeklausur2;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Probeklausur2Test\n{\n    static Person p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,\n            p11, p12, p13, p14, p15, p16, p17, p18, p19, p20;\n    static Set&lt;Person&gt; persons1,  persons2;\n\n    @BeforeAll\n    public static void setUp()\n    {\n        p1 = new Person(\"Zeynep\", \"Al-Haddad\", 75, \"Stuttgart\");\n        p2 = new Person(\"Mia\", \"Wagner\", 93, \"Berlin\");\n        p3 = new Person(\"Mariam\", \"Yilmaz\", 33, \"Berlin\");\n        p4 = new Person(\"Zeynep\", \"Becker\", 12, \"Bremen\");\n        p5 = new Person(\"Fatma\", \"Becker\", 27, \"Magdeburg\");\n        p6 = new Person(\"Layla\", \"Ayd\u0131n\", 10, \"Essen\");\n        p7 = new Person(\"Emma\", \"Al-Haddad\", 83, \"Hamburg\");\n        p8 = new Person(\"Mia\", \"Al-Mufti\", 27, \"Hamburg\");\n        p9 = new Person(\"Anna\", \"Schmidt\", 45, \"Potsdam\");\n        p10 = new Person(\"Elif\", \"Al-Mufti\", 92, \"Magdeburg\");\n        p11 = new Person(\"Anna\", \"Ibrahim\", 61, \"Bremen\");\n        p12 = new Person(\"Aisha\", \"Wagner\", 78, \"Potsdam\");\n        p13 = new Person(\"Elif\", \"Fischer\", 42, \"Dortmund\");\n        p14 = new Person(\"Emma\", \"Becker\", 15, \"Potsdam\");\n        p15 = new Person(\"Aylin\", \"Khalil\", 72, \"Bremen\");\n        p16 = new Person(\"Elif\", \"Ibrahim\", 82, \"Berlin\");\n        p17 = new Person(\"Elif\", \"Fischer\", 12, \"Leipzig\");\n        p18 = new Person(\"Noor\", \"Al-Mufti\", 62, \"Berlin\");\n        p19 = new Person(\"Mariam\", \"Becker\", 48, \"Dresden\");\n        p20 = new Person(\"Noor\", \"Schneider\", 98, \"Leipzig\");\n\n        persons1 = Set.of(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);\n        persons2 = Set.of(p11, p12, p13, p14, p15, p16, p17, p18, p19, p20);\n    }\n\n    private boolean checkTowSetsSameElements(Set&lt;Person&gt; set1, Set&lt;Person&gt; set2)\n    {\n        if(set1.size() != set2.size()) return false;\n        for(Person p : set1) if(!set2.contains(p)) return false;\n        for(Person p : set2) if(!set1.contains(p)) return false;\n        return true;\n    }\n\n    private Comparator&lt;Person&gt; helpSort()\n    {\n        return (o1, o2) -&gt; (o1.nachname().compareTo(o2.nachname()) == 0) ?\n                o1.vorname().compareTo(o2.vorname()) :\n                o1.nachname().compareTo(o2.nachname());\n    }\n\n    @Test\n    @DisplayName(\"createSetAelterAls()\")\n    public void testCreateSetAelterAls()\n    {\n        // given persons1 and persons2\n        int alter = 50;\n\n        // when\n        Set&lt;Person&gt; aelterAls50 = Probeklausur2.createSetAelterAls(alter, persons1, persons2);\n        List&lt;Person&gt; aelterAls50Sorted = aelterAls50.stream().sorted().collect(Collectors.toList());\n        Set&lt;Person&gt; expected = Set.of(p1, p2, p7, p10, p11, p12, p15, p16, p18, p20);\n        List&lt;Person&gt; expectedSorted = expected.stream().sorted().collect(Collectors.toList());\n\n        // then\n        assertEquals(expectedSorted, aelterAls50Sorted, \"createSetAelterAls() doesn't seem to work properly yet\");\n    }\n\n    @Test\n    @DisplayName(\"createMapOrtPersonen()\")\n    public void testCreateMapOrtPersonen()\n    {\n        // given persons1 and persons2\n\n        // when\n        Map&lt;String, Set&lt;Person&gt;&gt; mapOrte = Probeklausur2.createMapOrtPersonen(persons1, persons2);\n        Set&lt;String&gt; orteSet = mapOrte.keySet();\n        List&lt;String&gt; orteSetSorted = orteSet.stream().sorted().collect(Collectors.toList());\n\n        Collection&lt;Set&lt;Person&gt;&gt; valuesColl = mapOrte.values();\n        List&lt;List&lt;Person&gt;&gt; valuesLists = new ArrayList&lt;&gt;();\n        for(Set&lt;Person&gt; set : valuesColl)\n        {\n            valuesLists.add(set.stream().collect(Collectors.toList()));\n        }\n        List&lt;Person&gt; valuesListSorted = valuesLists.stream()\n                .flatMap( l -&gt; l.stream().sorted( helpSort()) )\n                .sorted( (o1, o2) -&gt; o1.ort().compareTo(o2.ort()) )\n                .collect(Collectors.toList());\n\n        Set&lt;String&gt; orteExpected = Set.of(\"Stuttgart\", \"Berlin\", \"Bremen\", \"Magdeburg\",\n                        \"Essen\", \"Hamburg\", \"Potsdam\", \"Dortmund\", \"Leipzig\", \"Dresden\");\n        List&lt;String&gt; orteExpectedSorted = orteSetSorted.stream().sorted().collect(Collectors.toList());\n        List&lt;Person&gt; stuttgart = List.of(p1);\n        List&lt;Person&gt; berlin = List.of(p2, p3, p16, p18);\n        List&lt;Person&gt; bremen = List.of(p4, p11, p15);\n        List&lt;Person&gt; magdeburg = List.of(p5, p10);\n        List&lt;Person&gt; essen = List.of(p6);\n        List&lt;Person&gt; hamburg = List.of(p7, p8);\n        List&lt;Person&gt; potsdam = List.of(p9, p12, p14);\n        List&lt;Person&gt; dortmund = List.of(p13);\n        List&lt;Person&gt; dresden = List.of(p19);\n        List&lt;Person&gt; leipzig = List.of(p17, p20);\n        List&lt;List&lt;Person&gt;&gt; expectedSets = List.of(stuttgart, berlin, bremen, magdeburg, essen, hamburg, potsdam,\n                dortmund, dresden, leipzig);\n        List&lt;Person&gt; expectedSetsSorted = expectedSets.stream()\n                .flatMap( l -&gt; l.stream().sorted( helpSort()) )\n                .sorted( (o1, o2) -&gt; o1.ort().compareTo(o2.ort()) )\n                .collect(Collectors.toList());\n\n        // then\n        assertTrue(mapOrte instanceof Map&lt;String, Set&lt;Person&gt;&gt;, \"createMapOrtPersonen() doesn't seem to work properly yet (wrong return type)\");\n        assertEquals(orteExpectedSorted, orteSetSorted, \"createMapOrtPersonen() doesn't seem to work properly yet (wrong key set)\");\n        assertEquals(expectedSetsSorted, valuesListSorted, \"createMapOrtPersonen() doesn't seem to work properly yet (wrong value collection)\");\n    }\n\n    @Test\n    @DisplayName(\"Person is Comparable\")\n    public void testPersonIsComparable() {\n        // given\n        Set&lt;Person&gt; unsorted = Set.of(p1, p4, p5, p14, p19);\n        List&lt;Person&gt; expected = List.of(p1, p14, p5, p19, p4);\n\n        assertTrue(p1 instanceof Comparable, \"Person is not Comparable yet\");\n        if(p1 instanceof Comparable) {\n\n            // when\n            List&lt;Person&gt; sorted = unsorted.stream().sorted().collect(Collectors.toList());\n\n            // then\n            assertEquals(expected, sorted, \"compareTo of Person not working properly yet \");\n        }\n    }\n\n    @Test\n    @DisplayName(\"getPersonMitAlter()\")\n    public void testGetPersonMitAlter()\n    {\n        int alter = 42;\n        Optional&lt;Person&gt; result1 = Probeklausur2.getPersonMitAlter(persons1, alter);\n        Optional&lt;Person&gt; result2 = Probeklausur2.getPersonMitAlter(persons2, alter);\n        assertTrue(result1.isEmpty(),\"getPersonMitAlter() doesn't seem to work properly yet\");\n        assertEquals(result2.get(), p13, \"getPersonMitAlter() doesn't seem to work properly yet\");\n    }\n\n    /*\n     * Schreiben Sie hinter diesem Kommentar Ihre beiden Testfaelle fuer 12.\n     */\n\n    @Test\n    @DisplayName(\"getPersonAusOrt() - Student\")\n    public void testGetPersonAusOrt()\n    {\n        Person result = Probeklausur2.getPersonAusOrt(persons1, \"Essen\");\n        assertEquals(p6, result, \"getPersonAusOrt(persons1, Essen)\");\n    }\n\n    @Test\n    @DisplayName(\"getPersonAusOrt() - Exception\")\n    public void testGetPersonAusOrtException()\n    {\n        Exception e = assertThrows(IllegalArgumentException.class, () -&gt; Probeklausur2.getPersonAusOrt(persons1, \"Leipzig\"));\n        assertEquals(\"Keine Person aus Leipzig gefunden.\", e.getMessage(), \"getPersonAusOrt(persons1, Leipzig)\");\n    }\n}\n</code></pre> <pre><code>package probeklausuren.probeklausur2;\n\npublic record Person(String vorname, String nachname, int alter, String ort) implements Comparable&lt;Person&gt;\n{\n    @Override\n    public String toString()\n    {\n        return String.format(\"%-8s %-9s aus %-9s ist %2d Jahre alt.\",\n                this.vorname, this.nachname, this.ort, this.alter);\n    }\n\n    @Override\n    public int compareTo(Person o)\n    {\n        if(this.nachname.compareTo(o.nachname) != 0) return this.nachname.compareTo(o.nachname);\n        else return this.vorname.compareTo(o.vorname);\n    }\n}\n</code></pre>"},{"location":"uebungen/#probeklausur-3","title":"Probeklausur 3","text":"Probeklausur 3 <ol> <li> <p>Gegeben ist der <code>record Adresse</code> wie folgt: </p> <pre><code>public record Adresse(String stadt, int plz, String strasse, short hausnummer)\n{\n    @Override\n    public String toString()\n    {\n        return String.format(\"%-21s in %5d %-9s\",\n                this.strasse + \" \" + this.hausnummer, this.plz, this.stadt);\n    }\n}\n</code></pre> </li> <li> <p>Gegeben sind die Klassen <code>Probeklausur3</code> und <code>Probeklausur3Test</code> wie folgt:</p> Probeklausur3.javaProbeklausur3Test.java <pre><code>package klausur;\n\nimport java.util.*;\n\npublic class Probeklausur3\n{\n    static Random r = new Random();\n\n    // Hilfsmethode - bleibt unveraendert (koenen Sie zuklappen)\n    private static Adresse createAdresse()\n    {\n        String[] strassen = {\"Sonnenblumenweg\", \"Waldlichtungstra\u00dfe\", \"Mondscheinpfad\",\n                \"Gl\u00fcckskleeallee\", \"Regenbogenpromenade\", \"Sternenstaubgasse\",\n                \"Kastanienhain\", \"Lavendelweg\", \"Wasserfallgasse\", \"Kirschbl\u00fctenallee\"};\n        String[] staedte = {\"Berlin\", \"Hamburg\", \"M\u00fcnchen\", \"K\u00f6ln\", \"Stuttgart\"};\n        Map&lt;String, List&lt;Integer&gt;&gt; postleitzahlen = Map.of(\n                \"Berlin\", List.of(13187, 10245, 10437, 10318, 12167, 12555),\n                \"Hamburg\", List.of(22525, 20359),\n                \"M\u00fcnchen\", List.of(80939, 81547, 80802),\n                \"K\u00f6ln\", List.of(50933, 50697, 50667),\n                \"Stuttgart\", List.of(70372)\n        );\n        short nr = (short)(r.nextInt(10) + 1);\n        String strasse = strassen[r.nextInt(strassen.length)];\n        String stadt = staedte[r.nextInt(staedte.length)];\n        var values = postleitzahlen.get(stadt);\n        int plz = values.get(r.nextInt(values.size()));\n        return new Adresse(stadt, plz, strasse, nr);\n    }\n\n    // Hilfsmethode - bleibt unveraendert (koenen Sie zuklappen)\n    public static Set&lt;Adresse&gt; createSetOfAdressen(int numberOfAdressen)\n    {\n        Set&lt;Adresse&gt; adressen = new HashSet&lt;&gt;();\n        for(int i = 0; i &lt; numberOfAdressen; i++)\n        {\n            adressen.add(createAdresse());\n        }\n        return adressen;\n    }\n\n    /*  TODO 3:\n     *  Map erzeugen,\n     *  Schluessel sind die Staedte aus adressen\n     *  Werte sind Listen aus adressen mit der entsprechenden Stadt\n     */\n    public static Map&lt;String, List&lt;Adresse&gt;&gt; createMapIndexedByCity(Set&lt;Adresse&gt; adressen)\n    {\n        return null; // TODO siehe 3.\n    }\n\n    /*  TODO 6:\n     *  Map erzeugen,\n     *  Schluessel sind die Staedte aus adressen\n     *  Werte sind Mengen aus den postleitzahlen der entsprechenden Stadt\n     */\n    public static Map&lt;String, Set&lt;Integer&gt;&gt; createMapIndexedByCitySetOfPLZ(Set&lt;Adresse&gt; adressen)\n    {\n        return null; // TODO siehe 6.\n    }\n\n    /*  TODO 8:\n     *  Map erzeugen,\n     *  Schluessel sind die Strassen, die in adressen in MEHREREN Staedten vorkommen\n     *  Werte sind Liste der Staedte mit den entsprechenden Strassen\n     */\n    public static Map&lt;String, List&lt;String&gt;&gt; createMapStreetsMultiple(Set&lt;Adresse&gt; adressen)\n    {\n        return null; // TODO siehe 8.\n    }\n\n    /*  TODO 10:\n     *  Stadt mit plz aus adressen suchen,\n     *  wenn Stadt mit plz existiert, dann Stadt zurueckgeben\n     *  wenn Stadt mit plz nicht existiert, dann IllegalArgumentException werfen\n     */\n    public static String getStadtMitPLZ(Set&lt;Adresse&gt; adressen, int plz)\n    {\n        return null; // TODO siehe 10.\n    }\n\n    /*  TODO 13:\n     *  Stadt mit plzStartsWith aus adressen suchen,\n     *  plzStartsWith ist der Beginn einer Postleitzahl, z.B. 22\n     *  wenn Stadt mit plzStartsWith existiert, dann Stadt im Optional zurueckgeben\n     *  wenn Stadt mit plzStartsWith nicht existiert, dann leeres Optional zurueckgeben\n     */\n    public static Optional&lt;String&gt; getStadtMitPLZstartsWith(Set&lt;Adresse&gt; adressen, int plzStartsWith)\n    {\n        return null; // TODO siehe 13.\n    }\n\n    /*\n     *  folgende Methode auskommentieren, nachdem Sie Interface Filterable erstellt haben\n     *  siehe TODO 15 und 16\n     */\n    /*\n    public static List&lt;Adresse&gt; filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter) {\n        return adressen.stream()\n                .filter(filter::filter)\n                .collect(Collectors.toList());\n    }\n    */\n\n    public static void main(String[] args)\n    {\n        // --------------- Vorbereitung - bleibt so ----------&gt;\n        Set&lt;Adresse&gt; adressen = createSetOfAdressen(20);\n        System.out.printf(\"%n%n--------------- adressen set---------------------%n%n\");\n        adressen.forEach(System.out::println);\n        // &lt;--------------- Vorbereitung - bleibt so ----------\n\n        System.out.printf(\"%n%n--------------- createMapIndexedByCity(Set&lt;Adresse&gt; adressen) ---------------------%n%n\");\n        // TODO siehe 4.\n\n        System.out.printf(\"%n%n----------- createMapIndexedByCity(Set&lt;Adresse&gt; adressen) sortiert ------------------%n%n\");\n        // TODO siehe 5.\n\n        System.out.printf(\"%n%n----------- createMapIndexedByCitySetOfPLZ(Set&lt;Adresse&gt; adressen) ------------------%n%n\");\n        // TODO siehe 7.\n\n        System.out.printf(\"%n%n-------------- createMapStreetsMultiple(Set&lt;Adresse&gt; adressen) ---------------------%n%n\");\n        // TODO siehe 9.\n\n        System.out.printf(\"%n%n--------------- getStadtMitPLZ(Set&lt;Adresse&gt; adressen, int plz) ---------------------%n%n\");\n        // TODO siehe 11.\n\n        System.out.printf(\"%n%n---------- getStadtMitPLZstartsWith(Set&lt;Adresse&gt; adressen, int plzStartsWith) -------------%n%n\");\n        for(int plzStartsWith = 21; plzStartsWith &lt; 24; plzStartsWith++) {\n            // TODO siehe 14.\n        }\n\n        System.out.printf(\"%n%n------ Filterable und filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter) ------%n%n\");\n        // TODO siehe 15 und 16.\n        // vorher Kommentare von Methode filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter) entfernen!\n\n\n        System.out.printf(\"%n%n------ Liste aller Staedte (keine Doppelungen) aus adressen alphabetisch sortiert ------%n%n\");\n        // TODO siehe 17.\n\n        System.out.printf(\"%n%n------ Liste aller Strassen + Hausnummer aus adressen alphabetisch absteigend sortiert ------%n%n\");\n        // TODO siehe 18.\n    }\n}\n</code></pre> <pre><code>package aufgabe;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Probeklausur3Test\n{\n    static Adresse a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n    static Set&lt;Adresse&gt; adressen;\n\n    @BeforeAll\n    public static void setUp()\n    {\n        a1= new Adresse(\"K\u00f6ln\",50667,\"Waldlichtungstra\u00dfe\",(short)10);\n        a2= new Adresse(\"M\u00fcnchen\",80939,\"Lavendelweg\",(short)1);\n        a3= new Adresse(\"Hamburg\",20359,\"Sternenstaubgasse\",(short)7);\n        a4= new Adresse(\"K\u00f6ln\",50697,\"Sonnenblumenweg\",(short)6);\n        a5= new Adresse(\"K\u00f6ln\",50697,\"Kastanienhain\",(short)1);\n        a6= new Adresse(\"M\u00fcnchen\",81547,\"Wasserfallgasse\",(short)6);\n        a7= new Adresse(\"M\u00fcnchen\",80939,\"Gl\u00fcckskleeallee\",(short)1);\n        a8= new Adresse(\"K\u00f6ln\",50697,\"Sternenstaubgasse\",(short)10);\n        a9= new Adresse(\"Hamburg\",22525,\"Kirschbl\u00fctenallee\",(short)6);\n        a10= new Adresse(\"K\u00f6ln\",50667,\"Lavendelweg\",(short)7);\n        a11= new Adresse(\"Stuttgart\",70372,\"Sternenstaubgasse\",(short)4);\n        a12= new Adresse(\"Berlin\",12167,\"Regenbogenpromenade\",(short)4);\n        a13= new Adresse(\"Hamburg\",22525,\"Regenbogenpromenade\",(short)2);\n        a14= new Adresse(\"Hamburg\",20359,\"Kirschbl\u00fctenallee\",(short)5);\n        a15= new Adresse(\"Berlin\",12555,\"Kirschbl\u00fctenallee\",(short)6);\n        a16= new Adresse(\"Berlin\",10437,\"Kirschbl\u00fctenallee\",(short)10);\n        a17= new Adresse(\"M\u00fcnchen\",80939,\"Waldlichtungstra\u00dfe\",(short)5);\n        a18= new Adresse(\"K\u00f6ln\",50933,\"Sonnenblumenweg\",(short)6);\n        a19= new Adresse(\"Berlin\",12555,\"Regenbogenpromenade\",(short)4);\n        a20= new Adresse(\"M\u00fcnchen\",81547,\"Mondscheinpfad\",(short)1);\n\n        Adresse[] arr_adressen = {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20};\n\n        adressen = new HashSet&lt;Adresse&gt;();\n        for(Adresse adresse : arr_adressen) adressen.add(adresse);\n    }\n\n    private static boolean stringSetsAreIdentical(Set&lt;String&gt; set1, Set&lt;String&gt; set2)\n    {\n        if (set1.size() != set2.size()) return false;\n        for(String word : set1)\n        {\n            if(!set2.contains(word)) return false;\n        }\n        for(String word : set2)\n        {\n            if(!set1.contains(word)) return false;\n        }\n        return true;\n    }\n\n    private static boolean integerSetsAreIdentical(Set&lt;Integer&gt; set1, Set&lt;Integer&gt; set2)\n    {\n        if (set1.size() != set2.size()) return false;\n        for(Integer number : set1)\n        {\n            if(!set2.contains(number)) return false;\n        }\n        for(Integer number : set2)\n        {\n            if(!set1.contains(number)) return false;\n        }\n        return true;\n    }\n\n    private static boolean addressListsAreIdentical(List&lt;Adresse&gt; list1, List&lt;Adresse&gt; list2)\n    {\n        if (list1.size() != list2.size()) return false;\n        for(Adresse adresse : list1)\n        {\n            if(!list2.contains(adresse)) return false;\n        }\n        for(Adresse adresse : list2)\n        {\n            if(!list1.contains(adresse)) return false;\n        }\n        return true;\n    }\n\n    private static boolean stringListsAreIdentical(List&lt;String&gt; list1, List&lt;String&gt; list2)\n    {\n        if (list1.size() != list2.size()) return false;\n        for(String word : list1)\n        {\n            if(!list2.contains(word)) return false;\n        }\n        for(String word : list2)\n        {\n            if(!list1.contains(word)) return false;\n        }\n        return true;\n    }\n\n\n    @Test\n    @DisplayName(\"createMapIndexedByCity()\")\n    public void testCreateMapIndexedByCity()\n    {\n        //given\n        Map&lt;String, List&lt;Adresse&gt;&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(\"Berlin\", List.of(a12,a15,a16,a19));\n        map1.put(\"K\u00f6ln\", List.of(a1,a4,a5,a8,a10,a18));\n        map1.put(\"Hamburg\", List.of(a3,a9,a13,a14));\n        map1.put(\"M\u00fcnchen\", List.of(a2,a6,a7,a17,a20));\n        map1.put(\"Stuttgart\", List.of(a11));\n\n        //when\n        Map&lt;String, List&lt;Adresse&gt;&gt; map2 = Probeklausur3.createMapIndexedByCity(adressen);\n\n        //then\n        assertTrue(stringSetsAreIdentical(map1.keySet(), map2.keySet()), \"key set seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"Berlin\"), map2.get(\"Berlin\")), \"address list for Berlin seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"K\u00f6ln\"), map2.get(\"K\u00f6ln\")), \"address list for K\u00f6ln seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"Hamburg\"), map2.get(\"Hamburg\")), \"address list for Hamburg seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"M\u00fcnchen\"), map2.get(\"M\u00fcnchen\")), \"address list for M\u00fcnchen seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"Stuttgart\"), map2.get(\"Stuttgart\")), \"address list for Stuttgart seems to be wrong\");\n    }\n\n    @Test\n    @DisplayName(\"createMapIndexedByCitySetOfPLZ()\")\n    public void testCreateMapIndexedByCitySetOfPLZ()\n    {\n        //given\n        Map&lt;String, Set&lt;Integer&gt;&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(\"Berlin\", Set.of(12167,12555,10437));\n        map1.put(\"K\u00f6ln\", Set.of(50667,50697,50933));\n        map1.put(\"Hamburg\", Set.of(20359,22525));\n        map1.put(\"M\u00fcnchen\", Set.of(80939,81547));\n        map1.put(\"Stuttgart\", Set.of(70372));\n\n        //when\n        Map&lt;String, Set&lt;Integer&gt;&gt; map2 = Probeklausur3.createMapIndexedByCitySetOfPLZ(adressen);\n\n        //then\n        assertTrue(stringSetsAreIdentical(map1.keySet(), map2.keySet()), \"key set seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"Berlin\"), map2.get(\"Berlin\")), \"plz set for Berlin seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"K\u00f6ln\"), map2.get(\"K\u00f6ln\")), \"plz set for K\u00f6ln seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"Hamburg\"), map2.get(\"Hamburg\")), \"plz set for Hamburg seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"M\u00fcnchen\"), map2.get(\"M\u00fcnchen\")), \"plz set for M\u00fcnchen seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"Stuttgart\"), map2.get(\"Stuttgart\")), \"plz set for Stuttgart seems to be wrong\");\n    }\n\n    @Test\n    @DisplayName(\"createMapStreetsMultiple()\")\n    public void testCreateMapStreetsMultiple()\n    {\n        //given\n        Map&lt;String, List&lt;String&gt;&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(\"Waldlichtungstra\u00dfe\", List.of(\"K\u00f6ln\",\"M\u00fcnchen\"));\n        map1.put(\"Sternenstaubgasse\", List.of(\"K\u00f6ln\",\"Hamburg\",\"Stuttgart\"));\n        map1.put(\"Lavendelweg\", List.of(\"K\u00f6ln\",\"M\u00fcnchen\"));\n        map1.put(\"Kirschbl\u00fctenallee\", List.of(\"Hamburg\",\"Berlin\"));\n        map1.put(\"Regenbogenpromenade\", List.of(\"Hamburg\",\"Berlin\"));\n\n        //when\n        Map&lt;String, List&lt;String&gt;&gt; map2 = Probeklausur3.createMapStreetsMultiple(adressen);\n\n        //then\n        assertTrue(stringSetsAreIdentical(map1.keySet(), map2.keySet()), \"key set seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Waldlichtungstra\u00dfe\"), map2.get(\"Waldlichtungstra\u00dfe\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Sternenstaubgasse\"), map2.get(\"Sternenstaubgasse\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Lavendelweg\"), map2.get(\"Lavendelweg\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Kirschbl\u00fctenallee\"), map2.get(\"Kirschbl\u00fctenallee\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Regenbogenpromenade\"), map2.get(\"Regenbogenpromenade\")), \"createMapStreetsMultiple seems to be wrong\");\n    }\n\n    @Test\n    @DisplayName(\"getStadtMitPLZstartsWith()\")\n    public void testGetStadtMitPLZstartsWith()\n    {\n        //given\n        int plzStartsWith1 = 22;\n        int plzStartsWith2 = 23;\n\n        //when\n        Optional&lt;String&gt; result1 = Probeklausur3.getStadtMitPLZstartsWith(adressen, plzStartsWith1);\n        Optional&lt;String&gt; result2 = Probeklausur3.getStadtMitPLZstartsWith(adressen, plzStartsWith2);\n        assertEquals(result2.get(), \"Hamburg\", \"getStadtMitPLZstartsWith() doesn't seem to work properly yet\");\n        assertTrue(result1.isEmpty(),\"getStadtMitPLZstartsWith() doesn't seem to work properly yet\");\n    }\n\n    /*\n     * Schreiben Sie hinter diesem Kommentar Ihre beiden Testfaelle fuer 12.\n     */\n\n}\n</code></pre> </li> <li> <p>Implementieren Sie die Methode <code>createMapIndexedByCity(Set&lt;Adresse&gt; adressen)</code>. Diese Methode gibt eine <code>Map&lt;String, List&lt;Adresse&gt;&gt;</code> zur\u00fcck. Die zur\u00fcckgegebene <code>Map</code> anth\u00e4lt als Schl\u00fcssel alle St\u00e4dte aus <code>adressen</code>. Die Werte sind die Listen von Adressen aus den entsprechenden St\u00e4dten. </p> <p>\u2192 siehe <code>testCreateMapIndexedByCity()</code> in <code>Probeklausur3Test</code> (Anzeige <code>createMapIndexedByCity()</code>)</p> </li> <li> <p>Rufen Sie die <code>createMapIndexedByCity()</code>-Methode in der <code>main</code>-Methode auf und geben Sie die zur\u00fcckgegebene <code>Map</code> wie folgt auf der Konsole aus (Zufallswerte!):</p> <pre><code>--------------- createMapIndexedByCity(Set&lt;Adresse&gt; adressen) ---------------------\n\nStadt : Berlin\n---------------------\nSonnenblumenweg 1\nSternenstaubgasse 8\nKirschbl\u00fctenallee 5\nKirschbl\u00fctenallee 7\nKirschbl\u00fctenallee 6\n---------------------\n\nStadt : Stuttgart\n---------------------\nSonnenblumenweg 4\nMondscheinpfad 10\nRegenbogenpromenade 2\nKirschbl\u00fctenallee 7\nLavendelweg 1\nRegenbogenpromenade 6\nLavendelweg 10\nSonnenblumenweg 10\n---------------------\n\nStadt : K\u00f6ln\n---------------------\nWaldlichtungstra\u00dfe 8\nGl\u00fcckskleeallee 3\n---------------------\n\nStadt : Hamburg\n---------------------\nMondscheinpfad 6\nGl\u00fcckskleeallee 6\n---------------------\n\nStadt : M\u00fcnchen\n---------------------\nGl\u00fcckskleeallee 1\nWaldlichtungstra\u00dfe 6\nWaldlichtungstra\u00dfe 2\n---------------------\n</code></pre> <p>d.h. immer erst die Stadt, dann eine Linie (L\u00e4nge egal), dann aus den Adressen jeweils Stra\u00dfe und Hausnummer. Zuletzt eine Linie und eine Leerzeile.</p> </li> <li> <p>Geben Sie nun in <code>main</code> die gleiche <code>Map</code> (aus <code>5.</code>) sortiert aus, d.h. sowohl die St\u00e4dte erscheinen in sortierter Reihenfolge als auch f\u00fcr jede einzelne Stadt die Stra\u00dfen aus den Adressen). Bei gleichem Stra\u00dfennamen wird nach Hausnummer sortiert.</p> <pre><code>----------- createMapIndexedByCity(Set&lt;Adresse&gt; adressen) sortiert ------------------\n\nStadt : Berlin\n---------------------\nKirschbl\u00fctenallee 5\nKirschbl\u00fctenallee 6\nKirschbl\u00fctenallee 7\nSonnenblumenweg 1\nSternenstaubgasse 8\n---------------------\n\nStadt : Hamburg\n---------------------\nGl\u00fcckskleeallee 6\nMondscheinpfad 6\n---------------------\n\nStadt : K\u00f6ln\n---------------------\nGl\u00fcckskleeallee 3\nWaldlichtungstra\u00dfe 8\n---------------------\n\nStadt : M\u00fcnchen\n---------------------\nGl\u00fcckskleeallee 1\nWaldlichtungstra\u00dfe 2\nWaldlichtungstra\u00dfe 6\n---------------------\n\nStadt : Stuttgart\n---------------------\nKirschbl\u00fctenallee 7\nLavendelweg 1\nLavendelweg 10\nMondscheinpfad 10\nRegenbogenpromenade 2\nRegenbogenpromenade 6\nSonnenblumenweg 4\nSonnenblumenweg 10\n---------------------\n</code></pre> </li> <li> <p>Implementieren Sie die Methode <code>createMapIndexedByCitySetOfPLZ(Set&lt;Adresse&gt; adressen)</code>. Diese Methode gibt eine <code>Map&lt;String, Set&lt;Integer&gt;&gt;</code> zur\u00fcck. Die zur\u00fcckgegebene <code>Map</code> anth\u00e4lt als Schl\u00fcssel alle St\u00e4dte aus <code>adressen</code>. Die Werte sind die Mengen der Postleitzahlen der entsprechenden Stadt aus <code>adressen</code>. </p> <p>\u2192 siehe <code>testCreateMapIndexedByCitySetOfPLZ()</code> in <code>Probeklausur3Test</code> (Anzeige <code>createMapIndexedByCitySetOfPLZ()</code>)</p> </li> <li> <p>Rufen Sie die <code>createMapIndexedByCitySetOfPLZ()</code>-Methode in der <code>main</code>-Methode auf und geben Sie die zur\u00fcckgegebene <code>Map</code> wie folgt auf der Konsole aus (Zufallswerte!):</p> <pre><code>----------- createMapIndexedByCitySetOfPLZ(Set&lt;Adresse&gt; adressen) ------------------\n\nBerlin     : [ 13187 12167 12555 10318 ]\nStuttgart  : [ 70372 ]\nK\u00f6ln       : [ 50667 ]\nHamburg    : [ 22525 ]\nM\u00fcnchen    : [ 80802 81547 ]\n</code></pre> <p>d.h. immer erst die Stadt, dann Postleitzahlen in eckigen Klammern durch Leerzeichen getrennt.</p> </li> <li> <p>Implementieren Sie die Methode <code>createMapStreetsMultiple(Set&lt;Adresse&gt; adressen)</code>. Diese Methode gibt eine <code>Map&lt;String, List&lt;String&gt;&gt;</code> zur\u00fcck. Die zur\u00fcckgegebene <code>Map</code> anth\u00e4lt als Schl\u00fcssel alle Stra\u00dfen, die in <code>adressen</code> in mehreren St\u00e4dten vorkommen. Die Werte sind die Listen der St\u00e4dte mit den entsprechenden Stra\u00dfen.  </p> <p>\u2192 siehe <code>testCreateMapStreetsMultiple()</code> in <code>Probeklausur3Test</code> (Anzeige <code>createMapStreetsMultiple()</code>)</p> <p>Tipp: Sie k\u00f6nnten sich erst eine Map erstellen mit den Stra\u00dfen als Schl\u00fcssel und Mengen der Adressen als Werte, dann diese Map durchgehen und schauen, welche Wertemengen gr\u00f6\u00dfer als 1 sind.</p> </li> <li> <p>Rufen Sie die <code>createMapStreetsMultiple()</code>-Methode in der <code>main</code>-Methode auf und geben Sie die zur\u00fcckgegebene <code>Map</code> wie folgt auf der Konsole aus (Zufallswerte!)::</p> <pre><code>-------------- createMapStreetsMultiple(Set&lt;Adresse&gt; adressen) ---------------------\n\nGl\u00fcckskleeallee      : [ K\u00f6ln Hamburg M\u00fcnchen ]\nWaldlichtungstra\u00dfe   : [ K\u00f6ln M\u00fcnchen ]\nKirschbl\u00fctenallee    : [ Stuttgart Berlin ]\nMondscheinpfad       : [ Stuttgart Hamburg ]\nSonnenblumenweg      : [ Stuttgart Berlin ]\n</code></pre> <p>d.h. immer erst die Stra\u00dfe, dann die St\u00e4dte in eckigen Klammern durch Leerzeichen getrennt.</p> </li> <li> <p>Implementieren Sie die Methode <code>getStadtMitPLZ(Set&lt;Adresse&gt; adressen, int plz)</code>. Diese Methode gibt die <code>Stadt</code> aus der Menge <code>adressen</code> zur\u00fcck, f\u00fcr die Postleitzahl <code>plz</code> verwendet wird. Existiert eine solche <code>Stadt</code> in <code>adressen</code> nicht, wird eine <code>IllegalArgumentException</code> mit der Nachricht <code>Keine Stadt mit Postleitzahl &lt;plz&gt; gefunden.</code> geworfen, wobei <code>&lt;plz&gt;</code> durch die Postleitzahl ersetzt wird, nach der gesucht wurde. </p> <p>\u2192 Tests schreiben Sie (siehe 12.)</p> </li> <li> <p>Rufen Sie die <code>getStadtMitPLZ(Set&lt;Adresse&gt; adressen, int plz)</code> in der <code>main</code>-Methode auf. Es wird entweder die zur\u00fcckgegebene Stadt ausgegeben (hier f\u00fcr Wert <code>22525</code>):</p> <pre><code>Hamburg\n</code></pre> <p>oder die Nachricht aus der <code>IllegalArgumentException</code> (hier f\u00fcr Wert <code>22526</code>):</p> <pre><code>Keine Stadt mit Postleitzahl 22526 gefunden.\n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>KlausurTest</code> zwei Tests f\u00fcr die Methode <code>getStadtMitPLZ(Set&lt;Adresse&gt; adressen, int plz)</code>. </p> <ul> <li>Der erste Test soll pr\u00fcfen, ob eine <code>Stadt</code> korrekt aus einer gegebenen Menge (Sie k\u00f6nnen <code>adressen</code> aus <code>KlausrTest</code> verwenden) f\u00fcr eine gegebene Postleitzahl ausgelesen wird, wenn eine passende <code>Stadt</code> existiert. </li> <li>Der zweite Test soll pr\u00fcfen, ob eine Exception geworfen wird, wenn eine solche Stadt nicht existiert. Au\u00dferdem soll f\u00fcr diesen Fall auch die Korrektheit der Exception-Message gepr\u00fcft werden. </li> </ul> </li> <li> <p>Implementieren Sie die Methode <code>getStadtMitPLZstartsWith(Set&lt;Adresse&gt; adressen, int plzStartsWith)</code>. Diese Methode gibt ein <code>Optional</code> zur\u00fcck. Dieses Optional enth\u00e4lt die <code>Stadt</code> aus der Menge <code>adressen</code> mit einer Postleitzahl, die mit <code>plzStartsWith</code> beginnt (z.B. <code>22</code> ist ein passender Beginn f\u00fcr die Postleitzahl <code>22525</code>). Existiert eine solche <code>Stadt</code> in <code>adressen</code> nicht, wird ein leeres <code>Optional</code> zur\u00fcckgegeben. </p> <p>\u2192 siehe <code>testGetStadtMitPLZstartsWith()</code> in <code>Probeklausur3Test</code> (Anzeige <code>getStadtMitPLZstartsWith()</code>)</p> </li> <li> <p>Rufen Sie die <code>getStadtMitPLZstartsWith(Set&lt;Adresse&gt; adressen, int plzStartsWith)</code> in der <code>main</code>-Methode auf. Es wird entweder die im <code>Optional</code> enthaltene Stadt ausgegeben (hier z.B. f\u00fcr <code>22</code>):</p> <pre><code>Hamburg\n</code></pre> <p>oder eine Nachricht der Form <code>Keine Stadt gefunden, deren Postleitzahl mit &lt;plzStartsWith&gt; gefunden.</code>, wobei <code>&lt;plzStartsWith&gt;</code> durch die Zahl ersetzt wird, nach der gesucht wurde (z.B. <code>21</code> oder <code>23</code>).</p> </li> <li> <p>Erstellen Sie ein functional Interface <code>Filterable</code> mit der Methode <code>filter(Adresse adresse)</code>. Diese Methode gibt ein <code>boolean</code> zur\u00fcck. Entfernen Sie nach Erstellung des Interfaces die Kommentare um die Methode <code>filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter)</code>.</p> </li> <li> <p>Erzeugen Sie in der <code>main</code>-Methode einen Lambda-Ausdruck vom Typ <code>Filterable</code>, der f\u00fcr eine gegebene <code>Adresse</code> pr\u00fcft, ob die in <code>Adresse</code> enthaltene <code>Stadt</code> <code>\"Berlin\"</code> ist. Rufen Sie die Methode <code>filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter)</code> und geben Sie die zur\u00fcckgegebene Liste aus (Zufallswerte):</p> <pre><code>------ Filterable und filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter) ------\n\nSonnenblumenweg 1     in 10318 Berlin   \nSternenstaubgasse 8   in 10318 Berlin   \nKirschbl\u00fctenallee 5   in 12167 Berlin   \nKirschbl\u00fctenallee 7   in 13187 Berlin   \nKirschbl\u00fctenallee 6   in 12555 Berlin   \n</code></pre> </li> <li> <p>Erstellen Sie aus der Menge <code>adressen</code> eine Liste aller St\u00e4dte. Die Liste soll aufsteigend nach den Stadtnamen sortiert sein und keine Stadt darf doppelt vorkommen. Geben Sie die Liste aus:</p> <pre><code>------ Liste aller Staedte (keine Doppelungen) aus adressen alphabetisch sortiert ------\n\nBerlin\nHamburg\nK\u00f6ln\nM\u00fcnchen\nStuttgart\n</code></pre> </li> <li> <p>Erstellen Sie aus der Menge <code>adressen</code> eine Liste aller Strassen und Hausnummern. Die Liste soll absteigend nach den Stra\u00dfennamen sortiert sein. Bei gleichen Stra\u00dfennamen h\u00f6here Hausnummer zuerst. Geben Sie die Liste aus:</p> <pre><code>------ Liste aller Strassen + Hausnummer aus adressen alphabetisch absteigend sortiert ------\n\nWaldlichtungstra\u00dfe 8\nWaldlichtungstra\u00dfe 6\nWaldlichtungstra\u00dfe 2\nSternenstaubgasse 8\nSonnenblumenweg 10\nSonnenblumenweg 4\nSonnenblumenweg 1\nRegenbogenpromenade 6\nRegenbogenpromenade 2\nMondscheinpfad 10\nMondscheinpfad 6\nLavendelweg 10\nLavendelweg 1\nKirschbl\u00fctenallee 7\nKirschbl\u00fctenallee 6\nKirschbl\u00fctenallee 5\nGl\u00fcckskleeallee 6\nGl\u00fcckskleeallee 3\nGl\u00fcckskleeallee 1\n</code></pre> <p>Tipp: Sortieren Sie zun\u00e4chst nach Stra\u00dfennamen (und evtl. Hausnummer) und bilden dann aus Stra\u00dfennamen und Hausnummer einen String, den Sie in der Liste speichern.</p> <p>Punkte</p> Aufgabe Punkte \u00a03. <code>createMapIndexedByCity()</code> \u00a03 Punkte \u00a04. Ausgabe unsortiert \u00a03 Punkte \u00a05. Ausgabe sortiert \u00a04 Punkte \u00a06. <code>createMapIndexedByCitySetOfPLZ()</code> \u00a04 Punkte \u00a07. Ausgabe \u00a03 Punkte \u00a08. <code>createMapStreetsMultiple()</code> \u00a04 Punkte \u00a09. Ausgabe \u00a02 Punkte \u00a010. <code>getStadtMitPLZ()</code> \u00a03 Punkte \u00a011. Aufruf und Ausgabe \u00a03 Punkte \u00a012. 2 JUnit-Tests \u00a05 Punkte \u00a013. <code>getStadtMitPLZstartsWith()</code> \u00a03 Punkte \u00a014. Aufruf und Ausgabe \u00a02 Punkte \u00a015. Filterable \u00a02 Punkte \u00a016. Aufruf und Ausgabe \u00a04 Punkte \u00a017. Liste St\u00e4dte sortiert \u00a02 Punkte \u00a018. Liste Stra\u00dfen+Nr sortiert \u00a04 Punkte \u00a0korrektes Programm \u00a04 Punkte gesamt 55 Punkte </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr Probeklausur3 Probeklausur3.javaFilterable.javaProbeklausur3Test.java <pre><code>package probeklausuren.probeklausur3;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Probeklausur3\n{\n    static Random r = new Random();\n\n    // Hilfsmethode - bleibt unveraendert (koenen Sie zuklappen)\n    private static Adresse createAdresse()\n    {\n        String[] strassen = {\"Sonnenblumenweg\", \"Waldlichtungstra\u00dfe\", \"Mondscheinpfad\",\n                \"Gl\u00fcckskleeallee\", \"Regenbogenpromenade\", \"Sternenstaubgasse\",\n                \"Kastanienhain\", \"Lavendelweg\", \"Wasserfallgasse\", \"Kirschbl\u00fctenallee\"};\n        String[] staedte = {\"Berlin\", \"Hamburg\", \"M\u00fcnchen\", \"K\u00f6ln\", \"Stuttgart\"};\n        Map&lt;String, List&lt;Integer&gt;&gt; postleitzahlen = Map.of(\n                \"Berlin\", List.of(13187, 10245, 10437, 10318, 12167, 12555),\n                \"Hamburg\", List.of(22525, 20359),\n                \"M\u00fcnchen\", List.of(80939, 81547, 80802),\n                \"K\u00f6ln\", List.of(50933, 50697, 50667),\n                \"Stuttgart\", List.of(70372)\n        );\n        short nr = (short)(r.nextInt(10) + 1);\n        String strasse = strassen[r.nextInt(strassen.length)];\n        String stadt = staedte[r.nextInt(staedte.length)];\n        var values = postleitzahlen.get(stadt);\n        int plz = values.get(r.nextInt(values.size()));\n        return new Adresse(stadt, plz, strasse, nr);\n    }\n\n    // Hilfsmethode - bleibt unveraendert (koenen Sie zuklappen)\n    public static Set&lt;Adresse&gt; createSetOfAdressen(int numberOfAdressen)\n    {\n        Set&lt;Adresse&gt; adressen = new HashSet&lt;&gt;();\n        for(int i = 0; i &lt; numberOfAdressen; i++)\n        {\n            adressen.add(createAdresse());\n        }\n        return adressen;\n    }\n\n    /*  TODO 3:\n     *  Map erzeugen,\n     *  Schluessel sind die Staedte aus adressen\n     *  Werte sind Listen aus adressen mit der entsprechenden Stadt\n     */\n    public static Map&lt;String, List&lt;Adresse&gt;&gt; createMapIndexedByCity(Set&lt;Adresse&gt; adressen)\n    {\n        return adressen.stream().collect(Collectors.groupingBy(a -&gt; a.stadt()));\n    }\n\n    /*  TODO 6:\n     *  Map erzeugen,\n     *  Schluessel sind die Staedte aus adressen\n     *  Werte sind Mengen aus den postleitzahlen der entsprechenden Stadt\n     */\n    public static Map&lt;String, Set&lt;Integer&gt;&gt; createMapIndexedByCitySetOfPLZ(Set&lt;Adresse&gt; adressen)\n    {\n        Map&lt;String, List&lt;Adresse&gt;&gt; mapIndexByCity = createMapIndexedByCity(adressen);\n        Map&lt;String, Set&lt;Integer&gt;&gt; mapSetPLZ = new HashMap&lt;&gt;();\n        for(Map.Entry&lt;String, List&lt;Adresse&gt;&gt; entry : mapIndexByCity.entrySet())\n        {\n            String stadt = entry.getKey();\n            List&lt;Adresse&gt; adressenList = entry.getValue();\n            Set&lt;Integer&gt; plzSet = adressenList.stream().map(a -&gt; a.plz()).collect(Collectors.toSet());\n            mapSetPLZ.put(stadt, plzSet);\n        }\n        return mapSetPLZ;\n    }\n\n    /*  TODO 8:\n     *  Map erzeugen,\n     *  Schluessel sind die Strassen, die in adressen in MEHREREN Staedten vorkommen\n     *  Werte sind Liste der Staedte mit den entsprechenden Strassen\n     */\n    public static Map&lt;String, List&lt;String&gt;&gt; createMapStreetsMultiple(Set&lt;Adresse&gt; adressen)\n    {\n        Map&lt;String, List&lt;Adresse&gt;&gt; strasseMitStaedten = adressen.stream().collect(Collectors.groupingBy(a -&gt; a.strasse()));\n        Map&lt;String, List&lt;String&gt;&gt; strasseMitStreetsMultiple = new HashMap&lt;&gt;();\n        for(Map.Entry&lt;String, List&lt;Adresse&gt;&gt; entry : strasseMitStaedten.entrySet())\n        {\n            String strasse = entry.getKey();\n            List&lt;Adresse&gt; adressenList = entry.getValue();\n            Set&lt;String&gt; adressenSet = adressenList.stream().map(a -&gt; a.stadt()).collect(Collectors.toSet());\n            if(adressenSet.size() &gt; 1)\n            {\n                List&lt;String&gt; staedteList = adressenSet.stream().collect(Collectors.toList());\n                strasseMitStreetsMultiple.put(strasse, staedteList);\n            }\n        }\n        return strasseMitStreetsMultiple;\n    }\n\n    /*  TODO 10:\n     *  Stadt mit plz aus adressen suchen,\n     *  wenn Stadt mit plz existiert, dann Stadt zurueckgeben\n     *  wenn Stadt mit plz nicht existiert, dann IllegalArgumentException werfen\n     */\n    public static String getStadtMitPLZ(Set&lt;Adresse&gt; adressen, int plz) throws IllegalArgumentException\n    {\n        for(Adresse adresse : adressen)\n        {\n            if(adresse.plz() == plz) return adresse.stadt();\n        }\n        throw new IllegalArgumentException(\"Keine Stadt mit Postleitzahl \" + plz + \" gefunden.\");\n    }\n\n\n    /*  TODO 13:\n     *  Stadt mit plzStartsWith aus adressen suchen,\n     *  plzStartsWith ist der Beginn einer Postleitzahl, z.B. 22\n     *  wenn Stadt mit plzStartsWith existiert, dann Stadt im Optional zurueckgeben\n     *  wenn Stadt mit plzStartsWith nicht existiert, dann leeres Optional zurueckgeben\n     */\n    public static Optional&lt;String&gt; getStadtMitPLZstartsWith(Set&lt;Adresse&gt; adressen, int plzStartsWith)\n    {\n        for(Adresse adresse : adressen)\n        {\n            String adressePLZ = adresse.plz() + \"\";\n            String substringSearchPLZ = plzStartsWith + \"\";\n            if(adressePLZ.startsWith(substringSearchPLZ)) return Optional.of(adresse.stadt());\n        }\n        return Optional.empty();\n    }\n\n    /*\n     *  folgende Methode auskommentieren, nachdem Sie Interface Filterable erstellt haben\n     */\n    public static List&lt;Adresse&gt; filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter) {\n        return adressen.stream()\n                .filter(filter::filter)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args)\n    {\n        // --------------- Vorbereitung - bleibt so ----------\n        Set&lt;Adresse&gt; adressen = createSetOfAdressen(20);\n        System.out.printf(\"%n%n--------------- adressen set---------------------%n%n\");\n        adressen.forEach(System.out::println);\n        int i = 1;\n        for(Adresse adresse : adressen)\n        {\n            System.out.println(\"a\"+i+\"= new Adresse(\\\"\"+adresse.stadt()+\"\\\",\"+adresse.plz()+\",\\\"\"\n                    +adresse.strasse()+\"\\\",(short)\"+adresse.hausnummer()+\");\");\n            i++;\n        }\n\n        System.out.printf(\"%n%n--------------- createMapIndexedByCity(Set&lt;Adresse&gt; adressen) ---------------------%n%n\");\n        // TODO siehe 4.\n        Map&lt;String, List&lt;Adresse&gt;&gt; mapCity = createMapIndexedByCity(adressen);\n        for(Map.Entry&lt;String, List&lt;Adresse&gt;&gt; entry : mapCity.entrySet())\n        {\n            System.out.println(\"Stadt : \" + entry.getKey());\n            System.out.println(\"---------------------\");\n            for(Adresse adresse : entry.getValue())\n            {\n                System.out.println(adresse.strasse() + \" \" + adresse.hausnummer());\n            }\n            System.out.println(\"---------------------\");\n            System.out.println();\n        }\n\n        System.out.printf(\"%n%n----------- createMapIndexedByCity(Set&lt;Adresse&gt; adressen) sortiert ------------------%n%n\");\n        // TODO siehe 5.\n        List&lt;String&gt; staedteSetSortiert = mapCity.keySet().stream().sorted().collect(Collectors.toList());\n\n        for(String stadt : staedteSetSortiert)\n        {\n            System.out.println(\"Stadt : \" + stadt);\n            System.out.println(\"---------------------\");\n            List&lt;Adresse&gt; adresseList = mapCity.get(stadt);\n            List&lt;Adresse&gt; adresseListSorted = adresseList.stream()\n                    .sorted((a,b) -&gt; a.strasse().compareTo(b.strasse()) != 0 ? a.strasse().compareTo(b.strasse()) : a.hausnummer() - b.hausnummer())\n                    .collect(Collectors.toList());\n            for(Adresse adresse : adresseListSorted)\n            {\n                System.out.println(adresse.strasse() + \" \" + adresse.hausnummer());\n            }\n            System.out.println(\"---------------------\");\n            System.out.println();\n        }\n\n        System.out.printf(\"%n%n----------- createMapIndexedByCitySetOfPLZ(Set&lt;Adresse&gt; adressen) ------------------%n%n\");\n        // TODO siehe 7.\n        Map&lt;String, Set&lt;Integer&gt;&gt; mapSetPLZ = createMapIndexedByCitySetOfPLZ(adressen);\n        for(Map.Entry&lt;String, Set&lt;Integer&gt;&gt; entry : mapSetPLZ.entrySet())\n        {\n            System.out.printf(\"%-10s : [ \" , entry.getKey());\n            for(Integer plz : entry.getValue())\n            {\n                System.out.print(plz + \" \");\n            }\n            System.out.println(\"]\");\n        }\n\n        System.out.printf(\"%n%n-------------- createMapStreetsMultiple(Set&lt;Adresse&gt; adressen) ---------------------%n%n\");\n        // TODO siehe 9.\n        Map&lt;String, List&lt;String&gt;&gt; mapMultipleStreets = createMapStreetsMultiple(adressen);\n        for(Map.Entry&lt;String, List&lt;String&gt;&gt; entry : mapMultipleStreets.entrySet())\n        {\n            System.out.printf(\"%-20s : [ \" , entry.getKey());\n            for(String stadt : entry.getValue())\n            {\n                System.out.print(stadt + \" \");\n            }\n            System.out.println(\"]\");\n        }\n\n        System.out.printf(\"%n%n--------------- getStadtMitPLZ(Set&lt;Adresse&gt; adressen, int plz) ---------------------%n%n\");\n        // TODO siehe 11.\n        try {\n            String stadtMitPLZ = getStadtMitPLZ(adressen, 22526);\n            System.out.println(stadtMitPLZ);\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n\n        System.out.printf(\"%n%n---------- getStadtMitPLZstartsWith(Set&lt;Adresse&gt; adressen, int plzStartsWith) -------------%n%n\");\n        // TODO siehe 14.\n        for(int plzStartsWith = 21; plzStartsWith &lt; 24; plzStartsWith++) {\n            Optional&lt;String&gt; stadtBeginntMitPLZ = getStadtMitPLZstartsWith(adressen, plzStartsWith);\n            if (stadtBeginntMitPLZ.isPresent()) {\n                System.out.println(stadtBeginntMitPLZ.get());\n            }\n            else {\n                System.out.println(\"Keine Stadt gefunden, deren Postleitzahl mit \" + plzStartsWith + \" gefunden.\");\n            }\n        }\n\n        System.out.printf(\"%n%n------ Filterable und filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter) ------%n%n\");\n        // TODO siehe 15 und 16.\n        // vorher Kommentare von Methode filterAdressen(Set&lt;Adresse&gt; adressen, Filterable filter) entfernen!\n        Filterable berlinFilter = adresse -&gt; \"Berlin\".equals(adresse.stadt());\n        List&lt;Adresse&gt; berlinAdressen = filterAdressen(adressen, berlinFilter);\n        berlinAdressen.forEach(adresse -&gt; System.out.println(adresse));\n\n        System.out.printf(\"%n%n------ Liste aller Staedte (keine Doppelungen) aus adressen alphabetisch sortiert ------%n%n\");\n        // TODO siehe 17.\n        List&lt;String&gt; staedteSortiert = adressen.stream().map(a -&gt; a.stadt()).sorted().distinct().collect(Collectors.toList());\n        staedteSortiert.forEach(System.out::println);\n\n        System.out.printf(\"%n%n------ Liste aller Strassen + Hausnummer aus adressen alphabetisch absteigend sortiert ------%n%n\");\n        // TODO siehe 18.\n        List&lt;String&gt; strassenSortiert = adressen.stream()\n                .sorted((a,b) -&gt; b.strasse().compareTo(a.strasse()) != 0 ? b.strasse().compareTo(a.strasse()) : b.hausnummer() - a.hausnummer())\n                .map(a -&gt; a.strasse() + \" \" + a.hausnummer()).distinct().collect(Collectors.toList());\n        strassenSortiert.forEach(System.out::println);\n    }\n}\n</code></pre> <pre><code>package probeklausuren.probeklausur3;\n\n@FunctionalInterface\npublic interface Filterable\n{\n    boolean filter(Adresse adresse);\n}\n</code></pre> <pre><code>package probeklausuren.probeklausur3;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Probeklausur3Test\n{\n    static Adresse a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n    static Set&lt;Adresse&gt; adressen;\n\n    @BeforeAll\n    public static void setUp()\n    {\n        a1= new Adresse(\"K\u00f6ln\",50667,\"Waldlichtungstra\u00dfe\",(short)10);\n        a2= new Adresse(\"M\u00fcnchen\",80939,\"Lavendelweg\",(short)1);\n        a3= new Adresse(\"Hamburg\",20359,\"Sternenstaubgasse\",(short)7);\n        a4= new Adresse(\"K\u00f6ln\",50697,\"Sonnenblumenweg\",(short)6);\n        a5= new Adresse(\"K\u00f6ln\",50697,\"Kastanienhain\",(short)1);\n        a6= new Adresse(\"M\u00fcnchen\",81547,\"Wasserfallgasse\",(short)6);\n        a7= new Adresse(\"M\u00fcnchen\",80939,\"Gl\u00fcckskleeallee\",(short)1);\n        a8= new Adresse(\"K\u00f6ln\",50697,\"Sternenstaubgasse\",(short)10);\n        a9= new Adresse(\"Hamburg\",22525,\"Kirschbl\u00fctenallee\",(short)6);\n        a10= new Adresse(\"K\u00f6ln\",50667,\"Lavendelweg\",(short)7);\n        a11= new Adresse(\"Stuttgart\",70372,\"Sternenstaubgasse\",(short)4);\n        a12= new Adresse(\"Berlin\",12167,\"Regenbogenpromenade\",(short)4);\n        a13= new Adresse(\"Hamburg\",22525,\"Regenbogenpromenade\",(short)2);\n        a14= new Adresse(\"Hamburg\",20359,\"Kirschbl\u00fctenallee\",(short)5);\n        a15= new Adresse(\"Berlin\",12555,\"Kirschbl\u00fctenallee\",(short)6);\n        a16= new Adresse(\"Berlin\",10437,\"Kirschbl\u00fctenallee\",(short)10);\n        a17= new Adresse(\"M\u00fcnchen\",80939,\"Waldlichtungstra\u00dfe\",(short)5);\n        a18= new Adresse(\"K\u00f6ln\",50933,\"Sonnenblumenweg\",(short)6);\n        a19= new Adresse(\"Berlin\",12555,\"Regenbogenpromenade\",(short)4);\n        a20= new Adresse(\"M\u00fcnchen\",81547,\"Mondscheinpfad\",(short)1);\n\n        Adresse[] arr_adressen = {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20};\n\n        adressen = new HashSet&lt;Adresse&gt;();\n        for(Adresse adresse : arr_adressen) adressen.add(adresse);\n    }\n\n    private static boolean addressSetsAreIdentical(Set&lt;Adresse&gt; set1, Set&lt;Adresse&gt; set2)\n    {\n        if (set1.size() != set2.size()) return false;\n        for(Adresse adresse : set1)\n        {\n            if(!set2.contains(adresse)) return false;\n        }\n        for(Adresse adresse : set2)\n        {\n            if(!set1.contains(adresse)) return false;\n        }\n        return true;\n    }\n\n    private static boolean stringSetsAreIdentical(Set&lt;String&gt; set1, Set&lt;String&gt; set2)\n    {\n        if (set1.size() != set2.size()) return false;\n        for(String word : set1)\n        {\n            if(!set2.contains(word)) return false;\n        }\n        for(String word : set2)\n        {\n            if(!set1.contains(word)) return false;\n        }\n        return true;\n    }\n\n    private static boolean integerSetsAreIdentical(Set&lt;Integer&gt; set1, Set&lt;Integer&gt; set2)\n    {\n        if (set1.size() != set2.size()) return false;\n        for(Integer number : set1)\n        {\n            if(!set2.contains(number)) return false;\n        }\n        for(Integer number : set2)\n        {\n            if(!set1.contains(number)) return false;\n        }\n        return true;\n    }\n\n    private static boolean addressListsAreIdentical(List&lt;Adresse&gt; list1, List&lt;Adresse&gt; list2)\n    {\n        if (list1.size() != list2.size()) return false;\n        for(Adresse adresse : list1)\n        {\n            if(!list2.contains(adresse)) return false;\n        }\n        for(Adresse adresse : list2)\n        {\n            if(!list1.contains(adresse)) return false;\n        }\n        return true;\n    }\n\n    private static boolean stringListsAreIdentical(List&lt;String&gt; list1, List&lt;String&gt; list2)\n    {\n        if (list1.size() != list2.size()) return false;\n        for(String word : list1)\n        {\n            if(!list2.contains(word)) return false;\n        }\n        for(String word : list2)\n        {\n            if(!list1.contains(word)) return false;\n        }\n        return true;\n    }\n\n\n    @Test\n    @DisplayName(\"createMapIndexedByCity()\")\n    public void testCreateMapIndexedByCity()\n    {\n        //given\n        Map&lt;String, List&lt;Adresse&gt;&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(\"Berlin\", List.of(a12,a15,a16,a19));\n        map1.put(\"K\u00f6ln\", List.of(a1,a4,a5,a8,a10,a18));\n        map1.put(\"Hamburg\", List.of(a3,a9,a13,a14));\n        map1.put(\"M\u00fcnchen\", List.of(a2,a6,a7,a17,a20));\n        map1.put(\"Stuttgart\", List.of(a11));\n\n        //when\n        Map&lt;String, List&lt;Adresse&gt;&gt; map2 = Probeklausur3.createMapIndexedByCity(adressen);\n\n        //then\n        assertTrue(stringSetsAreIdentical(map1.keySet(), map2.keySet()), \"key set seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"Berlin\"), map2.get(\"Berlin\")), \"address list for Berlin seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"K\u00f6ln\"), map2.get(\"K\u00f6ln\")), \"address list for K\u00f6ln seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"Hamburg\"), map2.get(\"Hamburg\")), \"address list for Hamburg seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"M\u00fcnchen\"), map2.get(\"M\u00fcnchen\")), \"address list for M\u00fcnchen seems to be wrong\");\n        assertTrue(addressListsAreIdentical(map1.get(\"Stuttgart\"), map2.get(\"Stuttgart\")), \"address list for Stuttgart seems to be wrong\");\n    }\n\n    @Test\n    @DisplayName(\"createMapIndexedByCitySetOfPLZ()\")\n    public void testCreateMapIndexedByCitySetOfPLZ()\n    {\n        //given\n        Map&lt;String, Set&lt;Integer&gt;&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(\"Berlin\", Set.of(12167,12555,10437));\n        map1.put(\"K\u00f6ln\", Set.of(50667,50697,50933));\n        map1.put(\"Hamburg\", Set.of(20359,22525));\n        map1.put(\"M\u00fcnchen\", Set.of(80939,81547));\n        map1.put(\"Stuttgart\", Set.of(70372));\n\n        //when\n        Map&lt;String, Set&lt;Integer&gt;&gt; map2 = Probeklausur3.createMapIndexedByCitySetOfPLZ(adressen);\n\n        //then\n        assertTrue(stringSetsAreIdentical(map1.keySet(), map2.keySet()), \"key set seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"Berlin\"), map2.get(\"Berlin\")), \"plz set for Berlin seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"K\u00f6ln\"), map2.get(\"K\u00f6ln\")), \"plz set for K\u00f6ln seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"Hamburg\"), map2.get(\"Hamburg\")), \"plz set for Hamburg seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"M\u00fcnchen\"), map2.get(\"M\u00fcnchen\")), \"plz set for M\u00fcnchen seems to be wrong\");\n        assertTrue(integerSetsAreIdentical(map1.get(\"Stuttgart\"), map2.get(\"Stuttgart\")), \"plz set for Stuttgart seems to be wrong\");\n    }\n\n    @Test\n    @DisplayName(\"createMapStreetsMultiple()\")\n    public void testCreateMapStreetsMultiple()\n    {\n        //given\n        Map&lt;String, List&lt;String&gt;&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(\"Waldlichtungstra\u00dfe\", List.of(\"K\u00f6ln\",\"M\u00fcnchen\"));\n        map1.put(\"Sternenstaubgasse\", List.of(\"K\u00f6ln\",\"Hamburg\",\"Stuttgart\"));\n        map1.put(\"Lavendelweg\", List.of(\"K\u00f6ln\",\"M\u00fcnchen\"));\n        map1.put(\"Kirschbl\u00fctenallee\", List.of(\"Hamburg\",\"Berlin\"));\n        map1.put(\"Regenbogenpromenade\", List.of(\"Hamburg\",\"Berlin\"));\n\n        //when\n        Map&lt;String, List&lt;String&gt;&gt; map2 = Probeklausur3.createMapStreetsMultiple(adressen);\n\n        //then\n        assertTrue(stringSetsAreIdentical(map1.keySet(), map2.keySet()), \"key set seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Waldlichtungstra\u00dfe\"), map2.get(\"Waldlichtungstra\u00dfe\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Sternenstaubgasse\"), map2.get(\"Sternenstaubgasse\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Lavendelweg\"), map2.get(\"Lavendelweg\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Kirschbl\u00fctenallee\"), map2.get(\"Kirschbl\u00fctenallee\")), \"createMapStreetsMultiple seems to be wrong\");\n        assertTrue(stringListsAreIdentical(map1.get(\"Regenbogenpromenade\"), map2.get(\"Regenbogenpromenade\")), \"createMapStreetsMultiple seems to be wrong\");\n    }\n\n    @Test\n    @DisplayName(\"getStadtMitPLZstartsWith()\")\n    public void testGetStadtMitPLZstartsWith()\n    {\n        //given\n        int plzStartsWith1 = 22;\n        int plzStartsWith2 = 23;\n\n        //when\n        Optional&lt;String&gt; result1 = Probeklausur3.getStadtMitPLZstartsWith(adressen, plzStartsWith1);\n        Optional&lt;String&gt; result2 = Probeklausur3.getStadtMitPLZstartsWith(adressen, plzStartsWith2);\n        assertEquals(result2.get(), \"Hamburg\", \"getStadtMitPLZstartsWith() doesn't seem to work properly yet\");\n        assertTrue(result1.isEmpty(),\"getStadtMitPLZstartsWith() doesn't seem to work properly yet\");\n    }\n\n    /*\n     * Schreiben Sie hinter diesem Kommentar Ihre beiden Testfaelle fuer 12.\n     */\n\n    @Test\n    @DisplayName(\"getStadtMitPLZ()\")\n    public void testGetStadtMitPLZ()\n    {\n        //given\n        int plz = 22525;\n\n        //when\n        String stadt = Probeklausur3.getStadtMitPLZ(adressen, plz);\n\n        //then\n        String expected = \"Hamburg\";\n        assertTrue(stadt.equals(expected), \"getStadtMitPLZ doesn't seem to work properly yet\");\n    }\n\n    @Test\n    @DisplayName(\"getStadtMitPLZException\")\n    public void testGetStadtMitPLZException()\n    {\n        //given\n        int plz = 22526;\n\n        //then\n        Exception exception = assertThrows(IllegalArgumentException.class, () -&gt; Klausur.getStadtMitPLZ(adressen, plz));\n        assertEquals(\"Keine Stadt mit Postleitzahl \" + plz + \" gefunden.\", exception.getMessage(), \"getStadtMitPLZException doesn't seem to work properly yet\");\n    }\n}\n</code></pre>"},{"location":"wiederholung/","title":"Wiederholung","text":""},{"location":"wiederholung/#datentypen","title":"Datentypen","text":""},{"location":"wiederholung/#wertetypen","title":"Wertetypen","text":"<ul> <li>es wird der konkrete Wert in der Variablen gespeichert\u000b</li> <li>belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche</li> </ul> Beispiele Wertetypen <pre><code>// boolean f\u00fcr Wahrheitswerte true und false\nboolean x = false;          // mit false initialisiert\nboolean wahr = true;        // Schluesselwort true\nboolean falsch = !wahr;     // Enthaelt den Wert false\n\n// byte, short, int, long f\u00fcr ganze Zahlen\nbyte a = 0;         // mit 0 initialisiert\nshort b = 124;      // Zuweisung einer ganzen Zahl\nint c = a + b;      // Wertebereich immer beachten!\nlong lo = c * 200;  // l nicht als Variablenname verwenden\n\n// char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen!\nchar zeichen = 'c';     // Doppelte \" f\u00fcr Strings!\u00a0\n\n// float und double f\u00fcr Flie\u00dfkommazahlen\nfloat f = 0.0f;         // Wird mit 0.0 initialisiert\ndouble d = 100.25;      // Dezimalpunkt statt Dezimalkomma!!\n</code></pre>"},{"location":"wiederholung/#referenztypen","title":"Referenztypen","text":"<ul> <li>es wird eine Referenz auf ein Objekt gespeichert\u000b</li> <li>Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand)</li> <li>Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator</li> </ul> Beispiele Referenztypen <pre><code>// Schluesselwort class um neue Klasse (Typ) zu definieren\npublic class Power \n{\n    int base; // Objektvariablen, f\u00fcr jedes Objekt\n    int exp;  // existieren Kopien im Arbeitsspeicher\n\n    public Power(int base, int exp)\n    {\n        this.base = base;\n        this.exp = exp;\n    }\n\n    // Objektmethode\n    public void print()\n    {\n        System.out.println(this.base + \"^\" + this.exp);\n    }\n}\n\n// irgendwo im Hauptprogramm\npublic static void main(String[] args)\u00a0\n{\n    Power p1 = new Power(2,4);\n    Power p2 = new Power(2,4);\n    p1.print();\n    p2.print();\n    boolean equal = (p1 == p2);     // true oder false ?\n}\n</code></pre>"},{"location":"wiederholung/#datenstrukturen","title":"Datenstrukturen","text":""},{"location":"wiederholung/#variablen","title":"Variablen","text":"<ul> <li>einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein)</li> <li>sind von einem Datentyp (Wertetyp oder Referenztyp)</li> <li>haben einen Namen</li> <li>besitzen einen Wert<ul> <li>Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =)</li> <li>Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final)</li> </ul> </li> <li>besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope)<ul> <li>Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde</li> <li>lokale Variable: in einer Methode deklariert \u2192 dort lokal</li> <li>globale Variable: in einer Klasse deklariert \u2192 dort global</li> </ul> </li> </ul> Beispiele Variablen <pre><code>int zahlen = 0;             // konventionelle Variable\nfinal float PI = 3.14516f;  // Konstante\n\n// Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz\nint[] zahlenFeld = new int[100];\n\n// Klassen mit Objekt- und Klassenvariablen\npublic class Power \n{\n    int base; // Objektvariablen, f\u00fcr jedes Objekt\n    int exp;  // existieren Kopien im Arbeitsspeicher\n\n    public Power(int base, int exp)\n    {\n        this.base = base;\n        this.exp = exp;\n    }\n\n    public String toString()\n    {\n        // lokale Variable --&gt; nur in der Methode gueltig\n        String output =\u00a0 this.base + \"^\" + this.exp;\n        return output;\n    }\n\n    // Variablen sollten mit einem Kleinbuchstaben beginnen\n    // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden\n}\n</code></pre>"},{"location":"wiederholung/#arrays","title":"Arrays","text":"<ul> <li>Arrays sind Objekte (Referenztypen)</li> <li>speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein)</li> <li>besitzen Methoden (z.B. <code>sort()</code>) und Variablen (z.B. <code>length</code>)</li> <li>k\u00f6nnen auch mehrdimensional sein</li> <li>Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes</li> </ul> Beispiele Arrays <pre><code>// Einfache Deklaration -&gt; nur Datentyp bekannt, keine Laenge\nint[] zahlen;           // Eckige Klammern f\u00fcr Array-Datentyp\n\n// Erzeugen eines neuen Feldes und Zuweisen der Referenz\nzahlen = new int[100];  // new-Operator, hier: Angabe der Laenge\n\n// Explizite Initialisierung bei der Deklaration\n// Bei Initialisiert mit Werten --&gt; keine Laengenangabe noetig\nfloat[] werte = new float[10];      // Platz f\u00fcr 10 Werte \ndouble[] fib = { 1.0, 2.0, 3.0 };   // Werte in {}-Klammern\n\n// Mehrdimensionale Felder\nint[][] hdBild = new int[1920][1080];\n\n// Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden\nPower[] potenzen = new Power[5];    // Noch keine Objekte enthalten\npotenzen[0] = new Power(2, 4);      // Zuweisung Objekt an Index 0\n</code></pre>"},{"location":"wiederholung/#literale","title":"Literale","text":"<ul> <li>sind Werte</li> <li>sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein)</li> <li>keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen</li> <li>meistens <ul> <li>auf der rechten Seite einer Wertzuweisung</li> <li>als Parameterwert bei Aufruf einer Methode</li> <li>als Vergleichswert bei logischen Ausdr\u00fccken</li> </ul> </li> </ul> Beispiele Literale <pre><code>100\ntrue\n'a'\n\"hallo\"\n{1,2,3,4}\n5.5\n</code></pre>"},{"location":"wiederholung/#ausdrucke","title":"Ausdr\u00fccke","text":"<ul> <li>kleinste ausf\u00fchrbare Einheit eines Programms</li> <li> <p>z.B.:</p> <ul> <li>Zuweisung</li> <li>numerische Berechnung</li> <li>logische Bedingung</li> </ul> </li> <li> <p>Operatoren:</p> <ul> <li>arithmetisch:     <code>+, -, *, /, %, ++, --</code></li> <li>relational:       <code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code></li> <li>logisch:          <code>!, &amp;&amp;, ||</code></li> <li>Zuweisung:        <code>=, +=, -=, *=, /=, %=</code></li> <li>sonstige:         <code>a?b:c, typecast, new, instanceof, .</code></li> </ul> </li> </ul>"},{"location":"wiederholung/#anweisungen","title":"Anweisungen","text":"<ul> <li>Einzelanweisung       <code>;</code></li> <li>Block                 <code>{}</code></li> <li>Deklaration           <code>Typ Methode</code>, <code>Typ Variable</code></li> <li>Ausdruck</li> <li>Bedingung             <code>if() else  switch() case</code></li> <li>Schleifen             <code>for        while       do while</code></li> <li>Exceptions            <code>try catch()</code></li> <li>Assertions            <code>assert</code></li> </ul> Beispiele Anweisungen <pre><code>// Bloecke immer zwischen geschweiften Klammern\n{\n// Anweisung 1...\n// Anweisung 2...\n}\n\n// Definition und Deklaration\nint a;\nfloat b = 1.0f;\n\n// Einfacher Ausdruck\na = 1010;\u00a0\n\n// Bedingungen\nif (a == 1010)\u00a0         // if-Zweig muss immer vorhanden sein\n{\n    // Anweisungen...\n}\nelse if (a == 1011)\u00a0    // 0 - beliebig viele else-if-Zweige\n{\n    // Anweisungen...\n}\nelse\u00a0           // 0 - 1 else-Zweig\n{\n    // Anweisungen...\n}\n\nswitch (a)      // zu pruefende Variable in Klammern\n{\n    case 1010: { b*=2.0; break; }   // beliebig viele case-Zweige\n    case 1011: { b*=3.0; break; }   // break nicht vergessen\n    default: { b=0.0f; }            // Zweig f\u00fcr alle anderen Werte\n}\n\nint[] meinFeld = {1,2,3,4,5};\n// for-Schleife\n// 1. Initialisierung\n// 2. Schleifen-Bedingung\n// 3. Anweisungen nach Schleifendurchlauf\n// Schleifen-Anweisungen als Block hinter for\nfor (int index = 0; index &lt; meinFeld.length; index++) \n{\n    System.out.println(meinFeld[index]);\n}\n\n// while-Schleife\n// Nur Schleifen-Bedingung angeben\n// Auf Endlos-Schleifen achten\nwhile (index &lt; meinFeld.length) \n{\u00a0\n    System.out.println(meinFeld[index]);\n    index++;\n}\n</code></pre>"},{"location":"wiederholung/#methoden","title":"Methoden","text":"<ul> <li>wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden</li> <li>Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. <code>void</code>)</li> <li>Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden</li> <li>bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum <code>return</code>)</li> <li>werden Methoden mit R\u00fcckgabetyp (also nicht <code>void</code>) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert)</li> </ul> Methodenstack/Call stack <pre><code>public static int multiply(int a, int b) {\n    return a*b;\n}\n\npublic static int square(int n) {\n    return multiply(n,n);\n}\n\npublic static void printSquare(int n) {\nint squared = square(n);\nSystem.out.println(n + \" x \" + n + \" = \"\u00a0+ squared);\n}\n\npublic static void main(String[] args) {\n    printSquare(4);\n}\n</code></pre>"},{"location":"wiederholung/#vererbung","title":"Vererbung","text":"<ul> <li>Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse)</li> <li>Schl\u00fcsselwort <code>extends</code></li> <li>jede Klasse (bis auf <code>Object</code>) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch <code>Object</code></li> <li>Vererbung beschreibt \u201eis-a\u201c-Beziehung</li> <li>Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als <code>final</code> definiert wurden) \u2192 @Override verwenden</li> <li>Originalmethode kann mit Schl\u00fcsselwort <code>super</code> aufgerufen werden</li> </ul>"},{"location":"wiederholung/#konstruktoren","title":"Konstruktoren","text":"<ul> <li>besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden</li> <li>gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht <code>void</code>)</li> <li>wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren)</li> <li>Aufruf von <code>this</code> und <code>super</code> m\u00f6glich</li> <li>werden nicht vererbt</li> </ul> Beispiele Konstruktoren <pre><code>public class Power {\n    int base;\n    int exp;\n\n    public Power()\n    {\n        this(1,0);  // Aufruf des Konstruktors in Zeile 15\n    }\n\n    public Power(int base)\n    {\n        this(base, 0);  // Aufruf des Konstruktors in Zeile 15\n    }\n\n    public Power(int base, int exp)\n    {\n        this.base=base;     // Parameterwerte f\u00fcr base und int\n        this.exp=exp;       // auf Objektvariablen sichern\n    }\n}\n\npublic static void main(String[] args) {\n    Power p1 = new Power();         // p1.base = 1, p1.exp = 0\n    Power p2 = new Power(10);       // p2.base = 10, p2.exp = 0\n    Power p3 = new Power(10,5);     // p3.base = 10, p3.exp = 5\n}\n</code></pre>"},{"location":"wiederholung/#access-controller-zugriffsmodifizierer","title":"Access Controller (Zugriffsmodifizierer)","text":"<ul> <li>Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung</li> <li> <p>Klassen</p> <ul> <li><code>public</code>      Zugriff von au\u00dferhalb des Paketes</li> <li>(default)     Zugriff nur innerhalb des Paketes</li> <li><code>final</code>       von der Klasse k\u00f6nnen keine Klassen erben</li> <li><code>abstract</code>    Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind)</li> </ul> </li> <li> <p>Variablen und Methoden (wenn Klasse <code>public</code>)</p> <ul> <li><code>public</code>      Zugriff von \u00fcberall (bei Variablen vermeiden!)</li> <li><code>protected</code>   Zugriff aus Klasse und Kindklasse</li> <li>(default)     Zugriff aus Klasse und Paket</li> <li><code>private</code>         Zugriff nur aus Klasse </li> </ul> </li> </ul>"},{"location":"wiederholung/#kleinigkeiten-die-wir-fast-nicht-betrachtet-haben","title":"\"Kleinigkeiten\", die wir (fast) nicht betrachtet haben","text":""},{"location":"wiederholung/#das-schlusselwort-static","title":"Das Schl\u00fcsselwort <code>static</code>","text":"<p>Mit dem Schl\u00fcsselwort <code>static</code> beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort <code>static</code> kann verwendet werden f\u00fcr</p> <ul> <li>Die Deklaration einer (Klassen-)Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). </li> <li>Die Deklaration einer (Klassen-)Methode. Eine statische Methode (Klassenmethode) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der <code>main()</code>-Methode) erstellen, um diese in der <code>main()</code>-Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. </li> <li>Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter.</li> </ul> <p>Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen. </p>"},{"location":"wiederholung/#die-for-each-schleife","title":"Die for-each-Schleife","text":"<p>Wir haben ein Array stets so durchlaufen, dass wir in einer <code>for</code>-Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.:</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor (int index = 0; index &lt; args.length; index++) \n{\n    System.out.print(numbers[index]);\n}\n</code></pre> <p>Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen:</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor(int number : numbers)\n{\n    System.out.print(number);\n}\n</code></pre> <p>Wir bezeichnen diese Schleifensyntax auch als for-each-Schleife. Die allgemeine Syntax ist</p> <pre><code>for(TypElement variablenNameElement : nameDesArrays)\n{\n    // hier lesende Verwendung von variablenNameElement\n}\n</code></pre> <p>Beachten Sie, dass Sie mit der for-each-Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor(int number : numbers)\n{\n    number = 5;\n}\n</code></pre> <p>, dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken (Setter). </p>"},{"location":"wiederholung/#die-klasse-javautilarrays","title":"Die Klasse <code>java.util.Arrays</code>","text":"<p>Die Klasse <code>Arrays</code> aus dem <code>java.util</code>-Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die <code>toString()</code>-Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen <code>toString()</code>-Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse <code>Arrays</code> finden Sie z.B. hier. Beachten Sie, dass Sie zum Verwenden der Klasse das <code>java.util</code>-Paket importieren m\u00fcssen. </p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nSystem.out.println(Arrays.toString(numbers));\n</code></pre> <p>Weitere interessante Methoden dieser Klasse sind <code>copyOf()</code>, <code>binarySearch()</code> und <code>sort()</code>. </p> \u00dcbung <p>Ist die <code>toString()</code>-Methode der <code>Arrays</code>-Klasse statisch oder handelt es sich um eine Objektmethode?</p>"},{"location":"wiederholung/#reservierter-typname-var","title":"Reservierter Typname <code>var</code>","text":"<p>Es gibt Programmiersprachen, z.B. JavaScript, in denen wir Variablen nicht mit einem Typ deklarieren, sondern der Typ aus dem Wert der Variablen ermittelt wird. Java ist dagegen eine typsichere Sprache. Seit Java 10 kann aber ein reservierter Typ verwendet werden, der auf lokale Variablen anwendbar ist. Dieser reservierte Typ hei\u00dft <code>var</code>. Es handelt sich dabei gar nicht um ein reserviertes Schl\u00fcsselwort, um bereits existierende Variablennamen <code>var</code> oder (noch schlechter) Methodennamen <code>var</code> nicht in Konflikt geraten zu lassen. M\u00f6gliche Eins\u00e4tze sind wie folgt:</p> <pre><code>int[] intArray = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nfor(var value : intArray)\n{\n    System.out.printf(value + \" \");\n}\nSystem.out.println();\nfor(var index = 0; index &lt; intArray.length; index++)\n{\n    intArray[index] = intArray[index] + 1;      // mit Effekt\n}\n</code></pre> <p>Auch hier wird der eigentliche Typ der Variablen <code>value</code> und <code>index</code> aus dem Kontext ermittelt (beides <code>int</code>). Man spricht von Local Variable Type Interference. Wir werden <code>var</code> sp\u00e4ter bei typisierten Collections h\u00e4ufiger anwenden. Es macht den Code manchmal besser lesbar. Guidelines zur Verwendung von <code>var</code> finden sich z.B. hier. </p>"},{"location":"wiederholung/#textblocke","title":"Textbl\u00f6cke","text":"<p>Wir wissen, dass String-Literale in doppelten Hochkomma gesetzt werden, also z.B. </p> <pre><code>String message = \"Hallo FIW!\";\n</code></pre> <p>Bei l\u00e4ngeren Zeichenketten, die \u00fcber mehrere Zeilen gehen und auch noch Zeichen enthalten, die maskiert werden m\u00fcssen, kann das sehr umst\u00e4ndlich aussehen, z.B.:</p> <pre><code>String source = \"String message = \\\"Hello FIW!\\\";\\n\" +\n        \"System.out.println(message);\\n\";\n</code></pre> <p>Das geht mit Textbl\u00f6cken einfacher:</p> <pre><code>String textblock = \"\"\"\n        String message = \"Hello FIW!\";\n        System.out.println(message);\n        \"\"\";\n</code></pre> <p>Syntaktisch sind die String-Literale alse in dreifache Hochkommata eingeschlossen: <code>\"\"\"</code>. Achten Sie aber darauf, dass nach den \u00f6ffnenden Hochkommata nicht gleich das String-Literal kommt, sondern erst ein Zeilenumbrauch:</p> <pre><code>// Fehler:\nString message = \"\"\"Hallo FIW!\"\"\";\n</code></pre> <pre><code>// korrekt:\nString message = \"\"\"\n    Hallo FIW!\"\"\";\n</code></pre> <pre><code>// auch korrekt:\nString message = \"\"\"\n    Hallo FIW!\n    \"\"\";\n</code></pre> <p>Wichtig ist der Zeilenumbruch nach den ersten drei Hochkommata. Ansonsten k\u00f6nnen Sie Textbl\u00f6cke als ganz normale Strings verwenden, d.h. wir k\u00f6nnen Textbl\u00f6cke mithilfe von <code>+</code> mit anderen String-Literalen verbinden und wir k\u00f6nnen Textbl\u00f6cke als Parameterwerte \u00fcbergeben, wenn Strings erwartet werden.</p> <p>In Textbl\u00f6cken klappt sogar der Einzug gut, d.h. </p> <pre><code>String html = \"\"\"\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;p&gt;Hello FIW!&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\";\nSystem.out.println(html);\n</code></pre> <p>gibt </p> <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;p&gt;Hello FIW!&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>auf der Konsole aus. F\u00fcr weitere Informationen zu Textbl\u00f6cken siehe z.B. hier.</p>"},{"location":"wiederholung/#record-klassen","title":"Record-Klassen","text":"<p>Record-Klassen sind spezielle Java-Klassen, die eine einfache Bildung neuer Datentypen erm\u00f6glichen. Die Grundidee ist, dass man einen Konstruktor angibt, dem als Parameter alle Werte f\u00fcr die Objektvariablen \u00fcbergeben werden. Die <code>Getter</code> (leider ohne <code>get</code> davor), die <code>toString()</code>-, <code>equals()</code>- und <code>hashCode()</code>-Methoden werden implizit definiert. Einen record  definieren wir mithilfe des Schl\u00fcsselwortes <code>record</code>:</p> <pre><code>public record Rectangle(double length, double height){}\n</code></pre> <p>Das ist es schon. Diese Klasse kann nun so verwendet werden, wie wir es kennen, z.B.:</p> <pre><code>Rectangle r1 = new Rectangle(4.0, 8.0);\nRectangle r2 = new Rectangle(4.0, 8.0);\nRectangle r3 = new Rectangle(8.0, 4.0);\nSystem.out.println(r1.toString());\nSystem.out.println(r2.toString());\nSystem.out.println(r3.toString());\nSystem.out.println(\"r1 gleich r2 ? \" + r1.equals(r2));\nSystem.out.println(\"r1 gleich r3 ? \" + r1.equals(r3));\n</code></pre> <p>ergibt folgende Ausgabe:</p> <pre><code>Rectangle[length=4.0, height=8.0]\nRectangle[length=4.0, height=8.0]\nRectangle[length=8.0, height=4.0]\nr1 gleich r2 ? true\nr1 gleich r3 ? false\n</code></pre> <p>Die <code>record</code>-Definition von <code>Rectangle</code> entspricht der folgenden Klassendefinition:</p> <pre><code>public final class Rectangle \n{\n    private final double length;\n    private final double width;\n\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n\n    double length() { return this.length; }\n    double width()  { return this.width; }\n\n    // Implementation of equals() and hashCode(), which specify\n    // that two record objects are equal if they\n    // are of the same type and contain equal field values.\n    public boolean equals...\n    public int hashCode...\n\n    // An implementation of toString() that returns a string\n    // representation of all the record class's fields,\n    // including their names.\n    public String toString() {...}\n}\n</code></pre> <p>Beachten Sie, dass <code>record</code>-Klassen automatisch <code>final</code> sind und dass man also nicht von ihnen erben kann. Au\u00dferdem sind <code>record</code>-Klassen stets unver\u00e4nderlich (die Objektvariablen erhalten genau einmal einen Wert und sind <code>final</code>).</p>"},{"location":"wrapper/","title":"Wrapper-Klassen","text":"<p>Motivation</p> <p>Letzte Woche haben wir mit folgender Fragestellung geendet: Wie wandeln wir einen <code>String</code> zu einem <code>int</code> (oder <code>double</code>) um? Die Antwort, die uns den Ausblick auf das Thema der heutigen Woche gibt, war: mit Wrapper-Klassen.</p> <p>In Programmierung I haben wir am Anfang die Datentypen <code>int</code>, <code>boolean</code>, <code>double</code>, <code>char</code>, <code>long</code> usw. kennengelernt. Wir haben diese Datentypen als Wertetypen kennenglernt, denn sie k\u00f6nnen nur Werte abbilden. Das Gegenst\u00fcck dazu sind Referenztypen, welche Referenzen auf Objekte repr\u00e4sentieren. F\u00fcr jeden Wertetyp gibt es aber auch einen entsprechenden Referenztyp, die sogenannten Wrapper-Klassen. Diese sind <code>Integer</code>, <code>Double</code>, <code>Float</code>, <code>Short</code>, <code>Byte</code>, <code>Long</code>, <code>Character</code> und <code>Boolean</code> und befinden sich im <code>java.lang</code>-Paket (also dem Standardpaket von Java - muss nicht importiert werden). Wir werden diese Wrapper-Klassen dieses Semester h\u00e4ufiger verwenden, insbesondere wenn wir Collections kennenlernen. </p> <p>Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" (wrappen) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel <code>int</code> \u2194 <code>Integer</code> verdeutlichen:</p> <p></p> <p>Der <code>int</code>-Wert <code>10</code> wird zu einem Typ <code>Integer</code> und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von Referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. </p> <p>Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von <code>boolean</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code> und <code>double</code> so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von <code>char</code> <code>Character</code> und die Wrapper-Klasse von <code>int</code> <code>Integer</code>. </p>  Wertetyp  Referenztyp (Wrapper-Klasse)  <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>boolean</code> <code>Boolean</code> <code>char</code> <code>Character</code>"},{"location":"wrapper/#objekterzeugung","title":"Objekterzeugung","text":"<p>Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen:</p> <ul> <li>Verwendung des Kontruktors, Parameterwert entweder vom Typ <code>String</code> oder vom entsprechenden Wertetyp,</li> <li>Verwendung der statischen Methode <code>valueOf()</code>,  Parameterwert entweder vom Typ <code>String</code> oder vom entsprechenden Wertetyp,</li> <li>sogenanntes Boxing (automatisches wrappen eins Wertes in seinen Referenztyp).</li> </ul> <p>Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von <code>Integer</code> an. Es gilt aber f\u00fcr alle Wrapper-Klassen. </p>"},{"location":"wrapper/#verwendung-des-kontruktors-deprecated","title":"Verwendung des Kontruktors - deprecated","text":"<p>F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von <code>Integer</code> als ein <code>int</code>-Wert) oder es wird ein <code>String</code> \u00fcbergeben, der idealerweise einen passenden Wert ent\u00e4lt, also f\u00fcr <code>Integer</code> soll der <code>String</code> eine Zahl enthalten. Am Beispiel von <code>Integer</code> k\u00f6nnte das z.B. so aussehen:</p> <pre><code>// Konstruktor mit Uebergabe Wertetyp\nint i = 100;\nInteger iObject1 = new Integer(i);\nInteger iObject2 = new Integer(100);\n\n// Konstruktor mit Uebergabe String\nString s = \"100\";\nInteger iObject3 = new Integer(s);\nInteger iObject4 = new Integer(\"100\");\n\n// Moeglich f\u00fcr alle numerischen Datentypen und boolean\n</code></pre> <p>F\u00fcr <code>Character</code> gibt es nur einen parametrisierten Konstruktor: <code>Character\u200b(char value)</code>. Die \u00dcbergabe eines <code>Strings</code> ist dort nicht m\u00f6glich. </p> <p>Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated, sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden <code>valueOf()</code> zu verwenden. </p>"},{"location":"wrapper/#die-valueof-methoden","title":"Die <code>valueOf()</code>-Methoden","text":"<p>Die <code>valueOf()</code>-Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften:</p> <ol> <li>sie sind statisch, d.h. der Aufruf erfolgt \u00fcber <code>Klassenname.valueOf()</code>,</li> <li>sie sind sogenannte Erzeugermethoden, denn sie geben ein Objekt der Klasse zur\u00fcck</li> </ol> <p>Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein <code>String</code> \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele</p> <pre><code>// Wrapper-Klassen haben die Klassenmethoden\n// valueOf(Wertetyp b) ...\nInteger iObject1 = Integer.valueOf(100);\nBoolean bObject1 = Boolean.valueOf(true);\nDouble  dObject1 = Double.valueOf(5.5);\n\n// ... oder valueOf(String s)\nInteger iObject2 = Integer.valueOf(\"100\");\nBoolean bObject2 = Boolean.valueOf(\"true\");\nDouble  dObject2 = Double.valueOf(\"5.5\");\n</code></pre> <p>Auch hier gilt wieder, dass f\u00fcr <code>Character</code> nur eine <code>valueOf()</code>-Methode existiert, n\u00e4mlich <code>valueOf(char c)</code>. Die \u00dcbergabe eines <code>Strings</code> ist nicht m\u00f6glich. </p>"},{"location":"wrapper/#auto-boxing","title":"Auto-Boxing","text":"<p>Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing.  Beispiele:</p> <pre><code>Integer   io1 = 100;\nBoolean   bo1 = true;\nCharacter co1 = 'a';\nDouble    do1 = 5.5;\nFloat     fo1 = 2.7f;\nLong      lo1 = 1234L;\n</code></pre> <p>Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter <code>Eclipse</code> \u2192 <code>Preferences</code> \u2192 <code>Java</code> \u2192 <code>Compiler</code> \u2192 <code>Errors/Warnings</code> folgende Einstellungen:</p> <p></p> <p>\u00dcbung</p> <p>Was wird ausgegeben und warum?  <pre><code>    Integer i1 = 5000;\n    Integer i2 = 5000;\n\n    System.out.println(i1 == i2);\n</code></pre></p>"},{"location":"wrapper/#werte-extrahieren","title":"Werte extrahieren","text":"<p>H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher <code>int</code>-Wert von einem <code>Integer</code>-Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <code>&lt;wrapperTyp&gt;Value()</code>-Objektmethoden zur Verf\u00fcgung also: <code>intValue()</code>, <code>doubleValue()</code>, <code>charValue()</code>, <code>booleanValue()</code> usw. Betrachten wir nochmal die Beispiele von eben:</p> <pre><code>Integer   io1 = 100;\nBoolean   bo1 = true;\nCharacter co1 = 'a';\nDouble    do1 = 5.5;\nFloat     fo1 = 2.7f;\nLong      lo1 = 1234L;\n\nint     i1 = io1.intValue();        // 100\nboolean b1 = bo1.booleanValue();    // true\nchar    c1 = co1.charValue();       // 'a'\ndouble  d1 = do1.doubleValue();     // 5.5\nfloat   f1 = fo1.floatValue();      // 2.7\nlong    l1 = lo1.longValue();       // 1234\n</code></pre> <p>Aber auch hier gibt es wieder ein Auto-Unboxing. Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <code>&lt;wrapperTyp&gt;Value()</code>-Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben:</p> <pre><code>int     i2 = io1;   // 100\nboolean b2 = bo1;   // true\nchar    c2 = co1;   // 'a'\ndouble  d2 = do1;   // 5.5\nfloat   f2 = fo1;   // 2.7\nlong    l2 = lo1;   // 1234\n</code></pre> <p>Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. </p> <p>\u00dcbung</p> <p>Geht das und wenn ja, warum? Was wird jeweils ausgegeben? <pre><code>    Integer i1 = 5000;\n    Integer i2 = 5000;\n    Integer i3 = 5001;\n\n    System.out.println(i1 &gt;= i2);\n    System.out.println(i3 &gt; i2);\n</code></pre></p> <p>Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von <code>Double</code>. Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden <code>String</code> erzeugt werden kann, indem die statische <code>&lt;WrapperTyp&gt;.parse&lt;WrapperTyp&gt;</code>-Methode verwendet wird. </p> <p></p>"},{"location":"wrapper/#strings-in-wertetypen","title":"Strings in Wertetypen","text":"<p>Wir wissen jetzt schon, dass wir uns mithilfe der <code>valueOf(String s)</code>-Methode Objekte einer Wrapper-Klasse erzeugen k\u00f6nnen. Unter Verwendung von <code>intValue()</code> k\u00f6nnte man z.B. aus einem <code>Intger</code>-Objekt den <code>int</code>-Wert extrahieren. Das ginge auch mit Auto-Unboxing. F\u00fcr die Umwandlung von <code>String</code> nach <code>int</code> verwendet man aber am besten die <code>parseInt()</code>-Methode. </p> <pre><code>String eingabe = JOptionPane.showInputDialog(\"Geben Sie eine Zahl ein: \");\nint zahl = Integer.parseInt(eingabe);\n</code></pre> <p>F\u00fcr <code>double</code> steht uns daf\u00fcr <code>Double.parseDouble(String s)</code> zur Verf\u00fcgung usw. </p> <p>Success</p> <p>Jetzt haben wir unser Problem gel\u00f6st, wir k\u00f6nnen <code>String</code> in einen <code>int</code> umwandeln! Wir kennen nun Wrapper-Klassen und deren <code>parseXXX(String)</code>-Methoden.</p>"},{"location":"wrapper/#links-zu-den-java-docs","title":"Links zu den Java-Docs","text":"<p>Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. </p> <ul> <li>Boolean</li> <li>Byte</li> <li>Character</li> <li>Double</li> <li>Float</li> <li>Integer</li> <li>Long</li> <li>Short</li> </ul> <p>\u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number. Diese enth\u00e4lt die Objektmethoden <code>byteValue()</code>, <code>doubleValue()</code>, <code>floatValue()</code>, <code>intValue()</code>, <code>longValue()</code> und <code>shortValue()</code>. Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. </p> <p>\u00dcbung</p> <p>Diese \u00dcbung gibt ein Hinweis auf das folgende Thema: Schauen Sie sich einmal die Java-Dokumentation der Klasse <code>Integer</code> an. Welche Exception kann die <code>parseInt(String)</code>-Methode werfen? </p>"},{"location":"wrapper/#ausblick","title":"Ausblick","text":"<p>Wir wissen nun, wie wir einen <code>String</code> in ein <code>int</code> umwandeln. N\u00e4mlich mithilfe der <code>parseInt(String)</code>-Methode der Klasse <code>Integer</code>. Was aber passiert, wenn der <code>String</code> gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?</p>"}]}